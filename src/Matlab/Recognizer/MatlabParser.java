// $ANTLR 3.5.2 D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3 2016-08-15 16:06:53

package Matlab.Recognizer;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


@SuppressWarnings("all")
public class MatlabParser extends MatlabParserBase {
	public static final String[] tokenNames = new String[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASPECT", "ASSIGN", "AT", 
		"BANG_MODE", "BLOCKCOMMENT", "BREAK", "CASE", "CATCH", "CLASSDEF", "COLON", 
		"COMMA", "COMMAND", "COMMAND_MODE", "CONTINUE", "CTRANS", "DEFAULTBLOCK", 
		"DEFAULTBLOCK1", "DEFAULTBLOCK2", "DEFAULTBLOCK3", "DEFAULTBLOCK4", "DEFAULT_MODE", 
		"DIGIT", "DOT", "DOTDOT", "ELLIPSIS", "ELSE", "ELSEIF", "END", "EOL", 
		"EQ", "EXCLAMATION", "EXP", "FOR", "FUNCTION", "GLOBAL", "GT", "GTEQ", 
		"ID", "IF", "IMAGINARY", "IMG", "LCURLY", "LDIV", "LETTER", "LINE", "LINECOMMENT", 
		"LINECOMMENT1", "LINECOMMENT2", "LINECOMMENT3", "LPAREN", "LSQUARE", "LT", 
		"LTEQ", "MINUS", "MLDIV", "MPOW", "MRDIV", "MTIMES", "NOT", "NOTEQ", "NUMBER", 
		"OR", "OTHERWISE", "PARFOR", "PERSISTENT", "PLUS", "POINT", "POW", "QUESTION", 
		"QUOTATION", "RCURLY", "RDIV", "REAL", "RETURN", "RPAREN", "RSQUARE", 
		"SEMICOLON", "SHORTAND", "SHORTOR", "SIGN", "SPACES", "SPMD", "START", 
		"STRING", "STRINGBLOCK", "SWITCH", "TIMES", "TRANS", "TRY", "UNKNOWN", 
		"WHILE", "WS", "ABORT", "ACTION", "ALL", "ANONYMOUSFUNCTION", "ASPECTACTION", 
		"ASPECTACTIONSECTION", "ASPECTANNOTATE", "ASPECTCALL", "ASPECTDEF", "ASPECTDIMENSION", 
		"ASPECTDIMENSIONSIGNATURE", "ASPECTEXECUTION", "ASPECTFILE", "ASPECTFULLSIGNATURE", 
		"ASPECTGET", "ASPECTINPUT", "ASPECTISTYPE", "ASPECTLOOP", "ASPECTLOOPBODY", 
		"ASPECTLOOPHEAD", "ASPECTMAINEXECUTION", "ASPECTNAME", "ASPECTOPERATOR", 
		"ASPECTOUTPUT", "ASPECTPATTERN", "ASPECTPATTERNSECTION", "ASPECTSELECTORCOMPOUND", 
		"ASPECTSELECTORSIMPLE", "ASPECTSET", "ASPECTTYPESIGNATURE", "ASPECTWITHIN", 
		"ATBASE", "ATTRIBUTE", "CELLARRAY", "CLASSFILE", "CLASSREF", "CURLYBRACE", 
		"DOTEXPRESSION", "DOTNAME", "ENUMERATION", "ENUMERATIONSECTION", "EVENT", 
		"EVENTSECTION", "EXTERNALMETHOD", "FUNCTIONFILE", "FUNCTIONHANDLE", "FUNCTIONREF", 
		"HCAT", "IFELSE", "INPUT", "METHODSECTION", "NAME", "NEGATIVE", "NESTEDFUNCTION", 
		"NOPRINT", "OUTPUT", "PARENTHESIS", "POSITIVE", "PRINT", "PROPERTY", "PROPERTYSECTION", 
		"REGULARARRAY", "REGULARMETHOD", "SCRIPTFILE", "STORAGE", "SWITCHCASE", 
		"TRYCATCH", "VAR", "VCAT"
	};
	public static final int EOF=-1;
	public static final int AND=4;
	public static final int ASPECT=5;
	public static final int ASSIGN=6;
	public static final int AT=7;
	public static final int BANG_MODE=8;
	public static final int BLOCKCOMMENT=9;
	public static final int BREAK=10;
	public static final int CASE=11;
	public static final int CATCH=12;
	public static final int CLASSDEF=13;
	public static final int COLON=14;
	public static final int COMMA=15;
	public static final int COMMAND=16;
	public static final int COMMAND_MODE=17;
	public static final int CONTINUE=18;
	public static final int CTRANS=19;
	public static final int DEFAULTBLOCK=20;
	public static final int DEFAULTBLOCK1=21;
	public static final int DEFAULTBLOCK2=22;
	public static final int DEFAULTBLOCK3=23;
	public static final int DEFAULTBLOCK4=24;
	public static final int DEFAULT_MODE=25;
	public static final int DIGIT=26;
	public static final int DOT=27;
	public static final int DOTDOT=28;
	public static final int ELLIPSIS=29;
	public static final int ELSE=30;
	public static final int ELSEIF=31;
	public static final int END=32;
	public static final int EOL=33;
	public static final int EQ=34;
	public static final int EXCLAMATION=35;
	public static final int EXP=36;
	public static final int FOR=37;
	public static final int FUNCTION=38;
	public static final int GLOBAL=39;
	public static final int GT=40;
	public static final int GTEQ=41;
	public static final int ID=42;
	public static final int IF=43;
	public static final int IMAGINARY=44;
	public static final int IMG=45;
	public static final int LCURLY=46;
	public static final int LDIV=47;
	public static final int LETTER=48;
	public static final int LINE=49;
	public static final int LINECOMMENT=50;
	public static final int LINECOMMENT1=51;
	public static final int LINECOMMENT2=52;
	public static final int LINECOMMENT3=53;
	public static final int LPAREN=54;
	public static final int LSQUARE=55;
	public static final int LT=56;
	public static final int LTEQ=57;
	public static final int MINUS=58;
	public static final int MLDIV=59;
	public static final int MPOW=60;
	public static final int MRDIV=61;
	public static final int MTIMES=62;
	public static final int NOT=63;
	public static final int NOTEQ=64;
	public static final int NUMBER=65;
	public static final int OR=66;
	public static final int OTHERWISE=67;
	public static final int PARFOR=68;
	public static final int PERSISTENT=69;
	public static final int PLUS=70;
	public static final int POINT=71;
	public static final int POW=72;
	public static final int QUESTION=73;
	public static final int QUOTATION=74;
	public static final int RCURLY=75;
	public static final int RDIV=76;
	public static final int REAL=77;
	public static final int RETURN=78;
	public static final int RPAREN=79;
	public static final int RSQUARE=80;
	public static final int SEMICOLON=81;
	public static final int SHORTAND=82;
	public static final int SHORTOR=83;
	public static final int SIGN=84;
	public static final int SPACES=85;
	public static final int SPMD=86;
	public static final int START=87;
	public static final int STRING=88;
	public static final int STRINGBLOCK=89;
	public static final int SWITCH=90;
	public static final int TIMES=91;
	public static final int TRANS=92;
	public static final int TRY=93;
	public static final int UNKNOWN=94;
	public static final int WHILE=95;
	public static final int WS=96;
	public static final int ABORT=97;
	public static final int ACTION=98;
	public static final int ALL=99;
	public static final int ANONYMOUSFUNCTION=100;
	public static final int ASPECTACTION=101;
	public static final int ASPECTACTIONSECTION=102;
	public static final int ASPECTANNOTATE=103;
	public static final int ASPECTCALL=104;
	public static final int ASPECTDEF=105;
	public static final int ASPECTDIMENSION=106;
	public static final int ASPECTDIMENSIONSIGNATURE=107;
	public static final int ASPECTEXECUTION=108;
	public static final int ASPECTFILE=109;
	public static final int ASPECTFULLSIGNATURE=110;
	public static final int ASPECTGET=111;
	public static final int ASPECTINPUT=112;
	public static final int ASPECTISTYPE=113;
	public static final int ASPECTLOOP=114;
	public static final int ASPECTLOOPBODY=115;
	public static final int ASPECTLOOPHEAD=116;
	public static final int ASPECTMAINEXECUTION=117;
	public static final int ASPECTNAME=118;
	public static final int ASPECTOPERATOR=119;
	public static final int ASPECTOUTPUT=120;
	public static final int ASPECTPATTERN=121;
	public static final int ASPECTPATTERNSECTION=122;
	public static final int ASPECTSELECTORCOMPOUND=123;
	public static final int ASPECTSELECTORSIMPLE=124;
	public static final int ASPECTSET=125;
	public static final int ASPECTTYPESIGNATURE=126;
	public static final int ASPECTWITHIN=127;
	public static final int ATBASE=128;
	public static final int ATTRIBUTE=129;
	public static final int CELLARRAY=130;
	public static final int CLASSFILE=131;
	public static final int CLASSREF=132;
	public static final int CURLYBRACE=133;
	public static final int DOTEXPRESSION=134;
	public static final int DOTNAME=135;
	public static final int ENUMERATION=136;
	public static final int ENUMERATIONSECTION=137;
	public static final int EVENT=138;
	public static final int EVENTSECTION=139;
	public static final int EXTERNALMETHOD=140;
	public static final int FUNCTIONFILE=141;
	public static final int FUNCTIONHANDLE=142;
	public static final int FUNCTIONREF=143;
	public static final int HCAT=144;
	public static final int IFELSE=145;
	public static final int INPUT=146;
	public static final int METHODSECTION=147;
	public static final int NAME=148;
	public static final int NEGATIVE=149;
	public static final int NESTEDFUNCTION=150;
	public static final int NOPRINT=151;
	public static final int OUTPUT=152;
	public static final int PARENTHESIS=153;
	public static final int POSITIVE=154;
	public static final int PRINT=155;
	public static final int PROPERTY=156;
	public static final int PROPERTYSECTION=157;
	public static final int REGULARARRAY=158;
	public static final int REGULARMETHOD=159;
	public static final int SCRIPTFILE=160;
	public static final int STORAGE=161;
	public static final int SWITCHCASE=162;
	public static final int TRYCATCH=163;
	public static final int VAR=164;
	public static final int VCAT=165;

	// delegates
	public MatlabParserBase[] getDelegates() {
		return new MatlabParserBase[] {};
	}

	// delegators


	public MatlabParser(TokenStream input) {
		this(input, new RecognizerSharedState());
	}
	public MatlabParser(TokenStream input, RecognizerSharedState state) {
		super(input, state);
	}

	protected TreeAdaptor adaptor = new CommonTreeAdaptor();

	public void setTreeAdaptor(TreeAdaptor adaptor) {
		this.adaptor = adaptor;
	}
	public TreeAdaptor getTreeAdaptor() {
		return adaptor;
	}
	@Override public String[] getTokenNames() { return MatlabParser.tokenNames; }
	@Override public String getGrammarFileName() { return "D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3"; }


	public static class file_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "file"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:57:8: public file : ( scriptFile -> scriptFile | functionFile -> functionFile | classFile -> classFile | aspectFile -> aspectFile );
	public final MatlabParser.file_return file() throws RecognitionException {
		MatlabParser.file_return retval = new MatlabParser.file_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope scriptFile1 =null;
		ParserRuleReturnScope functionFile2 =null;
		ParserRuleReturnScope classFile3 =null;
		ParserRuleReturnScope aspectFile4 =null;

		RewriteRuleSubtreeStream stream_classFile=new RewriteRuleSubtreeStream(adaptor,"rule classFile");
		RewriteRuleSubtreeStream stream_functionFile=new RewriteRuleSubtreeStream(adaptor,"rule functionFile");
		RewriteRuleSubtreeStream stream_aspectFile=new RewriteRuleSubtreeStream(adaptor,"rule aspectFile");
		RewriteRuleSubtreeStream stream_scriptFile=new RewriteRuleSubtreeStream(adaptor,"rule scriptFile");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:57:13: ( scriptFile -> scriptFile | functionFile -> functionFile | classFile -> classFile | aspectFile -> aspectFile )
			int alt1=4;
			alt1 = dfa1.predict(input);
			switch (alt1) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:57:15: scriptFile
					{
					pushFollow(FOLLOW_scriptFile_in_file391);
					scriptFile1=scriptFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_scriptFile.add(scriptFile1.getTree());
					// AST REWRITE
					// elements: scriptFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 57:26: -> scriptFile
					{
						adaptor.addChild(root_0, stream_scriptFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:58:6: functionFile
					{
					pushFollow(FOLLOW_functionFile_in_file402);
					functionFile2=functionFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_functionFile.add(functionFile2.getTree());
					// AST REWRITE
					// elements: functionFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 58:19: -> functionFile
					{
						adaptor.addChild(root_0, stream_functionFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:59:6: classFile
					{
					pushFollow(FOLLOW_classFile_in_file413);
					classFile3=classFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_classFile.add(classFile3.getTree());
					// AST REWRITE
					// elements: classFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 59:16: -> classFile
					{
						adaptor.addChild(root_0, stream_classFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:60:6: aspectFile
					{
					pushFollow(FOLLOW_aspectFile_in_file424);
					aspectFile4=aspectFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFile.add(aspectFile4.getTree());
					// AST REWRITE
					// elements: aspectFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 60:17: -> aspectFile
					{
						adaptor.addChild(root_0, stream_aspectFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "file"


	public static class scriptFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "scriptFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:1: scriptFile : statements EOF -> ^( SCRIPTFILE[\"\"] ( statements )? ) ;
	public final MatlabParser.scriptFile_return scriptFile() throws RecognitionException {
		MatlabParser.scriptFile_return retval = new MatlabParser.scriptFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOF6=null;
		ParserRuleReturnScope statements5 =null;

		Object EOF6_tree=null;
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:12: ( statements EOF -> ^( SCRIPTFILE[\"\"] ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:14: statements EOF
			{
			pushFollow(FOLLOW_statements_in_scriptFile442);
			statements5=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements5.getTree());
			EOF6=(Token)match(input,EOF,FOLLOW_EOF_in_scriptFile444); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF6);

			// AST REWRITE
			// elements: statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 65:29: -> ^( SCRIPTFILE[\"\"] ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:32: ^( SCRIPTFILE[\"\"] ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SCRIPTFILE, ""), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:49: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "scriptFile"


	public static class statements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "statements"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:1: statements : ( statement | xEOS )* -> ( statement )* ;
	public final MatlabParser.statements_return statements() throws RecognitionException {
		MatlabParser.statements_return retval = new MatlabParser.statements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope statement7 =null;
		ParserRuleReturnScope xEOS8 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:12: ( ( statement | xEOS )* -> ( statement )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:14: ( statement | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:14: ( statement | xEOS )*
			loop2:
			while (true) {
				int alt2=3;
				int LA2_0 = input.LA(1);
				if ( (LA2_0==END) ) {
					int LA2_2 = input.LA(2);
					if ( (LA2_2==SEMICOLON) ) {
						int LA2_7 = input.LA(3);
						if ( (((Index_IsActive())&&(True()))) ) {
							alt2=1;
						}

					}
					else if ( (LA2_2==COMMA) ) {
						int LA2_8 = input.LA(3);
						if ( (((Index_IsActive())&&(True()))) ) {
							alt2=1;
						}

					}
					else if ( (LA2_2==EOL) ) {
						int LA2_9 = input.LA(3);
						if ( (((Index_IsActive())&&(True()))) ) {
							alt2=1;
						}

					}
					else if ( (LA2_2==AND||LA2_2==COLON||LA2_2==CTRANS||LA2_2==EQ||(LA2_2 >= GT && LA2_2 <= GTEQ)||LA2_2==LDIV||(LA2_2 >= LT && LA2_2 <= MTIMES)||LA2_2==NOTEQ||LA2_2==OR||LA2_2==PLUS||LA2_2==POW||LA2_2==RDIV||(LA2_2 >= SHORTAND && LA2_2 <= SHORTOR)||(LA2_2 >= TIMES && LA2_2 <= TRANS)) && (((Index_IsActive())&&(True())))) {
						alt2=1;
					}

				}
				else if ( (LA2_0==ID) && (((Command_IsEnabled())||(True())))) {
					alt2=1;
				}
				else if ( (LA2_0==AT||LA2_0==IMAGINARY||LA2_0==LCURLY||(LA2_0 >= LPAREN && LA2_0 <= LSQUARE)||LA2_0==MINUS||LA2_0==NOT||LA2_0==PLUS||LA2_0==QUESTION||LA2_0==REAL||LA2_0==STRING) && ((True()))) {
					alt2=1;
				}
				else if ( (LA2_0==BREAK||LA2_0==COMMAND||LA2_0==CONTINUE||LA2_0==EXCLAMATION||LA2_0==FOR||LA2_0==GLOBAL||LA2_0==IF||(LA2_0 >= PARFOR && LA2_0 <= PERSISTENT)||LA2_0==RETURN||LA2_0==SPMD||LA2_0==SWITCH||LA2_0==TRY||LA2_0==WHILE) ) {
					alt2=1;
				}
				else if ( (LA2_0==COMMA||LA2_0==EOL||LA2_0==SEMICOLON) ) {
					alt2=2;
				}

				switch (alt2) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:15: statement
					{
					pushFollow(FOLLOW_statement_in_statements466);
					statement7=statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_statement.add(statement7.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:27: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_statements470);
					xEOS8=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS8.getTree());
					}
					break;

				default :
					break loop2;
				}
			}

			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 67:34: -> ( statement )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:37: ( statement )*
				while ( stream_statement.hasNext() ) {
					adaptor.addChild(root_0, stream_statement.nextTree());
				}
				stream_statement.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "statements"


	public static class functionFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:1: functionFile : ( ( openFunctionFile )=> openFunctionFile -> openFunctionFile | closeFunctionFile -> closeFunctionFile );
	public final MatlabParser.functionFile_return functionFile() throws RecognitionException {
		MatlabParser.functionFile_return retval = new MatlabParser.functionFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope openFunctionFile9 =null;
		ParserRuleReturnScope closeFunctionFile10 =null;

		RewriteRuleSubtreeStream stream_closeFunctionFile=new RewriteRuleSubtreeStream(adaptor,"rule closeFunctionFile");
		RewriteRuleSubtreeStream stream_openFunctionFile=new RewriteRuleSubtreeStream(adaptor,"rule openFunctionFile");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:14: ( ( openFunctionFile )=> openFunctionFile -> openFunctionFile | closeFunctionFile -> closeFunctionFile )
			int alt3=2;
			int LA3_0 = input.LA(1);
			if ( (LA3_0==EOL) ) {
				int LA3_1 = input.LA(2);
				if ( (synpred1_MatlabParser()) ) {
					alt3=1;
				}
				else if ( (true) ) {
					alt3=2;
				}

			}
			else if ( (LA3_0==FUNCTION) ) {
				int LA3_2 = input.LA(2);
				if ( (synpred1_MatlabParser()) ) {
					alt3=1;
				}
				else if ( (true) ) {
					alt3=2;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 3, 0, input);
				throw nvae;
			}

			switch (alt3) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:16: ( openFunctionFile )=> openFunctionFile
					{
					pushFollow(FOLLOW_openFunctionFile_in_functionFile495);
					openFunctionFile9=openFunctionFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_openFunctionFile.add(openFunctionFile9.getTree());
					// AST REWRITE
					// elements: openFunctionFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 71:54: -> openFunctionFile
					{
						adaptor.addChild(root_0, stream_openFunctionFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:72:7: closeFunctionFile
					{
					pushFollow(FOLLOW_closeFunctionFile_in_functionFile507);
					closeFunctionFile10=closeFunctionFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeFunctionFile.add(closeFunctionFile10.getTree());
					// AST REWRITE
					// elements: closeFunctionFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 72:25: -> closeFunctionFile
					{
						adaptor.addChild(root_0, stream_closeFunctionFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionFile"


	public static class openFunctionFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openFunctionFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:1: openFunctionFile : ( EOL )* openFunctions EOF -> ^( FUNCTIONFILE[\"\"] openFunctions ) ;
	public final MatlabParser.openFunctionFile_return openFunctionFile() throws RecognitionException {
		MatlabParser.openFunctionFile_return retval = new MatlabParser.openFunctionFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL11=null;
		Token EOF13=null;
		ParserRuleReturnScope openFunctions12 =null;

		Object EOL11_tree=null;
		Object EOF13_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_openFunctions=new RewriteRuleSubtreeStream(adaptor,"rule openFunctions");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:18: ( ( EOL )* openFunctions EOF -> ^( FUNCTIONFILE[\"\"] openFunctions ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:20: ( EOL )* openFunctions EOF
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:20: ( EOL )*
			loop4:
			while (true) {
				int alt4=2;
				int LA4_0 = input.LA(1);
				if ( (LA4_0==EOL) ) {
					alt4=1;
				}

				switch (alt4) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:21: EOL
					{
					EOL11=(Token)match(input,EOL,FOLLOW_EOL_in_openFunctionFile527); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL11);

					}
					break;

				default :
					break loop4;
				}
			}

			pushFollow(FOLLOW_openFunctions_in_openFunctionFile531);
			openFunctions12=openFunctions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_openFunctions.add(openFunctions12.getTree());
			EOF13=(Token)match(input,EOF,FOLLOW_EOF_in_openFunctionFile533); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF13);

			// AST REWRITE
			// elements: openFunctions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 77:45: -> ^( FUNCTIONFILE[\"\"] openFunctions )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:48: ^( FUNCTIONFILE[\"\"] openFunctions )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNCTIONFILE, ""), root_1);
				adaptor.addChild(root_1, stream_openFunctions.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openFunctionFile"


	public static class openFunctions_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openFunctions"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:1: openFunctions : ( openFunction )+ -> ( openFunction )+ ;
	public final MatlabParser.openFunctions_return openFunctions() throws RecognitionException {
		MatlabParser.openFunctions_return retval = new MatlabParser.openFunctions_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope openFunction14 =null;

		RewriteRuleSubtreeStream stream_openFunction=new RewriteRuleSubtreeStream(adaptor,"rule openFunction");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:15: ( ( openFunction )+ -> ( openFunction )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:17: ( openFunction )+
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:17: ( openFunction )+
			int cnt5=0;
			loop5:
			while (true) {
				int alt5=2;
				int LA5_0 = input.LA(1);
				if ( (LA5_0==FUNCTION) ) {
					alt5=1;
				}

				switch (alt5) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:18: openFunction
					{
					pushFollow(FOLLOW_openFunction_in_openFunctions552);
					openFunction14=openFunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_openFunction.add(openFunction14.getTree());
					}
					break;

				default :
					if ( cnt5 >= 1 ) break loop5;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(5, input);
					throw eee;
				}
				cnt5++;
			}

			// AST REWRITE
			// elements: openFunction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 79:33: -> ( openFunction )+
			{
				if ( !(stream_openFunction.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_openFunction.hasNext() ) {
					adaptor.addChild(root_0, stream_openFunction.nextTree());
				}
				stream_openFunction.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openFunctions"


	public static class openFunction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openFunction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:1: openFunction : FUNCTION functionSignature openBody -> ^( FUNCTION functionSignature ( openBody )? ) ;
	public final MatlabParser.openFunction_return openFunction() throws RecognitionException {
		MatlabParser.openFunction_return retval = new MatlabParser.openFunction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION15=null;
		ParserRuleReturnScope functionSignature16 =null;
		ParserRuleReturnScope openBody17 =null;

		Object FUNCTION15_tree=null;
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_functionSignature=new RewriteRuleSubtreeStream(adaptor,"rule functionSignature");
		RewriteRuleSubtreeStream stream_openBody=new RewriteRuleSubtreeStream(adaptor,"rule openBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:14: ( FUNCTION functionSignature openBody -> ^( FUNCTION functionSignature ( openBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:16: FUNCTION functionSignature openBody
			{
			FUNCTION15=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_openFunction570); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION15);

			pushFollow(FOLLOW_functionSignature_in_openFunction572);
			functionSignature16=functionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_functionSignature.add(functionSignature16.getTree());
			pushFollow(FOLLOW_openBody_in_openFunction574);
			openBody17=openBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_openBody.add(openBody17.getTree());
			// AST REWRITE
			// elements: functionSignature, FUNCTION, openBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 81:52: -> ^( FUNCTION functionSignature ( openBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:55: ^( FUNCTION functionSignature ( openBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_FUNCTION.nextNode(), root_1);
				adaptor.addChild(root_1, stream_functionSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:84: ( openBody )?
				if ( stream_openBody.hasNext() ) {
					adaptor.addChild(root_1, stream_openBody.nextTree());
				}
				stream_openBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openFunction"


	public static class functionSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:1: functionSignature : ( outputPortion functionName ( inputPortion )? -> ( outputPortion )? functionName ( inputPortion )? | name ( inputPortion )? -> name ( inputPortion )? );
	public final MatlabParser.functionSignature_return functionSignature() throws RecognitionException {
		MatlabParser.functionSignature_return retval = new MatlabParser.functionSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope outputPortion18 =null;
		ParserRuleReturnScope functionName19 =null;
		ParserRuleReturnScope inputPortion20 =null;
		ParserRuleReturnScope name21 =null;
		ParserRuleReturnScope inputPortion22 =null;

		RewriteRuleSubtreeStream stream_functionName=new RewriteRuleSubtreeStream(adaptor,"rule functionName");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_outputPortion=new RewriteRuleSubtreeStream(adaptor,"rule outputPortion");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:19: ( outputPortion functionName ( inputPortion )? -> ( outputPortion )? functionName ( inputPortion )? | name ( inputPortion )? -> name ( inputPortion )? )
			int alt8=2;
			int LA8_0 = input.LA(1);
			if ( (LA8_0==ID) ) {
				int LA8_1 = input.LA(2);
				if ( (LA8_1==ASSIGN) ) {
					alt8=1;
				}
				else if ( (LA8_1==EOF||LA8_1==COMMA||(LA8_1 >= END && LA8_1 <= EOL)||LA8_1==FUNCTION||LA8_1==LPAREN||LA8_1==SEMICOLON) ) {
					alt8=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 8, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA8_0==LSQUARE) ) {
				alt8=1;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 8, 0, input);
				throw nvae;
			}

			switch (alt8) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:21: outputPortion functionName ( inputPortion )?
					{
					pushFollow(FOLLOW_outputPortion_in_functionSignature596);
					outputPortion18=outputPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_outputPortion.add(outputPortion18.getTree());
					pushFollow(FOLLOW_functionName_in_functionSignature598);
					functionName19=functionName();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_functionName.add(functionName19.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:48: ( inputPortion )?
					int alt6=2;
					int LA6_0 = input.LA(1);
					if ( (LA6_0==LPAREN) ) {
						alt6=1;
					}
					switch (alt6) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:49: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_functionSignature601);
							inputPortion20=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion20.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: inputPortion, functionName, outputPortion
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 83:64: -> ( outputPortion )? functionName ( inputPortion )?
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:67: ( outputPortion )?
						if ( stream_outputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_outputPortion.nextTree());
						}
						stream_outputPortion.reset();

						adaptor.addChild(root_0, stream_functionName.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:97: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:84:9: name ( inputPortion )?
					{
					pushFollow(FOLLOW_name_in_functionSignature627);
					name21=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(name21.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:84:14: ( inputPortion )?
					int alt7=2;
					int LA7_0 = input.LA(1);
					if ( (LA7_0==LPAREN) ) {
						alt7=1;
					}
					switch (alt7) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:84:15: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_functionSignature630);
							inputPortion22=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion22.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: inputPortion, name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 84:30: -> name ( inputPortion )?
					{
						adaptor.addChild(root_0, stream_name.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:84:38: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionSignature"


	public static class outputPortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "outputPortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:87:1: outputPortion : ( output ASSIGN -> output | outputVector ASSIGN -> ( outputVector )? );
	public final MatlabParser.outputPortion_return outputPortion() throws RecognitionException {
		MatlabParser.outputPortion_return retval = new MatlabParser.outputPortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASSIGN24=null;
		Token ASSIGN26=null;
		ParserRuleReturnScope output23 =null;
		ParserRuleReturnScope outputVector25 =null;

		Object ASSIGN24_tree=null;
		Object ASSIGN26_tree=null;
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_output=new RewriteRuleSubtreeStream(adaptor,"rule output");
		RewriteRuleSubtreeStream stream_outputVector=new RewriteRuleSubtreeStream(adaptor,"rule outputVector");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:87:15: ( output ASSIGN -> output | outputVector ASSIGN -> ( outputVector )? )
			int alt9=2;
			int LA9_0 = input.LA(1);
			if ( (LA9_0==ID) ) {
				alt9=1;
			}
			else if ( (LA9_0==LSQUARE) ) {
				alt9=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 9, 0, input);
				throw nvae;
			}

			switch (alt9) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:87:17: output ASSIGN
					{
					pushFollow(FOLLOW_output_in_outputPortion656);
					output23=output();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_output.add(output23.getTree());
					ASSIGN24=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_outputPortion658); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN24);

					// AST REWRITE
					// elements: output
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 87:31: -> output
					{
						adaptor.addChild(root_0, stream_output.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:88:8: outputVector ASSIGN
					{
					pushFollow(FOLLOW_outputVector_in_outputPortion671);
					outputVector25=outputVector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_outputVector.add(outputVector25.getTree());
					ASSIGN26=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_outputPortion673); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN26);

					// AST REWRITE
					// elements: outputVector
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 88:28: -> ( outputVector )?
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:88:31: ( outputVector )?
						if ( stream_outputVector.hasNext() ) {
							adaptor.addChild(root_0, stream_outputVector.nextTree());
						}
						stream_outputVector.reset();

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "outputPortion"


	public static class output_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "output"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:91:1: output : name -> ^( OUTPUT[\"\"] name ) ;
	public final MatlabParser.output_return output() throws RecognitionException {
		MatlabParser.output_return retval = new MatlabParser.output_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name27 =null;

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:91:8: ( name -> ^( OUTPUT[\"\"] name ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:91:10: name
			{
			pushFollow(FOLLOW_name_in_output694);
			name27=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name27.getTree());
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 91:15: -> ^( OUTPUT[\"\"] name )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:91:18: ^( OUTPUT[\"\"] name )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OUTPUT, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "output"


	public static class name_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "name"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:93:1: name : xID -> ^( NAME[\"\"] xID ) ;
	public final MatlabParser.name_return name() throws RecognitionException {
		MatlabParser.name_return retval = new MatlabParser.name_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xID28 =null;

		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:93:6: ( xID -> ^( NAME[\"\"] xID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:93:8: xID
			{
			pushFollow(FOLLOW_xID_in_name712);
			xID28=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID28.getTree());
			// AST REWRITE
			// elements: xID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 93:12: -> ^( NAME[\"\"] xID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:93:15: ^( NAME[\"\"] xID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name"


	public static class outputVector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "outputVector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:1: outputVector : LSQUARE ( vectorOutputs )? RSQUARE -> ( vectorOutputs )? ;
	public final MatlabParser.outputVector_return outputVector() throws RecognitionException {
		MatlabParser.outputVector_return retval = new MatlabParser.outputVector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE29=null;
		Token RSQUARE31=null;
		ParserRuleReturnScope vectorOutputs30 =null;

		Object LSQUARE29_tree=null;
		Object RSQUARE31_tree=null;
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_vectorOutputs=new RewriteRuleSubtreeStream(adaptor,"rule vectorOutputs");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:14: ( LSQUARE ( vectorOutputs )? RSQUARE -> ( vectorOutputs )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:16: LSQUARE ( vectorOutputs )? RSQUARE
			{
			LSQUARE29=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_outputVector730); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE29);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:24: ( vectorOutputs )?
			int alt10=2;
			int LA10_0 = input.LA(1);
			if ( (LA10_0==ID) ) {
				alt10=1;
			}
			switch (alt10) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:25: vectorOutputs
					{
					pushFollow(FOLLOW_vectorOutputs_in_outputVector733);
					vectorOutputs30=vectorOutputs();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_vectorOutputs.add(vectorOutputs30.getTree());
					}
					break;

			}

			RSQUARE31=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_outputVector737); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE31);

			// AST REWRITE
			// elements: vectorOutputs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 95:49: -> ( vectorOutputs )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:52: ( vectorOutputs )?
				if ( stream_vectorOutputs.hasNext() ) {
					adaptor.addChild(root_0, stream_vectorOutputs.nextTree());
				}
				stream_vectorOutputs.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "outputVector"


	public static class vectorOutputs_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "vectorOutputs"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:1: vectorOutputs : vectorOutput ({...}? => ( COMMA )? vectorOutput )* -> ( vectorOutput )+ ;
	public final MatlabParser.vectorOutputs_return vectorOutputs() throws RecognitionException {
		MatlabParser.vectorOutputs_return retval = new MatlabParser.vectorOutputs_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA33=null;
		ParserRuleReturnScope vectorOutput32 =null;
		ParserRuleReturnScope vectorOutput34 =null;

		Object COMMA33_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_vectorOutput=new RewriteRuleSubtreeStream(adaptor,"rule vectorOutput");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:15: ( vectorOutput ({...}? => ( COMMA )? vectorOutput )* -> ( vectorOutput )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:17: vectorOutput ({...}? => ( COMMA )? vectorOutput )*
			{
			pushFollow(FOLLOW_vectorOutput_in_vectorOutputs753);
			vectorOutput32=vectorOutput();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_vectorOutput.add(vectorOutput32.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:30: ({...}? => ( COMMA )? vectorOutput )*
			loop12:
			while (true) {
				int alt12=2;
				int LA12_0 = input.LA(1);
				if ( (LA12_0==COMMA||LA12_0==ID) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
					alt12=1;
				}

				switch (alt12) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:31: {...}? => ( COMMA )? vectorOutput
					{
					if ( !((Separator_CommaFollowsOrSpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "vectorOutputs", "Separator_CommaFollowsOrSpacesPrecede()");
					}
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:76: ( COMMA )?
					int alt11=2;
					int LA11_0 = input.LA(1);
					if ( (LA11_0==COMMA) ) {
						alt11=1;
					}
					switch (alt11) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:77: COMMA
							{
							COMMA33=(Token)match(input,COMMA,FOLLOW_COMMA_in_vectorOutputs760); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA33);

							}
							break;

					}

					pushFollow(FOLLOW_vectorOutput_in_vectorOutputs764);
					vectorOutput34=vectorOutput();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_vectorOutput.add(vectorOutput34.getTree());
					}
					break;

				default :
					break loop12;
				}
			}

			// AST REWRITE
			// elements: vectorOutput
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 97:100: -> ( vectorOutput )+
			{
				if ( !(stream_vectorOutput.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_vectorOutput.hasNext() ) {
					adaptor.addChild(root_0, stream_vectorOutput.nextTree());
				}
				stream_vectorOutput.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "vectorOutputs"


	public static class vectorOutput_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "vectorOutput"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:1: vectorOutput : name ({...}? => filter )? -> ^( OUTPUT[\"\"] name ( filter )? ) ;
	public final MatlabParser.vectorOutput_return vectorOutput() throws RecognitionException {
		MatlabParser.vectorOutput_return retval = new MatlabParser.vectorOutput_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name35 =null;
		ParserRuleReturnScope filter36 =null;

		RewriteRuleSubtreeStream stream_filter=new RewriteRuleSubtreeStream(adaptor,"rule filter");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:14: ( name ({...}? => filter )? -> ^( OUTPUT[\"\"] name ( filter )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:16: name ({...}? => filter )?
			{
			pushFollow(FOLLOW_name_in_vectorOutput782);
			name35=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name35.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:21: ({...}? => filter )?
			int alt13=2;
			int LA13_0 = input.LA(1);
			if ( (LA13_0==AT) && ((Method_SignatureIsActive()))) {
				alt13=1;
			}
			switch (alt13) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:22: {...}? => filter
					{
					if ( !((Method_SignatureIsActive())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "vectorOutput", "Method_SignatureIsActive()");
					}
					pushFollow(FOLLOW_filter_in_vectorOutput788);
					filter36=filter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_filter.add(filter36.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: filter, name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 99:63: -> ^( OUTPUT[\"\"] name ( filter )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:66: ^( OUTPUT[\"\"] name ( filter )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OUTPUT, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:84: ( filter )?
				if ( stream_filter.hasNext() ) {
					adaptor.addChild(root_1, stream_filter.nextTree());
				}
				stream_filter.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "vectorOutput"


	public static class filter_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "filter"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:101:1: filter : AT classReference -> classReference ;
	public final MatlabParser.filter_return filter() throws RecognitionException {
		MatlabParser.filter_return retval = new MatlabParser.filter_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AT37=null;
		ParserRuleReturnScope classReference38 =null;

		Object AT37_tree=null;
		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:101:8: ( AT classReference -> classReference )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:101:10: AT classReference
			{
			AT37=(Token)match(input,AT,FOLLOW_AT_in_filter813); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_AT.add(AT37);

			pushFollow(FOLLOW_classReference_in_filter815);
			classReference38=classReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classReference.add(classReference38.getTree());
			// AST REWRITE
			// elements: classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 101:28: -> classReference
			{
				adaptor.addChild(root_0, stream_classReference.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "filter"


	public static class functionName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:103:1: functionName : xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) ;
	public final MatlabParser.functionName_return functionName() throws RecognitionException {
		MatlabParser.functionName_return retval = new MatlabParser.functionName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xFUNCTIONID39 =null;

		RewriteRuleSubtreeStream stream_xFUNCTIONID=new RewriteRuleSubtreeStream(adaptor,"rule xFUNCTIONID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:103:14: ( xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:103:16: xFUNCTIONID
			{
			pushFollow(FOLLOW_xFUNCTIONID_in_functionName828);
			xFUNCTIONID39=xFUNCTIONID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xFUNCTIONID.add(xFUNCTIONID39.getTree());
			// AST REWRITE
			// elements: xFUNCTIONID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 103:28: -> ^( NAME[\"\"] xFUNCTIONID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:103:31: ^( NAME[\"\"] xFUNCTIONID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xFUNCTIONID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionName"


	public static class inputPortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "inputPortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:1: inputPortion : LPAREN ( parameters )? RPAREN -> ( parameters )? ;
	public final MatlabParser.inputPortion_return inputPortion() throws RecognitionException {
		MatlabParser.inputPortion_return retval = new MatlabParser.inputPortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN40=null;
		Token RPAREN42=null;
		ParserRuleReturnScope parameters41 =null;

		Object LPAREN40_tree=null;
		Object RPAREN42_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_parameters=new RewriteRuleSubtreeStream(adaptor,"rule parameters");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:14: ( LPAREN ( parameters )? RPAREN -> ( parameters )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:16: LPAREN ( parameters )? RPAREN
			{
			LPAREN40=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_inputPortion846); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN40);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:23: ( parameters )?
			int alt14=2;
			int LA14_0 = input.LA(1);
			if ( (LA14_0==ID||LA14_0==NOT) ) {
				alt14=1;
			}
			switch (alt14) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:24: parameters
					{
					pushFollow(FOLLOW_parameters_in_inputPortion849);
					parameters41=parameters();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parameters.add(parameters41.getTree());
					}
					break;

			}

			RPAREN42=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_inputPortion853); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN42);

			// AST REWRITE
			// elements: parameters
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 105:44: -> ( parameters )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:47: ( parameters )?
				if ( stream_parameters.hasNext() ) {
					adaptor.addChild(root_0, stream_parameters.nextTree());
				}
				stream_parameters.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "inputPortion"


	public static class parameters_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parameters"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:1: parameters : parameter ( COMMA parameter )* -> ( parameter )+ ;
	public final MatlabParser.parameters_return parameters() throws RecognitionException {
		MatlabParser.parameters_return retval = new MatlabParser.parameters_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA44=null;
		ParserRuleReturnScope parameter43 =null;
		ParserRuleReturnScope parameter45 =null;

		Object COMMA44_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_parameter=new RewriteRuleSubtreeStream(adaptor,"rule parameter");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:12: ( parameter ( COMMA parameter )* -> ( parameter )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:14: parameter ( COMMA parameter )*
			{
			pushFollow(FOLLOW_parameter_in_parameters869);
			parameter43=parameter();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parameter.add(parameter43.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:24: ( COMMA parameter )*
			loop15:
			while (true) {
				int alt15=2;
				int LA15_0 = input.LA(1);
				if ( (LA15_0==COMMA) ) {
					alt15=1;
				}

				switch (alt15) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:25: COMMA parameter
					{
					COMMA44=(Token)match(input,COMMA,FOLLOW_COMMA_in_parameters872); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA44);

					pushFollow(FOLLOW_parameter_in_parameters874);
					parameter45=parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parameter.add(parameter45.getTree());
					}
					break;

				default :
					break loop15;
				}
			}

			// AST REWRITE
			// elements: parameter
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 107:43: -> ( parameter )+
			{
				if ( !(stream_parameter.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_parameter.hasNext() ) {
					adaptor.addChild(root_0, stream_parameter.nextTree());
				}
				stream_parameter.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameters"


	public static class parameter_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parameter"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:1: parameter : parameterName ({...}? => filter )? -> ^( INPUT[\"\"] parameterName ( filter )? ) ;
	public final MatlabParser.parameter_return parameter() throws RecognitionException {
		MatlabParser.parameter_return retval = new MatlabParser.parameter_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope parameterName46 =null;
		ParserRuleReturnScope filter47 =null;

		RewriteRuleSubtreeStream stream_filter=new RewriteRuleSubtreeStream(adaptor,"rule filter");
		RewriteRuleSubtreeStream stream_parameterName=new RewriteRuleSubtreeStream(adaptor,"rule parameterName");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:11: ( parameterName ({...}? => filter )? -> ^( INPUT[\"\"] parameterName ( filter )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:13: parameterName ({...}? => filter )?
			{
			pushFollow(FOLLOW_parameterName_in_parameter892);
			parameterName46=parameterName();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parameterName.add(parameterName46.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:27: ({...}? => filter )?
			int alt16=2;
			int LA16_0 = input.LA(1);
			if ( (LA16_0==AT) && ((Method_SignatureIsActive()))) {
				alt16=1;
			}
			switch (alt16) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:28: {...}? => filter
					{
					if ( !((Method_SignatureIsActive())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "parameter", "Method_SignatureIsActive()");
					}
					pushFollow(FOLLOW_filter_in_parameter898);
					filter47=filter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_filter.add(filter47.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: filter, parameterName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 109:69: -> ^( INPUT[\"\"] parameterName ( filter )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:72: ^( INPUT[\"\"] parameterName ( filter )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(INPUT, ""), root_1);
				adaptor.addChild(root_1, stream_parameterName.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:98: ( filter )?
				if ( stream_filter.hasNext() ) {
					adaptor.addChild(root_1, stream_filter.nextTree());
				}
				stream_filter.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameter"


	public static class parameterName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parameterName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:111:1: parameterName : xPARAMETERID -> ^( NAME[\"\"] xPARAMETERID ) ;
	public final MatlabParser.parameterName_return parameterName() throws RecognitionException {
		MatlabParser.parameterName_return retval = new MatlabParser.parameterName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xPARAMETERID48 =null;

		RewriteRuleSubtreeStream stream_xPARAMETERID=new RewriteRuleSubtreeStream(adaptor,"rule xPARAMETERID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:111:15: ( xPARAMETERID -> ^( NAME[\"\"] xPARAMETERID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:111:17: xPARAMETERID
			{
			pushFollow(FOLLOW_xPARAMETERID_in_parameterName923);
			xPARAMETERID48=xPARAMETERID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xPARAMETERID.add(xPARAMETERID48.getTree());
			// AST REWRITE
			// elements: xPARAMETERID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 111:30: -> ^( NAME[\"\"] xPARAMETERID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:111:33: ^( NAME[\"\"] xPARAMETERID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xPARAMETERID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameterName"


	public static class openBody_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openBody"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:1: openBody : ( xEOS openItems )? -> ( openItems )? ;
	public final MatlabParser.openBody_return openBody() throws RecognitionException {
		MatlabParser.openBody_return retval = new MatlabParser.openBody_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xEOS49 =null;
		ParserRuleReturnScope openItems50 =null;

		RewriteRuleSubtreeStream stream_openItems=new RewriteRuleSubtreeStream(adaptor,"rule openItems");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:10: ( ( xEOS openItems )? -> ( openItems )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:12: ( xEOS openItems )?
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:12: ( xEOS openItems )?
			int alt17=2;
			int LA17_0 = input.LA(1);
			if ( (LA17_0==COMMA||LA17_0==EOL||LA17_0==SEMICOLON) ) {
				alt17=1;
			}
			switch (alt17) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:13: xEOS openItems
					{
					pushFollow(FOLLOW_xEOS_in_openBody942);
					xEOS49=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS49.getTree());
					pushFollow(FOLLOW_openItems_in_openBody944);
					openItems50=openItems();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_openItems.add(openItems50.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: openItems
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 113:30: -> ( openItems )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:33: ( openItems )?
				if ( stream_openItems.hasNext() ) {
					adaptor.addChild(root_0, stream_openItems.nextTree());
				}
				stream_openItems.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openBody"


	public static class openItems_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openItems"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:1: openItems : ( openItem | xEOS )* -> ( openItem )* ;
	public final MatlabParser.openItems_return openItems() throws RecognitionException {
		MatlabParser.openItems_return retval = new MatlabParser.openItems_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope openItem51 =null;
		ParserRuleReturnScope xEOS52 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_openItem=new RewriteRuleSubtreeStream(adaptor,"rule openItem");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:11: ( ( openItem | xEOS )* -> ( openItem )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:13: ( openItem | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:13: ( openItem | xEOS )*
			loop18:
			while (true) {
				int alt18=3;
				int LA18_0 = input.LA(1);
				if ( (LA18_0==ID) && (((Command_IsEnabled())||(True())))) {
					alt18=1;
				}
				else if ( (LA18_0==IMAGINARY||LA18_0==LCURLY||(LA18_0 >= LPAREN && LA18_0 <= LSQUARE)||LA18_0==MINUS||LA18_0==NOT||LA18_0==PLUS||LA18_0==REAL||LA18_0==STRING) && ((True()))) {
					alt18=1;
				}
				else if ( (LA18_0==END) && (((Index_IsActive())&&(True())))) {
					alt18=1;
				}
				else if ( (LA18_0==AT||LA18_0==QUESTION) && ((True()))) {
					alt18=1;
				}
				else if ( (LA18_0==BREAK||LA18_0==COMMAND||LA18_0==CONTINUE||LA18_0==EXCLAMATION||LA18_0==FOR||LA18_0==GLOBAL||LA18_0==IF||(LA18_0 >= PARFOR && LA18_0 <= PERSISTENT)||LA18_0==RETURN||LA18_0==SPMD||LA18_0==SWITCH||LA18_0==TRY||LA18_0==WHILE) ) {
					alt18=1;
				}
				else if ( (LA18_0==COMMA||LA18_0==EOL||LA18_0==SEMICOLON) ) {
					alt18=2;
				}

				switch (alt18) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:14: openItem
					{
					pushFollow(FOLLOW_openItem_in_openItems963);
					openItem51=openItem();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_openItem.add(openItem51.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:25: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_openItems967);
					xEOS52=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS52.getTree());
					}
					break;

				default :
					break loop18;
				}
			}

			// AST REWRITE
			// elements: openItem
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 115:32: -> ( openItem )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:35: ( openItem )*
				while ( stream_openItem.hasNext() ) {
					adaptor.addChild(root_0, stream_openItem.nextTree());
				}
				stream_openItem.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openItems"


	public static class openItem_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openItem"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:117:1: openItem : statement -> statement ;
	public final MatlabParser.openItem_return openItem() throws RecognitionException {
		MatlabParser.openItem_return retval = new MatlabParser.openItem_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope statement53 =null;

		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:117:10: ( statement -> statement )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:117:12: statement
			{
			pushFollow(FOLLOW_statement_in_openItem985);
			statement53=statement();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statement.add(statement53.getTree());
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 117:22: -> statement
			{
				adaptor.addChild(root_0, stream_statement.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openItem"


	public static class closeFunctionFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeFunctionFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:1: closeFunctionFile : ( EOL )* closeFunctions ( EOL )* EOF -> ^( FUNCTIONFILE[\"\"] closeFunctions ) ;
	public final MatlabParser.closeFunctionFile_return closeFunctionFile() throws RecognitionException {
		MatlabParser.closeFunctionFile_return retval = new MatlabParser.closeFunctionFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL54=null;
		Token EOL56=null;
		Token EOF57=null;
		ParserRuleReturnScope closeFunctions55 =null;

		Object EOL54_tree=null;
		Object EOL56_tree=null;
		Object EOF57_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_closeFunctions=new RewriteRuleSubtreeStream(adaptor,"rule closeFunctions");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:19: ( ( EOL )* closeFunctions ( EOL )* EOF -> ^( FUNCTIONFILE[\"\"] closeFunctions ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:21: ( EOL )* closeFunctions ( EOL )* EOF
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:21: ( EOL )*
			loop19:
			while (true) {
				int alt19=2;
				int LA19_0 = input.LA(1);
				if ( (LA19_0==EOL) ) {
					alt19=1;
				}

				switch (alt19) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:22: EOL
					{
					EOL54=(Token)match(input,EOL,FOLLOW_EOL_in_closeFunctionFile1001); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL54);

					}
					break;

				default :
					break loop19;
				}
			}

			pushFollow(FOLLOW_closeFunctions_in_closeFunctionFile1005);
			closeFunctions55=closeFunctions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeFunctions.add(closeFunctions55.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:43: ( EOL )*
			loop20:
			while (true) {
				int alt20=2;
				int LA20_0 = input.LA(1);
				if ( (LA20_0==EOL) ) {
					alt20=1;
				}

				switch (alt20) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:44: EOL
					{
					EOL56=(Token)match(input,EOL,FOLLOW_EOL_in_closeFunctionFile1008); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL56);

					}
					break;

				default :
					break loop20;
				}
			}

			EOF57=(Token)match(input,EOF,FOLLOW_EOF_in_closeFunctionFile1012); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF57);

			// AST REWRITE
			// elements: closeFunctions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 121:54: -> ^( FUNCTIONFILE[\"\"] closeFunctions )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:57: ^( FUNCTIONFILE[\"\"] closeFunctions )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNCTIONFILE, ""), root_1);
				adaptor.addChild(root_1, stream_closeFunctions.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeFunctionFile"


	public static class closeFunctions_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeFunctions"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:1: closeFunctions : closeFunction ( ( EOL )* closeFunction )* -> ( closeFunction )+ ;
	public final MatlabParser.closeFunctions_return closeFunctions() throws RecognitionException {
		MatlabParser.closeFunctions_return retval = new MatlabParser.closeFunctions_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL59=null;
		ParserRuleReturnScope closeFunction58 =null;
		ParserRuleReturnScope closeFunction60 =null;

		Object EOL59_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleSubtreeStream stream_closeFunction=new RewriteRuleSubtreeStream(adaptor,"rule closeFunction");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:16: ( closeFunction ( ( EOL )* closeFunction )* -> ( closeFunction )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:18: closeFunction ( ( EOL )* closeFunction )*
			{
			pushFollow(FOLLOW_closeFunction_in_closeFunctions1030);
			closeFunction58=closeFunction();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeFunction.add(closeFunction58.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:32: ( ( EOL )* closeFunction )*
			loop22:
			while (true) {
				int alt22=2;
				alt22 = dfa22.predict(input);
				switch (alt22) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:33: ( EOL )* closeFunction
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:33: ( EOL )*
					loop21:
					while (true) {
						int alt21=2;
						int LA21_0 = input.LA(1);
						if ( (LA21_0==EOL) ) {
							alt21=1;
						}

						switch (alt21) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:34: EOL
							{
							EOL59=(Token)match(input,EOL,FOLLOW_EOL_in_closeFunctions1034); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EOL.add(EOL59);

							}
							break;

						default :
							break loop21;
						}
					}

					pushFollow(FOLLOW_closeFunction_in_closeFunctions1038);
					closeFunction60=closeFunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeFunction.add(closeFunction60.getTree());
					}
					break;

				default :
					break loop22;
				}
			}

			// AST REWRITE
			// elements: closeFunction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 123:56: -> ( closeFunction )+
			{
				if ( !(stream_closeFunction.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_closeFunction.hasNext() ) {
					adaptor.addChild(root_0, stream_closeFunction.nextTree());
				}
				stream_closeFunction.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeFunctions"


	public static class closeFunction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeFunction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:1: closeFunction : FUNCTION functionSignature closeBody END -> ^( FUNCTION functionSignature ( closeBody )? ) ;
	public final MatlabParser.closeFunction_return closeFunction() throws RecognitionException {
		MatlabParser.closeFunction_return retval = new MatlabParser.closeFunction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION61=null;
		Token END64=null;
		ParserRuleReturnScope functionSignature62 =null;
		ParserRuleReturnScope closeBody63 =null;

		Object FUNCTION61_tree=null;
		Object END64_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_functionSignature=new RewriteRuleSubtreeStream(adaptor,"rule functionSignature");
		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:15: ( FUNCTION functionSignature closeBody END -> ^( FUNCTION functionSignature ( closeBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:17: FUNCTION functionSignature closeBody END
			{
			FUNCTION61=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_closeFunction1056); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION61);

			pushFollow(FOLLOW_functionSignature_in_closeFunction1058);
			functionSignature62=functionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_functionSignature.add(functionSignature62.getTree());
			pushFollow(FOLLOW_closeBody_in_closeFunction1060);
			closeBody63=closeBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeBody.add(closeBody63.getTree());
			END64=(Token)match(input,END,FOLLOW_END_in_closeFunction1062); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END64);

			// AST REWRITE
			// elements: FUNCTION, functionSignature, closeBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 125:58: -> ^( FUNCTION functionSignature ( closeBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:61: ^( FUNCTION functionSignature ( closeBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_FUNCTION.nextNode(), root_1);
				adaptor.addChild(root_1, stream_functionSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:90: ( closeBody )?
				if ( stream_closeBody.hasNext() ) {
					adaptor.addChild(root_1, stream_closeBody.nextTree());
				}
				stream_closeBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeFunction"


	public static class closeBody_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeBody"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:1: closeBody : ( xEOS closeItems )? -> ( closeItems )? ;
	public final MatlabParser.closeBody_return closeBody() throws RecognitionException {
		MatlabParser.closeBody_return retval = new MatlabParser.closeBody_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xEOS65 =null;
		ParserRuleReturnScope closeItems66 =null;

		RewriteRuleSubtreeStream stream_closeItems=new RewriteRuleSubtreeStream(adaptor,"rule closeItems");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:11: ( ( xEOS closeItems )? -> ( closeItems )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:13: ( xEOS closeItems )?
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:13: ( xEOS closeItems )?
			int alt23=2;
			int LA23_0 = input.LA(1);
			if ( (LA23_0==COMMA||LA23_0==EOL||LA23_0==SEMICOLON) ) {
				alt23=1;
			}
			switch (alt23) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:14: xEOS closeItems
					{
					pushFollow(FOLLOW_xEOS_in_closeBody1085);
					xEOS65=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS65.getTree());
					pushFollow(FOLLOW_closeItems_in_closeBody1087);
					closeItems66=closeItems();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeItems.add(closeItems66.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: closeItems
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 127:32: -> ( closeItems )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:35: ( closeItems )?
				if ( stream_closeItems.hasNext() ) {
					adaptor.addChild(root_0, stream_closeItems.nextTree());
				}
				stream_closeItems.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeBody"


	public static class closeItems_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeItems"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:1: closeItems : ( closeItem | xEOS )* -> ( closeItem )* ;
	public final MatlabParser.closeItems_return closeItems() throws RecognitionException {
		MatlabParser.closeItems_return retval = new MatlabParser.closeItems_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope closeItem67 =null;
		ParserRuleReturnScope xEOS68 =null;

		RewriteRuleSubtreeStream stream_closeItem=new RewriteRuleSubtreeStream(adaptor,"rule closeItem");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:12: ( ( closeItem | xEOS )* -> ( closeItem )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:14: ( closeItem | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:14: ( closeItem | xEOS )*
			loop24:
			while (true) {
				int alt24=3;
				int LA24_0 = input.LA(1);
				if ( (LA24_0==END) ) {
					int LA24_1 = input.LA(2);
					if ( (((Index_IsActive())&&(True()))) ) {
						alt24=1;
					}

				}
				else if ( (LA24_0==FUNCTION) ) {
					alt24=1;
				}
				else if ( (LA24_0==ID) && (((Command_IsEnabled())||(True())))) {
					alt24=1;
				}
				else if ( (LA24_0==AT||LA24_0==IMAGINARY||LA24_0==LCURLY||(LA24_0 >= LPAREN && LA24_0 <= LSQUARE)||LA24_0==MINUS||LA24_0==NOT||LA24_0==PLUS||LA24_0==QUESTION||LA24_0==REAL||LA24_0==STRING) && ((True()))) {
					alt24=1;
				}
				else if ( (LA24_0==BREAK||LA24_0==COMMAND||LA24_0==CONTINUE||LA24_0==EXCLAMATION||LA24_0==FOR||LA24_0==GLOBAL||LA24_0==IF||(LA24_0 >= PARFOR && LA24_0 <= PERSISTENT)||LA24_0==RETURN||LA24_0==SPMD||LA24_0==SWITCH||LA24_0==TRY||LA24_0==WHILE) ) {
					alt24=1;
				}
				else if ( (LA24_0==COMMA||LA24_0==EOL||LA24_0==SEMICOLON) ) {
					alt24=2;
				}

				switch (alt24) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:15: closeItem
					{
					pushFollow(FOLLOW_closeItem_in_closeItems1106);
					closeItem67=closeItem();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeItem.add(closeItem67.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:27: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_closeItems1110);
					xEOS68=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS68.getTree());
					}
					break;

				default :
					break loop24;
				}
			}

			// AST REWRITE
			// elements: closeItem
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 129:34: -> ( closeItem )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:37: ( closeItem )*
				while ( stream_closeItem.hasNext() ) {
					adaptor.addChild(root_0, stream_closeItem.nextTree());
				}
				stream_closeItem.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeItems"


	public static class closeItem_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeItem"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:131:1: closeItem : ( nestedFunction -> nestedFunction | statement -> statement );
	public final MatlabParser.closeItem_return closeItem() throws RecognitionException {
		MatlabParser.closeItem_return retval = new MatlabParser.closeItem_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope nestedFunction69 =null;
		ParserRuleReturnScope statement70 =null;

		RewriteRuleSubtreeStream stream_nestedFunction=new RewriteRuleSubtreeStream(adaptor,"rule nestedFunction");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:131:11: ( nestedFunction -> nestedFunction | statement -> statement )
			int alt25=2;
			int LA25_0 = input.LA(1);
			if ( (LA25_0==FUNCTION) ) {
				alt25=1;
			}
			else if ( (LA25_0==ID) && (((Command_IsEnabled())||(True())))) {
				alt25=2;
			}
			else if ( (LA25_0==IMAGINARY||LA25_0==LCURLY||(LA25_0 >= LPAREN && LA25_0 <= LSQUARE)||LA25_0==MINUS||LA25_0==NOT||LA25_0==PLUS||LA25_0==REAL||LA25_0==STRING) && ((True()))) {
				alt25=2;
			}
			else if ( (LA25_0==END) && (((Index_IsActive())&&(True())))) {
				alt25=2;
			}
			else if ( (LA25_0==AT||LA25_0==QUESTION) && ((True()))) {
				alt25=2;
			}
			else if ( (LA25_0==BREAK||LA25_0==COMMAND||LA25_0==CONTINUE||LA25_0==EXCLAMATION||LA25_0==FOR||LA25_0==GLOBAL||LA25_0==IF||(LA25_0 >= PARFOR && LA25_0 <= PERSISTENT)||LA25_0==RETURN||LA25_0==SPMD||LA25_0==SWITCH||LA25_0==TRY||LA25_0==WHILE) ) {
				alt25=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 25, 0, input);
				throw nvae;
			}

			switch (alt25) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:131:13: nestedFunction
					{
					pushFollow(FOLLOW_nestedFunction_in_closeItem1128);
					nestedFunction69=nestedFunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_nestedFunction.add(nestedFunction69.getTree());
					// AST REWRITE
					// elements: nestedFunction
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 131:28: -> nestedFunction
					{
						adaptor.addChild(root_0, stream_nestedFunction.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:132:13: statement
					{
					pushFollow(FOLLOW_statement_in_closeItem1146);
					statement70=statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_statement.add(statement70.getTree());
					// AST REWRITE
					// elements: statement
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 132:23: -> statement
					{
						adaptor.addChild(root_0, stream_statement.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeItem"


	public static class nestedFunction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nestedFunction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:1: nestedFunction : FUNCTION functionSignature closeBody END -> ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? ) ;
	public final MatlabParser.nestedFunction_return nestedFunction() throws RecognitionException {
		MatlabParser.nestedFunction_return retval = new MatlabParser.nestedFunction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION71=null;
		Token END74=null;
		ParserRuleReturnScope functionSignature72 =null;
		ParserRuleReturnScope closeBody73 =null;

		Object FUNCTION71_tree=null;
		Object END74_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_functionSignature=new RewriteRuleSubtreeStream(adaptor,"rule functionSignature");
		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:16: ( FUNCTION functionSignature closeBody END -> ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:18: FUNCTION functionSignature closeBody END
			{
			FUNCTION71=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_nestedFunction1163); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION71);

			pushFollow(FOLLOW_functionSignature_in_nestedFunction1165);
			functionSignature72=functionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_functionSignature.add(functionSignature72.getTree());
			pushFollow(FOLLOW_closeBody_in_nestedFunction1167);
			closeBody73=closeBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeBody.add(closeBody73.getTree());
			END74=(Token)match(input,END,FOLLOW_END_in_nestedFunction1169); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END74);

			// AST REWRITE
			// elements: closeBody, functionSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 135:59: -> ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:62: ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NESTEDFUNCTION, FUNCTION71), root_1);
				adaptor.addChild(root_1, stream_functionSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:108: ( closeBody )?
				if ( stream_closeBody.hasNext() ) {
					adaptor.addChild(root_1, stream_closeBody.nextTree());
				}
				stream_closeBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nestedFunction"


	public static class classFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "classFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:1: classFile : ( EOL )* classDef ( EOL )* ( closeFunctions ( EOL )* )? EOF -> ^( CLASSFILE[\"\"] classDef ( closeFunctions )? ) ;
	public final MatlabParser.classFile_return classFile() throws RecognitionException {
		MatlabParser.classFile_return retval = new MatlabParser.classFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL75=null;
		Token EOL77=null;
		Token EOL79=null;
		Token EOF80=null;
		ParserRuleReturnScope classDef76 =null;
		ParserRuleReturnScope closeFunctions78 =null;

		Object EOL75_tree=null;
		Object EOL77_tree=null;
		Object EOL79_tree=null;
		Object EOF80_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_classDef=new RewriteRuleSubtreeStream(adaptor,"rule classDef");
		RewriteRuleSubtreeStream stream_closeFunctions=new RewriteRuleSubtreeStream(adaptor,"rule closeFunctions");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:11: ( ( EOL )* classDef ( EOL )* ( closeFunctions ( EOL )* )? EOF -> ^( CLASSFILE[\"\"] classDef ( closeFunctions )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:13: ( EOL )* classDef ( EOL )* ( closeFunctions ( EOL )* )? EOF
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:13: ( EOL )*
			loop26:
			while (true) {
				int alt26=2;
				int LA26_0 = input.LA(1);
				if ( (LA26_0==EOL) ) {
					alt26=1;
				}

				switch (alt26) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:14: EOL
					{
					EOL75=(Token)match(input,EOL,FOLLOW_EOL_in_classFile1195); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL75);

					}
					break;

				default :
					break loop26;
				}
			}

			pushFollow(FOLLOW_classDef_in_classFile1199);
			classDef76=classDef();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classDef.add(classDef76.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:29: ( EOL )*
			loop27:
			while (true) {
				int alt27=2;
				int LA27_0 = input.LA(1);
				if ( (LA27_0==EOL) ) {
					alt27=1;
				}

				switch (alt27) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:30: EOL
					{
					EOL77=(Token)match(input,EOL,FOLLOW_EOL_in_classFile1202); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL77);

					}
					break;

				default :
					break loop27;
				}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:36: ( closeFunctions ( EOL )* )?
			int alt29=2;
			int LA29_0 = input.LA(1);
			if ( (LA29_0==FUNCTION) ) {
				alt29=1;
			}
			switch (alt29) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:37: closeFunctions ( EOL )*
					{
					pushFollow(FOLLOW_closeFunctions_in_classFile1207);
					closeFunctions78=closeFunctions();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeFunctions.add(closeFunctions78.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:52: ( EOL )*
					loop28:
					while (true) {
						int alt28=2;
						int LA28_0 = input.LA(1);
						if ( (LA28_0==EOL) ) {
							alt28=1;
						}

						switch (alt28) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:53: EOL
							{
							EOL79=(Token)match(input,EOL,FOLLOW_EOL_in_classFile1210); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EOL.add(EOL79);

							}
							break;

						default :
							break loop28;
						}
					}

					}
					break;

			}

			EOF80=(Token)match(input,EOF,FOLLOW_EOF_in_classFile1216); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF80);

			// AST REWRITE
			// elements: closeFunctions, classDef
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 139:65: -> ^( CLASSFILE[\"\"] classDef ( closeFunctions )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:68: ^( CLASSFILE[\"\"] classDef ( closeFunctions )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CLASSFILE, ""), root_1);
				adaptor.addChild(root_1, stream_classDef.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:93: ( closeFunctions )?
				if ( stream_closeFunctions.hasNext() ) {
					adaptor.addChild(root_1, stream_closeFunctions.nextTree());
				}
				stream_closeFunctions.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "classFile"


	public static class classDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "classDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:1: classDef : CLASSDEF ( annotationPortion )? name ( genealogyPortion )? xEOS sections END -> ^( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? ( sections )? ) ;
	public final MatlabParser.classDef_return classDef() throws RecognitionException {
		MatlabParser.classDef_return retval = new MatlabParser.classDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CLASSDEF81=null;
		Token END87=null;
		ParserRuleReturnScope annotationPortion82 =null;
		ParserRuleReturnScope name83 =null;
		ParserRuleReturnScope genealogyPortion84 =null;
		ParserRuleReturnScope xEOS85 =null;
		ParserRuleReturnScope sections86 =null;

		Object CLASSDEF81_tree=null;
		Object END87_tree=null;
		RewriteRuleTokenStream stream_CLASSDEF=new RewriteRuleTokenStream(adaptor,"token CLASSDEF");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_genealogyPortion=new RewriteRuleSubtreeStream(adaptor,"rule genealogyPortion");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_sections=new RewriteRuleSubtreeStream(adaptor,"rule sections");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:10: ( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? xEOS sections END -> ^( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? ( sections )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:12: CLASSDEF ( annotationPortion )? name ( genealogyPortion )? xEOS sections END
			{
			CLASSDEF81=(Token)match(input,CLASSDEF,FOLLOW_CLASSDEF_in_classDef1239); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CLASSDEF.add(CLASSDEF81);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:21: ( annotationPortion )?
			int alt30=2;
			int LA30_0 = input.LA(1);
			if ( (LA30_0==LPAREN) ) {
				alt30=1;
			}
			switch (alt30) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:22: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_classDef1242);
					annotationPortion82=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion82.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_name_in_classDef1246);
			name83=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name83.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:47: ( genealogyPortion )?
			int alt31=2;
			int LA31_0 = input.LA(1);
			if ( (LA31_0==LT) ) {
				alt31=1;
			}
			switch (alt31) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:48: genealogyPortion
					{
					pushFollow(FOLLOW_genealogyPortion_in_classDef1249);
					genealogyPortion84=genealogyPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_genealogyPortion.add(genealogyPortion84.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_xEOS_in_classDef1253);
			xEOS85=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS85.getTree());
			pushFollow(FOLLOW_sections_in_classDef1255);
			sections86=sections();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_sections.add(sections86.getTree());
			END87=(Token)match(input,END,FOLLOW_END_in_classDef1257); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END87);

			// AST REWRITE
			// elements: sections, genealogyPortion, name, CLASSDEF, annotationPortion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 141:85: -> ^( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? ( sections )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:88: ^( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? ( sections )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_CLASSDEF.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:99: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:125: ( genealogyPortion )?
				if ( stream_genealogyPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_genealogyPortion.nextTree());
				}
				stream_genealogyPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:145: ( sections )?
				if ( stream_sections.hasNext() ) {
					adaptor.addChild(root_1, stream_sections.nextTree());
				}
				stream_sections.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "classDef"


	public static class annotationPortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "annotationPortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:143:1: annotationPortion : LPAREN attributes RPAREN -> attributes ;
	public final MatlabParser.annotationPortion_return annotationPortion() throws RecognitionException {
		MatlabParser.annotationPortion_return retval = new MatlabParser.annotationPortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN88=null;
		Token RPAREN90=null;
		ParserRuleReturnScope attributes89 =null;

		Object LPAREN88_tree=null;
		Object RPAREN90_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_attributes=new RewriteRuleSubtreeStream(adaptor,"rule attributes");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:143:19: ( LPAREN attributes RPAREN -> attributes )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:143:21: LPAREN attributes RPAREN
			{
			LPAREN88=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_annotationPortion1289); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN88);

			pushFollow(FOLLOW_attributes_in_annotationPortion1291);
			attributes89=attributes();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_attributes.add(attributes89.getTree());
			RPAREN90=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_annotationPortion1293); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN90);

			// AST REWRITE
			// elements: attributes
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 143:46: -> attributes
			{
				adaptor.addChild(root_0, stream_attributes.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "annotationPortion"


	public static class attributes_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "attributes"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:1: attributes : attribute ( COMMA attribute )* -> ( attribute )+ ;
	public final MatlabParser.attributes_return attributes() throws RecognitionException {
		MatlabParser.attributes_return retval = new MatlabParser.attributes_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA92=null;
		ParserRuleReturnScope attribute91 =null;
		ParserRuleReturnScope attribute93 =null;

		Object COMMA92_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_attribute=new RewriteRuleSubtreeStream(adaptor,"rule attribute");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:12: ( attribute ( COMMA attribute )* -> ( attribute )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:14: attribute ( COMMA attribute )*
			{
			pushFollow(FOLLOW_attribute_in_attributes1306);
			attribute91=attribute();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_attribute.add(attribute91.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:24: ( COMMA attribute )*
			loop32:
			while (true) {
				int alt32=2;
				int LA32_0 = input.LA(1);
				if ( (LA32_0==COMMA) ) {
					alt32=1;
				}

				switch (alt32) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:25: COMMA attribute
					{
					COMMA92=(Token)match(input,COMMA,FOLLOW_COMMA_in_attributes1309); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA92);

					pushFollow(FOLLOW_attribute_in_attributes1311);
					attribute93=attribute();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_attribute.add(attribute93.getTree());
					}
					break;

				default :
					break loop32;
				}
			}

			// AST REWRITE
			// elements: attribute
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 145:43: -> ( attribute )+
			{
				if ( !(stream_attribute.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_attribute.hasNext() ) {
					adaptor.addChild(root_0, stream_attribute.nextTree());
				}
				stream_attribute.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "attributes"


	public static class attribute_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "attribute"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:1: attribute : ( NOT name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) ) | name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) ) | name ASSIGN expression -> ^( ATTRIBUTE[\"\"] name expression ) );
	public final MatlabParser.attribute_return attribute() throws RecognitionException {
		MatlabParser.attribute_return retval = new MatlabParser.attribute_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token NOT94=null;
		Token ASSIGN98=null;
		ParserRuleReturnScope name95 =null;
		ParserRuleReturnScope name96 =null;
		ParserRuleReturnScope name97 =null;
		ParserRuleReturnScope expression99 =null;

		Object NOT94_tree=null;
		Object ASSIGN98_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:11: ( NOT name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) ) | name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) ) | name ASSIGN expression -> ^( ATTRIBUTE[\"\"] name expression ) )
			int alt33=3;
			int LA33_0 = input.LA(1);
			if ( (LA33_0==NOT) ) {
				alt33=1;
			}
			else if ( (LA33_0==ID) ) {
				int LA33_2 = input.LA(2);
				if ( (LA33_2==COMMA||LA33_2==RPAREN) ) {
					alt33=2;
				}
				else if ( (LA33_2==ASSIGN) ) {
					alt33=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 33, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 33, 0, input);
				throw nvae;
			}

			switch (alt33) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:13: NOT name
					{
					NOT94=(Token)match(input,NOT,FOLLOW_NOT_in_attribute1329); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT94);

					pushFollow(FOLLOW_name_in_attribute1331);
					name95=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(name95.getTree());
					// AST REWRITE
					// elements: name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 147:22: -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:25: ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ATTRIBUTE, ""), root_1);
						adaptor.addChild(root_1, stream_name.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:46: ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_2);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:56: ^( NAME[\"\"] ^( ID[\"false\"] ) )
						{
						Object root_3 = (Object)adaptor.nil();
						root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_3);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:67: ^( ID[\"false\"] )
						{
						Object root_4 = (Object)adaptor.nil();
						root_4 = (Object)adaptor.becomeRoot((Object)adaptor.create(ID, "false"), root_4);
						adaptor.addChild(root_3, root_4);
						}

						adaptor.addChild(root_2, root_3);
						}

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:7: name
					{
					pushFollow(FOLLOW_name_in_attribute1363);
					name96=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(name96.getTree());
					// AST REWRITE
					// elements: name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 148:12: -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:15: ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ATTRIBUTE, ""), root_1);
						adaptor.addChild(root_1, stream_name.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:36: ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_2);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:46: ^( NAME[\"\"] ^( ID[\"true\"] ) )
						{
						Object root_3 = (Object)adaptor.nil();
						root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_3);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:57: ^( ID[\"true\"] )
						{
						Object root_4 = (Object)adaptor.nil();
						root_4 = (Object)adaptor.becomeRoot((Object)adaptor.create(ID, "true"), root_4);
						adaptor.addChild(root_3, root_4);
						}

						adaptor.addChild(root_2, root_3);
						}

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:149:13: name ASSIGN expression
					{
					pushFollow(FOLLOW_name_in_attribute1401);
					name97=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(name97.getTree());
					ASSIGN98=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_attribute1403); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN98);

					pushFollow(FOLLOW_expression_in_attribute1405);
					expression99=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression99.getTree());
					// AST REWRITE
					// elements: name, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 149:36: -> ^( ATTRIBUTE[\"\"] name expression )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:149:39: ^( ATTRIBUTE[\"\"] name expression )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ATTRIBUTE, ""), root_1);
						adaptor.addChild(root_1, stream_name.nextTree());
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "attribute"


	public static class genealogyPortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "genealogyPortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:152:1: genealogyPortion : LT baseClasses -> baseClasses ;
	public final MatlabParser.genealogyPortion_return genealogyPortion() throws RecognitionException {
		MatlabParser.genealogyPortion_return retval = new MatlabParser.genealogyPortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LT100=null;
		ParserRuleReturnScope baseClasses101 =null;

		Object LT100_tree=null;
		RewriteRuleTokenStream stream_LT=new RewriteRuleTokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_baseClasses=new RewriteRuleSubtreeStream(adaptor,"rule baseClasses");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:152:18: ( LT baseClasses -> baseClasses )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:152:20: LT baseClasses
			{
			LT100=(Token)match(input,LT,FOLLOW_LT_in_genealogyPortion1429); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LT.add(LT100);

			pushFollow(FOLLOW_baseClasses_in_genealogyPortion1431);
			baseClasses101=baseClasses();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_baseClasses.add(baseClasses101.getTree());
			// AST REWRITE
			// elements: baseClasses
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 152:35: -> baseClasses
			{
				adaptor.addChild(root_0, stream_baseClasses.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "genealogyPortion"


	public static class baseClasses_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "baseClasses"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:1: baseClasses : classReference ( AND classReference )* -> ( classReference )+ ;
	public final MatlabParser.baseClasses_return baseClasses() throws RecognitionException {
		MatlabParser.baseClasses_return retval = new MatlabParser.baseClasses_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AND103=null;
		ParserRuleReturnScope classReference102 =null;
		ParserRuleReturnScope classReference104 =null;

		Object AND103_tree=null;
		RewriteRuleTokenStream stream_AND=new RewriteRuleTokenStream(adaptor,"token AND");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:13: ( classReference ( AND classReference )* -> ( classReference )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:15: classReference ( AND classReference )*
			{
			pushFollow(FOLLOW_classReference_in_baseClasses1444);
			classReference102=classReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classReference.add(classReference102.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:30: ( AND classReference )*
			loop34:
			while (true) {
				int alt34=2;
				int LA34_0 = input.LA(1);
				if ( (LA34_0==AND) ) {
					alt34=1;
				}

				switch (alt34) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:31: AND classReference
					{
					AND103=(Token)match(input,AND,FOLLOW_AND_in_baseClasses1447); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AND.add(AND103);

					pushFollow(FOLLOW_classReference_in_baseClasses1449);
					classReference104=classReference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_classReference.add(classReference104.getTree());
					}
					break;

				default :
					break loop34;
				}
			}

			// AST REWRITE
			// elements: classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 154:52: -> ( classReference )+
			{
				if ( !(stream_classReference.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_classReference.hasNext() ) {
					adaptor.addChild(root_0, stream_classReference.nextTree());
				}
				stream_classReference.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "baseClasses"


	public static class classReference_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "classReference"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:156:1: classReference : fullClassName -> ^( CLASSREF[\"\"] fullClassName ) ;
	public final MatlabParser.classReference_return classReference() throws RecognitionException {
		MatlabParser.classReference_return retval = new MatlabParser.classReference_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope fullClassName105 =null;

		RewriteRuleSubtreeStream stream_fullClassName=new RewriteRuleSubtreeStream(adaptor,"rule fullClassName");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:156:16: ( fullClassName -> ^( CLASSREF[\"\"] fullClassName ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:156:18: fullClassName
			{
			pushFollow(FOLLOW_fullClassName_in_classReference1467);
			fullClassName105=fullClassName();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_fullClassName.add(fullClassName105.getTree());
			// AST REWRITE
			// elements: fullClassName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 156:32: -> ^( CLASSREF[\"\"] fullClassName )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:156:35: ^( CLASSREF[\"\"] fullClassName )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CLASSREF, ""), root_1);
				adaptor.addChild(root_1, stream_fullClassName.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "classReference"


	public static class fullClassName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "fullClassName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:1: fullClassName : xID ({...}? => DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) ;
	public final MatlabParser.fullClassName_return fullClassName() throws RecognitionException {
		MatlabParser.fullClassName_return retval = new MatlabParser.fullClassName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT107=null;
		ParserRuleReturnScope xID106 =null;
		ParserRuleReturnScope xANYID108 =null;

		Object DOT107_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_xANYID=new RewriteRuleSubtreeStream(adaptor,"rule xANYID");
		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:15: ( xID ({...}? => DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:17: xID ({...}? => DOT xANYID )*
			{
			pushFollow(FOLLOW_xID_in_fullClassName1485);
			xID106=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID106.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:21: ({...}? => DOT xANYID )*
			loop35:
			while (true) {
				int alt35=2;
				int LA35_0 = input.LA(1);
				if ( (LA35_0==DOT) && (((Chain_MayAddDotName())||(Chain_MayAddDotExpression())||(true)))) {
					int LA35_11 = input.LA(2);
					if ( (LA35_11==ID) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_13 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==BREAK) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_14 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==CASE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_15 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==CATCH) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_16 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==CLASSDEF) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_17 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==CONTINUE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_18 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==ELSE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_19 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==ELSEIF) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_20 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==END) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_21 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==FOR) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_22 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==FUNCTION) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_23 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==GLOBAL) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_24 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==IF) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_25 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==OTHERWISE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_26 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==PARFOR) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_27 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==PERSISTENT) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_28 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==RETURN) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_29 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==SPMD) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_30 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==SWITCH) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_31 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==TRY) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_32 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==WHILE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_33 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}

				}

				switch (alt35) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:22: {...}? => DOT xANYID
					{
					if ( !((true)) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "fullClassName", "true");
					}
					DOT107=(Token)match(input,DOT,FOLLOW_DOT_in_fullClassName1491); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DOT.add(DOT107);

					pushFollow(FOLLOW_xANYID_in_fullClassName1493);
					xANYID108=xANYID();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xANYID.add(xANYID108.getTree());
					}
					break;

				default :
					break loop35;
				}
			}

			// AST REWRITE
			// elements: xANYID, xID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 158:45: -> ^( NAME[\"\"] xID ( xANYID )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:48: ^( NAME[\"\"] xID ( xANYID )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:63: ( xANYID )*
				while ( stream_xANYID.hasNext() ) {
					adaptor.addChild(root_1, stream_xANYID.nextTree());
				}
				stream_xANYID.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "fullClassName"


	public static class sections_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sections"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:1: sections : ( section | xEOS )* -> ( section )* ;
	public final MatlabParser.sections_return sections() throws RecognitionException {
		MatlabParser.sections_return retval = new MatlabParser.sections_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope section109 =null;
		ParserRuleReturnScope xEOS110 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_section=new RewriteRuleSubtreeStream(adaptor,"rule section");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:10: ( ( section | xEOS )* -> ( section )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:12: ( section | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:12: ( section | xEOS )*
			loop36:
			while (true) {
				int alt36=3;
				int LA36_0 = input.LA(1);
				if ( (LA36_0==ID) && (((Keyword_EnumerationIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_EventsIdFollows())||(Keyword_MethodsIdFollows())))) {
					alt36=1;
				}
				else if ( (LA36_0==COMMA||LA36_0==EOL||LA36_0==SEMICOLON) ) {
					alt36=2;
				}

				switch (alt36) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:13: section
					{
					pushFollow(FOLLOW_section_in_sections1519);
					section109=section();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_section.add(section109.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:23: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_sections1523);
					xEOS110=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS110.getTree());
					}
					break;

				default :
					break loop36;
				}
			}

			// AST REWRITE
			// elements: section
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 160:30: -> ( section )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:33: ( section )*
				while ( stream_section.hasNext() ) {
					adaptor.addChild(root_0, stream_section.nextTree());
				}
				stream_section.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sections"


	public static class section_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "section"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:162:1: section : ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection );
	public final MatlabParser.section_return section() throws RecognitionException {
		MatlabParser.section_return retval = new MatlabParser.section_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope eventSection111 =null;
		ParserRuleReturnScope propertySection112 =null;
		ParserRuleReturnScope methodSection113 =null;
		ParserRuleReturnScope enumerationSection114 =null;

		RewriteRuleSubtreeStream stream_propertySection=new RewriteRuleSubtreeStream(adaptor,"rule propertySection");
		RewriteRuleSubtreeStream stream_methodSection=new RewriteRuleSubtreeStream(adaptor,"rule methodSection");
		RewriteRuleSubtreeStream stream_eventSection=new RewriteRuleSubtreeStream(adaptor,"rule eventSection");
		RewriteRuleSubtreeStream stream_enumerationSection=new RewriteRuleSubtreeStream(adaptor,"rule enumerationSection");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:162:9: ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection )
			int alt37=4;
			int LA37_0 = input.LA(1);
			if ( (LA37_0==ID) && (((Keyword_EnumerationIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_EventsIdFollows())||(Keyword_MethodsIdFollows())))) {
				int LA37_1 = input.LA(2);
				if ( ((Keyword_EventsIdFollows())) ) {
					alt37=1;
				}
				else if ( ((Keyword_PropertiesIdFollows())) ) {
					alt37=2;
				}
				else if ( ((Keyword_MethodsIdFollows())) ) {
					alt37=3;
				}
				else if ( ((Keyword_EnumerationIdFollows())) ) {
					alt37=4;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 37, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt37) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:162:11: eventSection
					{
					pushFollow(FOLLOW_eventSection_in_section1541);
					eventSection111=eventSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_eventSection.add(eventSection111.getTree());
					// AST REWRITE
					// elements: eventSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 162:24: -> eventSection
					{
						adaptor.addChild(root_0, stream_eventSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:163:5: propertySection
					{
					pushFollow(FOLLOW_propertySection_in_section1551);
					propertySection112=propertySection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_propertySection.add(propertySection112.getTree());
					// AST REWRITE
					// elements: propertySection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 163:21: -> propertySection
					{
						adaptor.addChild(root_0, stream_propertySection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:164:5: methodSection
					{
					pushFollow(FOLLOW_methodSection_in_section1561);
					methodSection113=methodSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodSection.add(methodSection113.getTree());
					// AST REWRITE
					// elements: methodSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 164:19: -> methodSection
					{
						adaptor.addChild(root_0, stream_methodSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:165:5: enumerationSection
					{
					pushFollow(FOLLOW_enumerationSection_in_section1571);
					enumerationSection114=enumerationSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_enumerationSection.add(enumerationSection114.getTree());
					// AST REWRITE
					// elements: enumerationSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 165:24: -> enumerationSection
					{
						adaptor.addChild(root_0, stream_enumerationSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "section"


	public static class eventSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "eventSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:1: eventSection : xEVENTS ( annotationPortion )? events END -> ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? ) ;
	public final MatlabParser.eventSection_return eventSection() throws RecognitionException {
		MatlabParser.eventSection_return retval = new MatlabParser.eventSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END118=null;
		ParserRuleReturnScope xEVENTS115 =null;
		ParserRuleReturnScope annotationPortion116 =null;
		ParserRuleReturnScope events117 =null;

		Object END118_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xEVENTS=new RewriteRuleSubtreeStream(adaptor,"rule xEVENTS");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_events=new RewriteRuleSubtreeStream(adaptor,"rule events");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:14: ( xEVENTS ( annotationPortion )? events END -> ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:16: xEVENTS ( annotationPortion )? events END
			{
			pushFollow(FOLLOW_xEVENTS_in_eventSection1588);
			xEVENTS115=xEVENTS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEVENTS.add(xEVENTS115.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:24: ( annotationPortion )?
			int alt38=2;
			int LA38_0 = input.LA(1);
			if ( (LA38_0==LPAREN) ) {
				alt38=1;
			}
			switch (alt38) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:25: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_eventSection1591);
					annotationPortion116=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion116.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_events_in_eventSection1595);
			events117=events();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_events.add(events117.getTree());
			END118=(Token)match(input,END,FOLLOW_END_in_eventSection1597); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END118);

			// AST REWRITE
			// elements: events, annotationPortion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 170:56: -> ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:59: ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENTSECTION, (xEVENTS115!=null?(xEVENTS115.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:90: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:111: ( events )?
				if ( stream_events.hasNext() ) {
					adaptor.addChild(root_1, stream_events.nextTree());
				}
				stream_events.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "eventSection"


	public static class events_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "events"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:1: events : ( event | xEOS )* -> ( event )* ;
	public final MatlabParser.events_return events() throws RecognitionException {
		MatlabParser.events_return retval = new MatlabParser.events_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope event119 =null;
		ParserRuleReturnScope xEOS120 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_event=new RewriteRuleSubtreeStream(adaptor,"rule event");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:8: ( ( event | xEOS )* -> ( event )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:10: ( event | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:10: ( event | xEOS )*
			loop39:
			while (true) {
				int alt39=3;
				int LA39_0 = input.LA(1);
				if ( (LA39_0==ID) ) {
					alt39=1;
				}
				else if ( (LA39_0==COMMA||LA39_0==EOL||LA39_0==SEMICOLON) ) {
					alt39=2;
				}

				switch (alt39) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:11: event
					{
					pushFollow(FOLLOW_event_in_events1624);
					event119=event();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_event.add(event119.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:19: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_events1628);
					xEOS120=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS120.getTree());
					}
					break;

				default :
					break loop39;
				}
			}

			// AST REWRITE
			// elements: event
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 172:26: -> ( event )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:29: ( event )*
				while ( stream_event.hasNext() ) {
					adaptor.addChild(root_0, stream_event.nextTree());
				}
				stream_event.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "events"


	public static class event_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "event"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:174:1: event : name xEOS -> ^( EVENT[\"\"] name ) ;
	public final MatlabParser.event_return event() throws RecognitionException {
		MatlabParser.event_return retval = new MatlabParser.event_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name121 =null;
		ParserRuleReturnScope xEOS122 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:174:7: ( name xEOS -> ^( EVENT[\"\"] name ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:174:9: name xEOS
			{
			pushFollow(FOLLOW_name_in_event1646);
			name121=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name121.getTree());
			pushFollow(FOLLOW_xEOS_in_event1648);
			xEOS122=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS122.getTree());
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 174:19: -> ^( EVENT[\"\"] name )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:174:22: ^( EVENT[\"\"] name )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENT, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "event"


	public static class propertySection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "propertySection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:1: propertySection : xPROPERTIES ( annotationPortion )? properties END -> ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? ) ;
	public final MatlabParser.propertySection_return propertySection() throws RecognitionException {
		MatlabParser.propertySection_return retval = new MatlabParser.propertySection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END126=null;
		ParserRuleReturnScope xPROPERTIES123 =null;
		ParserRuleReturnScope annotationPortion124 =null;
		ParserRuleReturnScope properties125 =null;

		Object END126_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xPROPERTIES=new RewriteRuleSubtreeStream(adaptor,"rule xPROPERTIES");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_properties=new RewriteRuleSubtreeStream(adaptor,"rule properties");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:17: ( xPROPERTIES ( annotationPortion )? properties END -> ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:19: xPROPERTIES ( annotationPortion )? properties END
			{
			pushFollow(FOLLOW_xPROPERTIES_in_propertySection1668);
			xPROPERTIES123=xPROPERTIES();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xPROPERTIES.add(xPROPERTIES123.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:31: ( annotationPortion )?
			int alt40=2;
			int LA40_0 = input.LA(1);
			if ( (LA40_0==LPAREN) ) {
				alt40=1;
			}
			switch (alt40) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:32: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_propertySection1671);
					annotationPortion124=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion124.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_properties_in_propertySection1675);
			properties125=properties();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_properties.add(properties125.getTree());
			END126=(Token)match(input,END,FOLLOW_END_in_propertySection1677); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END126);

			// AST REWRITE
			// elements: annotationPortion, properties
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 178:67: -> ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:70: ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PROPERTYSECTION, (xPROPERTIES123!=null?(xPROPERTIES123.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:108: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:129: ( properties )?
				if ( stream_properties.hasNext() ) {
					adaptor.addChild(root_1, stream_properties.nextTree());
				}
				stream_properties.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "propertySection"


	public static class properties_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "properties"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:1: properties : ( property | xEOS )* -> ( property )* ;
	public final MatlabParser.properties_return properties() throws RecognitionException {
		MatlabParser.properties_return retval = new MatlabParser.properties_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope property127 =null;
		ParserRuleReturnScope xEOS128 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_property=new RewriteRuleSubtreeStream(adaptor,"rule property");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:12: ( ( property | xEOS )* -> ( property )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:14: ( property | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:14: ( property | xEOS )*
			loop41:
			while (true) {
				int alt41=3;
				int LA41_0 = input.LA(1);
				if ( (LA41_0==ID) ) {
					alt41=1;
				}
				else if ( (LA41_0==COMMA||LA41_0==EOL||LA41_0==SEMICOLON) ) {
					alt41=2;
				}

				switch (alt41) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:15: property
					{
					pushFollow(FOLLOW_property_in_properties1704);
					property127=property();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property.add(property127.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:26: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_properties1708);
					xEOS128=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS128.getTree());
					}
					break;

				default :
					break loop41;
				}
			}

			// AST REWRITE
			// elements: property
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 180:33: -> ( property )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:36: ( property )*
				while ( stream_property.hasNext() ) {
					adaptor.addChild(root_0, stream_property.nextTree());
				}
				stream_property.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "properties"


	public static class property_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "property"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:1: property : name ( filter )? ( ASSIGN expression )? -> ^( PROPERTY[\"\"] name ( filter )? ( expression )? ) ;
	public final MatlabParser.property_return property() throws RecognitionException {
		MatlabParser.property_return retval = new MatlabParser.property_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASSIGN131=null;
		ParserRuleReturnScope name129 =null;
		ParserRuleReturnScope filter130 =null;
		ParserRuleReturnScope expression132 =null;

		Object ASSIGN131_tree=null;
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_filter=new RewriteRuleSubtreeStream(adaptor,"rule filter");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:10: ( name ( filter )? ( ASSIGN expression )? -> ^( PROPERTY[\"\"] name ( filter )? ( expression )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:12: name ( filter )? ( ASSIGN expression )?
			{
			pushFollow(FOLLOW_name_in_property1726);
			name129=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name129.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:17: ( filter )?
			int alt42=2;
			int LA42_0 = input.LA(1);
			if ( (LA42_0==AT) ) {
				alt42=1;
			}
			switch (alt42) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:18: filter
					{
					pushFollow(FOLLOW_filter_in_property1729);
					filter130=filter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_filter.add(filter130.getTree());
					}
					break;

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:27: ( ASSIGN expression )?
			int alt43=2;
			int LA43_0 = input.LA(1);
			if ( (LA43_0==ASSIGN) ) {
				alt43=1;
			}
			switch (alt43) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:28: ASSIGN expression
					{
					ASSIGN131=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_property1734); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN131);

					pushFollow(FOLLOW_expression_in_property1736);
					expression132=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression132.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: filter, name, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 182:48: -> ^( PROPERTY[\"\"] name ( filter )? ( expression )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:51: ^( PROPERTY[\"\"] name ( filter )? ( expression )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PROPERTY, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:71: ( filter )?
				if ( stream_filter.hasNext() ) {
					adaptor.addChild(root_1, stream_filter.nextTree());
				}
				stream_filter.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:81: ( expression )?
				if ( stream_expression.hasNext() ) {
					adaptor.addChild(root_1, stream_expression.nextTree());
				}
				stream_expression.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property"


	public static class methodSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:1: methodSection : xMETHODS ( annotationPortion )? methods END -> ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? ) ;
	public final MatlabParser.methodSection_return methodSection() throws RecognitionException {
		MatlabParser.methodSection_return retval = new MatlabParser.methodSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END136=null;
		ParserRuleReturnScope xMETHODS133 =null;
		ParserRuleReturnScope annotationPortion134 =null;
		ParserRuleReturnScope methods135 =null;

		Object END136_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xMETHODS=new RewriteRuleSubtreeStream(adaptor,"rule xMETHODS");
		RewriteRuleSubtreeStream stream_methods=new RewriteRuleSubtreeStream(adaptor,"rule methods");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:15: ( xMETHODS ( annotationPortion )? methods END -> ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:17: xMETHODS ( annotationPortion )? methods END
			{
			pushFollow(FOLLOW_xMETHODS_in_methodSection1768);
			xMETHODS133=xMETHODS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xMETHODS.add(xMETHODS133.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:26: ( annotationPortion )?
			int alt44=2;
			int LA44_0 = input.LA(1);
			if ( (LA44_0==LPAREN) ) {
				alt44=1;
			}
			switch (alt44) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:27: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_methodSection1771);
					annotationPortion134=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion134.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_methods_in_methodSection1775);
			methods135=methods();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_methods.add(methods135.getTree());
			END136=(Token)match(input,END,FOLLOW_END_in_methodSection1777); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END136);

			// AST REWRITE
			// elements: annotationPortion, methods
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 186:59: -> ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:62: ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(METHODSECTION, (xMETHODS133!=null?(xMETHODS133.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:95: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:116: ( methods )?
				if ( stream_methods.hasNext() ) {
					adaptor.addChild(root_1, stream_methods.nextTree());
				}
				stream_methods.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methodSection"


	public static class methods_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methods"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:1: methods : ( method | xEOS )* -> ( method )* ;
	public final MatlabParser.methods_return methods() throws RecognitionException {
		MatlabParser.methods_return retval = new MatlabParser.methods_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope method137 =null;
		ParserRuleReturnScope xEOS138 =null;

		RewriteRuleSubtreeStream stream_method=new RewriteRuleSubtreeStream(adaptor,"rule method");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:9: ( ( method | xEOS )* -> ( method )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:11: ( method | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:11: ( method | xEOS )*
			loop45:
			while (true) {
				int alt45=3;
				int LA45_0 = input.LA(1);
				if ( (LA45_0==FUNCTION||LA45_0==ID||LA45_0==LSQUARE) ) {
					alt45=1;
				}
				else if ( (LA45_0==COMMA||LA45_0==EOL||LA45_0==SEMICOLON) ) {
					alt45=2;
				}

				switch (alt45) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:12: method
					{
					pushFollow(FOLLOW_method_in_methods1804);
					method137=method();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_method.add(method137.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:21: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_methods1808);
					xEOS138=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS138.getTree());
					}
					break;

				default :
					break loop45;
				}
			}

			// AST REWRITE
			// elements: method
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 188:28: -> ( method )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:31: ( method )*
				while ( stream_method.hasNext() ) {
					adaptor.addChild(root_0, stream_method.nextTree());
				}
				stream_method.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methods"


	public static class method_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "method"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:190:1: method : ( regularMethod -> regularMethod | externalMethod -> externalMethod );
	public final MatlabParser.method_return method() throws RecognitionException {
		MatlabParser.method_return retval = new MatlabParser.method_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope regularMethod139 =null;
		ParserRuleReturnScope externalMethod140 =null;

		RewriteRuleSubtreeStream stream_externalMethod=new RewriteRuleSubtreeStream(adaptor,"rule externalMethod");
		RewriteRuleSubtreeStream stream_regularMethod=new RewriteRuleSubtreeStream(adaptor,"rule regularMethod");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:190:8: ( regularMethod -> regularMethod | externalMethod -> externalMethod )
			int alt46=2;
			int LA46_0 = input.LA(1);
			if ( (LA46_0==FUNCTION) ) {
				alt46=1;
			}
			else if ( (LA46_0==ID||LA46_0==LSQUARE) ) {
				alt46=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 46, 0, input);
				throw nvae;
			}

			switch (alt46) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:190:10: regularMethod
					{
					pushFollow(FOLLOW_regularMethod_in_method1826);
					regularMethod139=regularMethod();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_regularMethod.add(regularMethod139.getTree());
					// AST REWRITE
					// elements: regularMethod
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 190:24: -> regularMethod
					{
						adaptor.addChild(root_0, stream_regularMethod.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:191:7: externalMethod
					{
					pushFollow(FOLLOW_externalMethod_in_method1838);
					externalMethod140=externalMethod();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_externalMethod.add(externalMethod140.getTree());
					// AST REWRITE
					// elements: externalMethod
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 191:22: -> externalMethod
					{
						adaptor.addChild(root_0, stream_externalMethod.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "method"


	public static class regularMethod_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "regularMethod"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:1: regularMethod : FUNCTION methodSignature closeBody END -> ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? ) ;
	public final MatlabParser.regularMethod_return regularMethod() throws RecognitionException {
		MatlabParser.regularMethod_return retval = new MatlabParser.regularMethod_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION141=null;
		Token END144=null;
		ParserRuleReturnScope methodSignature142 =null;
		ParserRuleReturnScope closeBody143 =null;

		Object FUNCTION141_tree=null;
		Object END144_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_methodSignature=new RewriteRuleSubtreeStream(adaptor,"rule methodSignature");
		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:15: ( FUNCTION methodSignature closeBody END -> ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:17: FUNCTION methodSignature closeBody END
			{
			FUNCTION141=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_regularMethod1855); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION141);

			pushFollow(FOLLOW_methodSignature_in_regularMethod1857);
			methodSignature142=methodSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_methodSignature.add(methodSignature142.getTree());
			pushFollow(FOLLOW_closeBody_in_regularMethod1859);
			closeBody143=closeBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeBody.add(closeBody143.getTree());
			END144=(Token)match(input,END,FOLLOW_END_in_regularMethod1861); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END144);

			// AST REWRITE
			// elements: closeBody, methodSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 194:56: -> ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:59: ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(REGULARMETHOD, FUNCTION141), root_1);
				adaptor.addChild(root_1, stream_methodSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:102: ( closeBody )?
				if ( stream_closeBody.hasNext() ) {
					adaptor.addChild(root_1, stream_closeBody.nextTree());
				}
				stream_closeBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "regularMethod"


	public static class methodSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:196:1: methodSignature : ( ( outputPortion )? methodName1 ( inputPortion )? -> ( outputPortion )? methodName1 ( inputPortion )? | outputPortion methodName2 ( inputPortion )? -> ( outputPortion )? methodName2 ( inputPortion )? | methodName3 ( inputPortion )? -> methodName3 ( inputPortion )? );
	public final MatlabParser.methodSignature_return methodSignature() throws RecognitionException {
		MatlabParser.methodSignature_return retval = new MatlabParser.methodSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope outputPortion145 =null;
		ParserRuleReturnScope methodName1146 =null;
		ParserRuleReturnScope inputPortion147 =null;
		ParserRuleReturnScope outputPortion148 =null;
		ParserRuleReturnScope methodName2149 =null;
		ParserRuleReturnScope inputPortion150 =null;
		ParserRuleReturnScope methodName3151 =null;
		ParserRuleReturnScope inputPortion152 =null;

		RewriteRuleSubtreeStream stream_methodName3=new RewriteRuleSubtreeStream(adaptor,"rule methodName3");
		RewriteRuleSubtreeStream stream_methodName2=new RewriteRuleSubtreeStream(adaptor,"rule methodName2");
		RewriteRuleSubtreeStream stream_methodName1=new RewriteRuleSubtreeStream(adaptor,"rule methodName1");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");
		RewriteRuleSubtreeStream stream_outputPortion=new RewriteRuleSubtreeStream(adaptor,"rule outputPortion");

		Method_EnterSignature();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:197:34: ( ( outputPortion )? methodName1 ( inputPortion )? -> ( outputPortion )? methodName1 ( inputPortion )? | outputPortion methodName2 ( inputPortion )? -> ( outputPortion )? methodName2 ( inputPortion )? | methodName3 ( inputPortion )? -> methodName3 ( inputPortion )? )
			int alt51=3;
			alt51 = dfa51.predict(input);
			switch (alt51) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:3: ( outputPortion )? methodName1 ( inputPortion )?
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:3: ( outputPortion )?
					int alt47=2;
					int LA47_0 = input.LA(1);
					if ( (LA47_0==ID) ) {
						int LA47_1 = input.LA(2);
						if ( (LA47_1==ASSIGN) ) {
							alt47=1;
						}
					}
					else if ( (LA47_0==LSQUARE) ) {
						alt47=1;
					}
					switch (alt47) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:4: outputPortion
							{
							pushFollow(FOLLOW_outputPortion_in_methodSignature1892);
							outputPortion145=outputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_outputPortion.add(outputPortion145.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_methodName1_in_methodSignature1896);
					methodName1146=methodName1();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodName1.add(methodName1146.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:32: ( inputPortion )?
					int alt48=2;
					int LA48_0 = input.LA(1);
					if ( (LA48_0==LPAREN) ) {
						alt48=1;
					}
					switch (alt48) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:33: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_methodSignature1899);
							inputPortion147=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion147.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: methodName1, inputPortion, outputPortion
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 198:48: -> ( outputPortion )? methodName1 ( inputPortion )?
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:51: ( outputPortion )?
						if ( stream_outputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_outputPortion.nextTree());
						}
						stream_outputPortion.reset();

						adaptor.addChild(root_0, stream_methodName1.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:80: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:3: outputPortion methodName2 ( inputPortion )?
					{
					pushFollow(FOLLOW_outputPortion_in_methodSignature1919);
					outputPortion148=outputPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_outputPortion.add(outputPortion148.getTree());
					pushFollow(FOLLOW_methodName2_in_methodSignature1921);
					methodName2149=methodName2();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodName2.add(methodName2149.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:29: ( inputPortion )?
					int alt49=2;
					int LA49_0 = input.LA(1);
					if ( (LA49_0==LPAREN) ) {
						alt49=1;
					}
					switch (alt49) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:30: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_methodSignature1924);
							inputPortion150=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion150.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: methodName2, inputPortion, outputPortion
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 199:45: -> ( outputPortion )? methodName2 ( inputPortion )?
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:48: ( outputPortion )?
						if ( stream_outputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_outputPortion.nextTree());
						}
						stream_outputPortion.reset();

						adaptor.addChild(root_0, stream_methodName2.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:77: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:200:3: methodName3 ( inputPortion )?
					{
					pushFollow(FOLLOW_methodName3_in_methodSignature1944);
					methodName3151=methodName3();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodName3.add(methodName3151.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:200:15: ( inputPortion )?
					int alt50=2;
					int LA50_0 = input.LA(1);
					if ( (LA50_0==LPAREN) ) {
						alt50=1;
					}
					switch (alt50) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:200:16: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_methodSignature1947);
							inputPortion152=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion152.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: methodName3, inputPortion
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 200:31: -> methodName3 ( inputPortion )?
					{
						adaptor.addChild(root_0, stream_methodName3.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:200:46: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Method_ExitSignature();
		}
		return retval;
	}
	// $ANTLR end "methodSignature"


	public static class methodName1_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodName1"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:204:1: methodName1 : xID DOT xFUNCTIONID -> ^( NAME[\"\"] xID xFUNCTIONID ) ;
	public final MatlabParser.methodName1_return methodName1() throws RecognitionException {
		MatlabParser.methodName1_return retval = new MatlabParser.methodName1_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT154=null;
		ParserRuleReturnScope xID153 =null;
		ParserRuleReturnScope xFUNCTIONID155 =null;

		Object DOT154_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");
		RewriteRuleSubtreeStream stream_xFUNCTIONID=new RewriteRuleSubtreeStream(adaptor,"rule xFUNCTIONID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:204:13: ( xID DOT xFUNCTIONID -> ^( NAME[\"\"] xID xFUNCTIONID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:204:15: xID DOT xFUNCTIONID
			{
			pushFollow(FOLLOW_xID_in_methodName11971);
			xID153=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID153.getTree());
			DOT154=(Token)match(input,DOT,FOLLOW_DOT_in_methodName11973); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOT.add(DOT154);

			pushFollow(FOLLOW_xFUNCTIONID_in_methodName11975);
			xFUNCTIONID155=xFUNCTIONID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xFUNCTIONID.add(xFUNCTIONID155.getTree());
			// AST REWRITE
			// elements: xID, xFUNCTIONID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 204:35: -> ^( NAME[\"\"] xID xFUNCTIONID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:204:38: ^( NAME[\"\"] xID xFUNCTIONID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				adaptor.addChild(root_1, stream_xFUNCTIONID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methodName1"


	public static class methodName2_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodName2"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:206:1: methodName2 : xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) ;
	public final MatlabParser.methodName2_return methodName2() throws RecognitionException {
		MatlabParser.methodName2_return retval = new MatlabParser.methodName2_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xFUNCTIONID156 =null;

		RewriteRuleSubtreeStream stream_xFUNCTIONID=new RewriteRuleSubtreeStream(adaptor,"rule xFUNCTIONID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:206:13: ( xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:206:15: xFUNCTIONID
			{
			pushFollow(FOLLOW_xFUNCTIONID_in_methodName21995);
			xFUNCTIONID156=xFUNCTIONID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xFUNCTIONID.add(xFUNCTIONID156.getTree());
			// AST REWRITE
			// elements: xFUNCTIONID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 206:27: -> ^( NAME[\"\"] xFUNCTIONID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:206:30: ^( NAME[\"\"] xFUNCTIONID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xFUNCTIONID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methodName2"


	public static class methodName3_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodName3"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:208:1: methodName3 : xID -> ^( NAME[\"\"] xID ) ;
	public final MatlabParser.methodName3_return methodName3() throws RecognitionException {
		MatlabParser.methodName3_return retval = new MatlabParser.methodName3_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xID157 =null;

		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:208:13: ( xID -> ^( NAME[\"\"] xID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:208:15: xID
			{
			pushFollow(FOLLOW_xID_in_methodName32013);
			xID157=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID157.getTree());
			// AST REWRITE
			// elements: xID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 208:19: -> ^( NAME[\"\"] xID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:208:22: ^( NAME[\"\"] xID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methodName3"


	public static class externalMethod_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "externalMethod"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:210:1: externalMethod : methodSignature xEOS -> ^( EXTERNALMETHOD[\"\"] methodSignature ) ;
	public final MatlabParser.externalMethod_return externalMethod() throws RecognitionException {
		MatlabParser.externalMethod_return retval = new MatlabParser.externalMethod_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope methodSignature158 =null;
		ParserRuleReturnScope xEOS159 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_methodSignature=new RewriteRuleSubtreeStream(adaptor,"rule methodSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:210:16: ( methodSignature xEOS -> ^( EXTERNALMETHOD[\"\"] methodSignature ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:210:18: methodSignature xEOS
			{
			pushFollow(FOLLOW_methodSignature_in_externalMethod2031);
			methodSignature158=methodSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_methodSignature.add(methodSignature158.getTree());
			pushFollow(FOLLOW_xEOS_in_externalMethod2033);
			xEOS159=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS159.getTree());
			// AST REWRITE
			// elements: methodSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 210:39: -> ^( EXTERNALMETHOD[\"\"] methodSignature )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:210:42: ^( EXTERNALMETHOD[\"\"] methodSignature )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXTERNALMETHOD, ""), root_1);
				adaptor.addChild(root_1, stream_methodSignature.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "externalMethod"


	public static class enumerationSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "enumerationSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:1: enumerationSection : xENUMERATION ( annotationPortion )? enumerations END -> ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? ) ;
	public final MatlabParser.enumerationSection_return enumerationSection() throws RecognitionException {
		MatlabParser.enumerationSection_return retval = new MatlabParser.enumerationSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END163=null;
		ParserRuleReturnScope xENUMERATION160 =null;
		ParserRuleReturnScope annotationPortion161 =null;
		ParserRuleReturnScope enumerations162 =null;

		Object END163_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_enumerations=new RewriteRuleSubtreeStream(adaptor,"rule enumerations");
		RewriteRuleSubtreeStream stream_xENUMERATION=new RewriteRuleSubtreeStream(adaptor,"rule xENUMERATION");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:20: ( xENUMERATION ( annotationPortion )? enumerations END -> ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:22: xENUMERATION ( annotationPortion )? enumerations END
			{
			pushFollow(FOLLOW_xENUMERATION_in_enumerationSection2053);
			xENUMERATION160=xENUMERATION();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xENUMERATION.add(xENUMERATION160.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:35: ( annotationPortion )?
			int alt52=2;
			int LA52_0 = input.LA(1);
			if ( (LA52_0==LPAREN) ) {
				alt52=1;
			}
			switch (alt52) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:36: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_enumerationSection2056);
					annotationPortion161=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion161.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_enumerations_in_enumerationSection2060);
			enumerations162=enumerations();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_enumerations.add(enumerations162.getTree());
			END163=(Token)match(input,END,FOLLOW_END_in_enumerationSection2062); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END163);

			// AST REWRITE
			// elements: annotationPortion, enumerations
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 214:73: -> ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:76: ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ENUMERATIONSECTION, (xENUMERATION160!=null?(xENUMERATION160.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:118: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:139: ( enumerations )?
				if ( stream_enumerations.hasNext() ) {
					adaptor.addChild(root_1, stream_enumerations.nextTree());
				}
				stream_enumerations.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumerationSection"


	public static class enumerations_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "enumerations"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:1: enumerations : ( enumeration | xEOS )* -> ( enumeration )* ;
	public final MatlabParser.enumerations_return enumerations() throws RecognitionException {
		MatlabParser.enumerations_return retval = new MatlabParser.enumerations_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope enumeration164 =null;
		ParserRuleReturnScope xEOS165 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_enumeration=new RewriteRuleSubtreeStream(adaptor,"rule enumeration");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:14: ( ( enumeration | xEOS )* -> ( enumeration )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:16: ( enumeration | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:16: ( enumeration | xEOS )*
			loop53:
			while (true) {
				int alt53=3;
				int LA53_0 = input.LA(1);
				if ( (LA53_0==ID) ) {
					alt53=1;
				}
				else if ( (LA53_0==COMMA||LA53_0==EOL||LA53_0==SEMICOLON) ) {
					alt53=2;
				}

				switch (alt53) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:17: enumeration
					{
					pushFollow(FOLLOW_enumeration_in_enumerations2089);
					enumeration164=enumeration();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_enumeration.add(enumeration164.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:31: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_enumerations2093);
					xEOS165=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS165.getTree());
					}
					break;

				default :
					break loop53;
				}
			}

			// AST REWRITE
			// elements: enumeration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 216:38: -> ( enumeration )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:41: ( enumeration )*
				while ( stream_enumeration.hasNext() ) {
					adaptor.addChild(root_0, stream_enumeration.nextTree());
				}
				stream_enumeration.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumerations"


	public static class enumeration_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "enumeration"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:1: enumeration : name ( call )? -> ^( ENUMERATION[\"\"] name ( call )? ) ;
	public final MatlabParser.enumeration_return enumeration() throws RecognitionException {
		MatlabParser.enumeration_return retval = new MatlabParser.enumeration_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name166 =null;
		ParserRuleReturnScope call167 =null;

		RewriteRuleSubtreeStream stream_call=new RewriteRuleSubtreeStream(adaptor,"rule call");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:13: ( name ( call )? -> ^( ENUMERATION[\"\"] name ( call )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:15: name ( call )?
			{
			pushFollow(FOLLOW_name_in_enumeration2111);
			name166=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name166.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:20: ( call )?
			int alt54=2;
			int LA54_0 = input.LA(1);
			if ( (LA54_0==LPAREN) ) {
				alt54=1;
			}
			switch (alt54) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:21: call
					{
					pushFollow(FOLLOW_call_in_enumeration2114);
					call167=call();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_call.add(call167.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: call, name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 218:28: -> ^( ENUMERATION[\"\"] name ( call )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:31: ^( ENUMERATION[\"\"] name ( call )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ENUMERATION, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:54: ( call )?
				if ( stream_call.hasNext() ) {
					adaptor.addChild(root_1, stream_call.nextTree());
				}
				stream_call.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration"


	public static class call_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "call"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:220:1: call : LPAREN ( expressions )? RPAREN -> ( expressions )? ;
	public final MatlabParser.call_return call() throws RecognitionException {
		MatlabParser.call_return retval = new MatlabParser.call_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN168=null;
		Token RPAREN170=null;
		ParserRuleReturnScope expressions169 =null;

		Object LPAREN168_tree=null;
		Object RPAREN170_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expressions=new RewriteRuleSubtreeStream(adaptor,"rule expressions");

		Balance_EnterParenthesis(); Index_EnterParenthesis();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:221:63: ( LPAREN ( expressions )? RPAREN -> ( expressions )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:222:1: LPAREN ( expressions )? RPAREN
			{
			LPAREN168=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_call2144); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN168);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:222:8: ( expressions )?
			int alt55=2;
			int LA55_0 = input.LA(1);
			if ( (LA55_0==ID||LA55_0==IMAGINARY||LA55_0==LCURLY||(LA55_0 >= LPAREN && LA55_0 <= LSQUARE)||LA55_0==MINUS||LA55_0==NOT||LA55_0==PLUS||LA55_0==REAL||LA55_0==STRING) ) {
				alt55=1;
			}
			else if ( (LA55_0==END) && ((Index_IsActive()))) {
				alt55=1;
			}
			else if ( (LA55_0==AT||LA55_0==QUESTION) ) {
				alt55=1;
			}
			switch (alt55) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:222:9: expressions
					{
					pushFollow(FOLLOW_expressions_in_call2147);
					expressions169=expressions();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expressions.add(expressions169.getTree());
					}
					break;

			}

			RPAREN170=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_call2151); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN170);

			// AST REWRITE
			// elements: expressions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 222:30: -> ( expressions )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:222:33: ( expressions )?
				if ( stream_expressions.hasNext() ) {
					adaptor.addChild(root_0, stream_expressions.nextTree());
				}
				stream_expressions.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Index_ExitParenthesis(); Balance_ExitParenthesis();
		}
		return retval;
	}
	// $ANTLR end "call"


	public static class expressions_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expressions"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:1: expressions : expression ( COMMA expression )* -> ( expression )+ ;
	public final MatlabParser.expressions_return expressions() throws RecognitionException {
		MatlabParser.expressions_return retval = new MatlabParser.expressions_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA172=null;
		ParserRuleReturnScope expression171 =null;
		ParserRuleReturnScope expression173 =null;

		Object COMMA172_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:13: ( expression ( COMMA expression )* -> ( expression )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:15: expression ( COMMA expression )*
			{
			pushFollow(FOLLOW_expression_in_expressions2171);
			expression171=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression171.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:26: ( COMMA expression )*
			loop56:
			while (true) {
				int alt56=2;
				int LA56_0 = input.LA(1);
				if ( (LA56_0==COMMA) ) {
					alt56=1;
				}

				switch (alt56) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:27: COMMA expression
					{
					COMMA172=(Token)match(input,COMMA,FOLLOW_COMMA_in_expressions2174); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA172);

					pushFollow(FOLLOW_expression_in_expressions2176);
					expression173=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression173.getTree());
					}
					break;

				default :
					break loop56;
				}
			}

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 225:46: -> ( expression )+
			{
				if ( !(stream_expression.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.hasNext() ) {
					adaptor.addChild(root_0, stream_expression.nextTree());
				}
				stream_expression.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expressions"


	public static class statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "statement"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:1: statement : ( ( assignment )=> assignment -> assignment | ( action )=> action -> action | ( simpleCommand )=> simpleCommand -> simpleCommand | ( abortCommand )=> abortCommand -> abortCommand | standardCommand -> standardCommand | bang -> bang | breakDef -> breakDef | continueDef -> continueDef | forDef -> forDef | global -> global | ifDef -> ifDef | parfor -> parfor | persistent -> persistent | returnDef -> returnDef | spmd -> spmd | switchDef -> switchDef | tryDef -> tryDef | whileDef -> whileDef );
	public final MatlabParser.statement_return statement() throws RecognitionException {
		MatlabParser.statement_return retval = new MatlabParser.statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope assignment174 =null;
		ParserRuleReturnScope action175 =null;
		ParserRuleReturnScope simpleCommand176 =null;
		ParserRuleReturnScope abortCommand177 =null;
		ParserRuleReturnScope standardCommand178 =null;
		ParserRuleReturnScope bang179 =null;
		ParserRuleReturnScope breakDef180 =null;
		ParserRuleReturnScope continueDef181 =null;
		ParserRuleReturnScope forDef182 =null;
		ParserRuleReturnScope global183 =null;
		ParserRuleReturnScope ifDef184 =null;
		ParserRuleReturnScope parfor185 =null;
		ParserRuleReturnScope persistent186 =null;
		ParserRuleReturnScope returnDef187 =null;
		ParserRuleReturnScope spmd188 =null;
		ParserRuleReturnScope switchDef189 =null;
		ParserRuleReturnScope tryDef190 =null;
		ParserRuleReturnScope whileDef191 =null;

		RewriteRuleSubtreeStream stream_spmd=new RewriteRuleSubtreeStream(adaptor,"rule spmd");
		RewriteRuleSubtreeStream stream_continueDef=new RewriteRuleSubtreeStream(adaptor,"rule continueDef");
		RewriteRuleSubtreeStream stream_forDef=new RewriteRuleSubtreeStream(adaptor,"rule forDef");
		RewriteRuleSubtreeStream stream_parfor=new RewriteRuleSubtreeStream(adaptor,"rule parfor");
		RewriteRuleSubtreeStream stream_assignment=new RewriteRuleSubtreeStream(adaptor,"rule assignment");
		RewriteRuleSubtreeStream stream_global=new RewriteRuleSubtreeStream(adaptor,"rule global");
		RewriteRuleSubtreeStream stream_abortCommand=new RewriteRuleSubtreeStream(adaptor,"rule abortCommand");
		RewriteRuleSubtreeStream stream_standardCommand=new RewriteRuleSubtreeStream(adaptor,"rule standardCommand");
		RewriteRuleSubtreeStream stream_whileDef=new RewriteRuleSubtreeStream(adaptor,"rule whileDef");
		RewriteRuleSubtreeStream stream_bang=new RewriteRuleSubtreeStream(adaptor,"rule bang");
		RewriteRuleSubtreeStream stream_returnDef=new RewriteRuleSubtreeStream(adaptor,"rule returnDef");
		RewriteRuleSubtreeStream stream_simpleCommand=new RewriteRuleSubtreeStream(adaptor,"rule simpleCommand");
		RewriteRuleSubtreeStream stream_action=new RewriteRuleSubtreeStream(adaptor,"rule action");
		RewriteRuleSubtreeStream stream_tryDef=new RewriteRuleSubtreeStream(adaptor,"rule tryDef");
		RewriteRuleSubtreeStream stream_persistent=new RewriteRuleSubtreeStream(adaptor,"rule persistent");
		RewriteRuleSubtreeStream stream_switchDef=new RewriteRuleSubtreeStream(adaptor,"rule switchDef");
		RewriteRuleSubtreeStream stream_breakDef=new RewriteRuleSubtreeStream(adaptor,"rule breakDef");
		RewriteRuleSubtreeStream stream_ifDef=new RewriteRuleSubtreeStream(adaptor,"rule ifDef");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:11: ( ( assignment )=> assignment -> assignment | ( action )=> action -> action | ( simpleCommand )=> simpleCommand -> simpleCommand | ( abortCommand )=> abortCommand -> abortCommand | standardCommand -> standardCommand | bang -> bang | breakDef -> breakDef | continueDef -> continueDef | forDef -> forDef | global -> global | ifDef -> ifDef | parfor -> parfor | persistent -> persistent | returnDef -> returnDef | spmd -> spmd | switchDef -> switchDef | tryDef -> tryDef | whileDef -> whileDef )
			int alt57=18;
			int LA57_0 = input.LA(1);
			if ( (LA57_0==ID) ) {
				int LA57_1 = input.LA(2);
				if ( ((synpred2_MatlabParser()&&(True()))) ) {
					alt57=1;
				}
				else if ( ((synpred3_MatlabParser()&&(True()))) ) {
					alt57=2;
				}
				else if ( ((synpred4_MatlabParser()&&(Command_IsEnabled()))) ) {
					alt57=3;
				}
				else if ( ((synpred5_MatlabParser()&&(Command_IsEnabled()))) ) {
					alt57=4;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 57, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA57_0==LSQUARE) ) {
				int LA57_2 = input.LA(2);
				if ( ((synpred2_MatlabParser()&&(True()))) ) {
					alt57=1;
				}
				else if ( ((synpred3_MatlabParser()&&(True()))) ) {
					alt57=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 57, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA57_0==PLUS) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==MINUS) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==NOT) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==REAL) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==IMAGINARY) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==STRING) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==LCURLY) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==LPAREN) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==END) && ((((Index_IsActive())&&synpred3_MatlabParser())&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==AT) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==QUESTION) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==COMMAND) ) {
				alt57=5;
			}
			else if ( (LA57_0==EXCLAMATION) ) {
				alt57=6;
			}
			else if ( (LA57_0==BREAK) ) {
				alt57=7;
			}
			else if ( (LA57_0==CONTINUE) ) {
				alt57=8;
			}
			else if ( (LA57_0==FOR) ) {
				alt57=9;
			}
			else if ( (LA57_0==GLOBAL) ) {
				alt57=10;
			}
			else if ( (LA57_0==IF) ) {
				alt57=11;
			}
			else if ( (LA57_0==PARFOR) ) {
				alt57=12;
			}
			else if ( (LA57_0==PERSISTENT) ) {
				alt57=13;
			}
			else if ( (LA57_0==RETURN) ) {
				alt57=14;
			}
			else if ( (LA57_0==SPMD) ) {
				alt57=15;
			}
			else if ( (LA57_0==SWITCH) ) {
				alt57=16;
			}
			else if ( (LA57_0==TRY) ) {
				alt57=17;
			}
			else if ( (LA57_0==WHILE) ) {
				alt57=18;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 57, 0, input);
				throw nvae;
			}

			switch (alt57) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:13: ( assignment )=> assignment
					{
					pushFollow(FOLLOW_assignment_in_statement2201);
					assignment174=assignment();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assignment.add(assignment174.getTree());
					// AST REWRITE
					// elements: assignment
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 229:39: -> assignment
					{
						adaptor.addChild(root_0, stream_assignment.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:230:13: ( action )=> action
					{
					pushFollow(FOLLOW_action_in_statement2224);
					action175=action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_action.add(action175.getTree());
					// AST REWRITE
					// elements: action
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 230:31: -> action
					{
						adaptor.addChild(root_0, stream_action.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:231:7: ( simpleCommand )=> simpleCommand
					{
					pushFollow(FOLLOW_simpleCommand_in_statement2241);
					simpleCommand176=simpleCommand();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_simpleCommand.add(simpleCommand176.getTree());
					// AST REWRITE
					// elements: simpleCommand
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 231:39: -> simpleCommand
					{
						adaptor.addChild(root_0, stream_simpleCommand.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:232:7: ( abortCommand )=> abortCommand
					{
					pushFollow(FOLLOW_abortCommand_in_statement2258);
					abortCommand177=abortCommand();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_abortCommand.add(abortCommand177.getTree());
					// AST REWRITE
					// elements: abortCommand
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 232:37: -> abortCommand
					{
						adaptor.addChild(root_0, stream_abortCommand.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:233:7: standardCommand
					{
					pushFollow(FOLLOW_standardCommand_in_statement2270);
					standardCommand178=standardCommand();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_standardCommand.add(standardCommand178.getTree());
					// AST REWRITE
					// elements: standardCommand
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 233:23: -> standardCommand
					{
						adaptor.addChild(root_0, stream_standardCommand.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:234:7: bang
					{
					pushFollow(FOLLOW_bang_in_statement2282);
					bang179=bang();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_bang.add(bang179.getTree());
					// AST REWRITE
					// elements: bang
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 234:12: -> bang
					{
						adaptor.addChild(root_0, stream_bang.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:235:13: breakDef
					{
					pushFollow(FOLLOW_breakDef_in_statement2300);
					breakDef180=breakDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_breakDef.add(breakDef180.getTree());
					// AST REWRITE
					// elements: breakDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 235:22: -> breakDef
					{
						adaptor.addChild(root_0, stream_breakDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:236:13: continueDef
					{
					pushFollow(FOLLOW_continueDef_in_statement2318);
					continueDef181=continueDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_continueDef.add(continueDef181.getTree());
					// AST REWRITE
					// elements: continueDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 236:25: -> continueDef
					{
						adaptor.addChild(root_0, stream_continueDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:237:13: forDef
					{
					pushFollow(FOLLOW_forDef_in_statement2336);
					forDef182=forDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_forDef.add(forDef182.getTree());
					// AST REWRITE
					// elements: forDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 237:20: -> forDef
					{
						adaptor.addChild(root_0, stream_forDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:238:13: global
					{
					pushFollow(FOLLOW_global_in_statement2354);
					global183=global();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_global.add(global183.getTree());
					// AST REWRITE
					// elements: global
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 238:20: -> global
					{
						adaptor.addChild(root_0, stream_global.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:239:13: ifDef
					{
					pushFollow(FOLLOW_ifDef_in_statement2372);
					ifDef184=ifDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_ifDef.add(ifDef184.getTree());
					// AST REWRITE
					// elements: ifDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 239:19: -> ifDef
					{
						adaptor.addChild(root_0, stream_ifDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 12 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:240:13: parfor
					{
					pushFollow(FOLLOW_parfor_in_statement2390);
					parfor185=parfor();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parfor.add(parfor185.getTree());
					// AST REWRITE
					// elements: parfor
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 240:20: -> parfor
					{
						adaptor.addChild(root_0, stream_parfor.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 13 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:241:13: persistent
					{
					pushFollow(FOLLOW_persistent_in_statement2408);
					persistent186=persistent();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_persistent.add(persistent186.getTree());
					// AST REWRITE
					// elements: persistent
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 241:24: -> persistent
					{
						adaptor.addChild(root_0, stream_persistent.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 14 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:242:13: returnDef
					{
					pushFollow(FOLLOW_returnDef_in_statement2426);
					returnDef187=returnDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_returnDef.add(returnDef187.getTree());
					// AST REWRITE
					// elements: returnDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 242:23: -> returnDef
					{
						adaptor.addChild(root_0, stream_returnDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 15 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:243:7: spmd
					{
					pushFollow(FOLLOW_spmd_in_statement2438);
					spmd188=spmd();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_spmd.add(spmd188.getTree());
					// AST REWRITE
					// elements: spmd
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 243:12: -> spmd
					{
						adaptor.addChild(root_0, stream_spmd.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 16 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:244:13: switchDef
					{
					pushFollow(FOLLOW_switchDef_in_statement2456);
					switchDef189=switchDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_switchDef.add(switchDef189.getTree());
					// AST REWRITE
					// elements: switchDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 244:23: -> switchDef
					{
						adaptor.addChild(root_0, stream_switchDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 17 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:245:13: tryDef
					{
					pushFollow(FOLLOW_tryDef_in_statement2474);
					tryDef190=tryDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_tryDef.add(tryDef190.getTree());
					// AST REWRITE
					// elements: tryDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 245:20: -> tryDef
					{
						adaptor.addChild(root_0, stream_tryDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 18 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:246:13: whileDef
					{
					pushFollow(FOLLOW_whileDef_in_statement2492);
					whileDef191=whileDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_whileDef.add(whileDef191.getTree());
					// AST REWRITE
					// elements: whileDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 246:22: -> whileDef
					{
						adaptor.addChild(root_0, stream_whileDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "statement"


	public static class assignment_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "assignment"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:251:1: assignment :{...}? => assignmentCore -> assignmentCore ;
	public final MatlabParser.assignment_return assignment() throws RecognitionException {
		MatlabParser.assignment_return retval = new MatlabParser.assignment_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope assignmentCore192 =null;

		RewriteRuleSubtreeStream stream_assignmentCore=new RewriteRuleSubtreeStream(adaptor,"rule assignmentCore");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:251:12: ({...}? => assignmentCore -> assignmentCore )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:251:14: {...}? => assignmentCore
			{
			if ( !((True())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "assignment", "True()");
			}
			pushFollow(FOLLOW_assignmentCore_in_assignment2520);
			assignmentCore192=assignmentCore();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assignmentCore.add(assignmentCore192.getTree());
			// AST REWRITE
			// elements: assignmentCore
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 251:41: -> assignmentCore
			{
				adaptor.addChild(root_0, stream_assignmentCore.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assignment"


	public static class assignmentCore_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "assignmentCore"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:253:1: assignmentCore : ( chain ASSIGN expression xEOS -> ^( ASSIGN chain expression xEOS ) | storage ASSIGN expression xEOS -> ^( ASSIGN storage expression xEOS ) );
	public final MatlabParser.assignmentCore_return assignmentCore() throws RecognitionException {
		MatlabParser.assignmentCore_return retval = new MatlabParser.assignmentCore_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASSIGN194=null;
		Token ASSIGN198=null;
		ParserRuleReturnScope chain193 =null;
		ParserRuleReturnScope expression195 =null;
		ParserRuleReturnScope xEOS196 =null;
		ParserRuleReturnScope storage197 =null;
		ParserRuleReturnScope expression199 =null;
		ParserRuleReturnScope xEOS200 =null;

		Object ASSIGN194_tree=null;
		Object ASSIGN198_tree=null;
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_chain=new RewriteRuleSubtreeStream(adaptor,"rule chain");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_storage=new RewriteRuleSubtreeStream(adaptor,"rule storage");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:253:16: ( chain ASSIGN expression xEOS -> ^( ASSIGN chain expression xEOS ) | storage ASSIGN expression xEOS -> ^( ASSIGN storage expression xEOS ) )
			int alt58=2;
			int LA58_0 = input.LA(1);
			if ( (LA58_0==ID) ) {
				alt58=1;
			}
			else if ( (LA58_0==LSQUARE) ) {
				alt58=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 58, 0, input);
				throw nvae;
			}

			switch (alt58) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:253:18: chain ASSIGN expression xEOS
					{
					pushFollow(FOLLOW_chain_in_assignmentCore2533);
					chain193=chain();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_chain.add(chain193.getTree());
					ASSIGN194=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentCore2535); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN194);

					pushFollow(FOLLOW_expression_in_assignmentCore2537);
					expression195=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression195.getTree());
					pushFollow(FOLLOW_xEOS_in_assignmentCore2539);
					xEOS196=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS196.getTree());
					// AST REWRITE
					// elements: chain, xEOS, expression, ASSIGN
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 253:47: -> ^( ASSIGN chain expression xEOS )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:253:50: ^( ASSIGN chain expression xEOS )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_ASSIGN.nextNode(), root_1);
						adaptor.addChild(root_1, stream_chain.nextTree());
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_1, stream_xEOS.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:254:9: storage ASSIGN expression xEOS
					{
					pushFollow(FOLLOW_storage_in_assignmentCore2561);
					storage197=storage();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_storage.add(storage197.getTree());
					ASSIGN198=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentCore2563); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN198);

					pushFollow(FOLLOW_expression_in_assignmentCore2565);
					expression199=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression199.getTree());
					pushFollow(FOLLOW_xEOS_in_assignmentCore2567);
					xEOS200=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS200.getTree());
					// AST REWRITE
					// elements: ASSIGN, storage, xEOS, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 254:40: -> ^( ASSIGN storage expression xEOS )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:254:43: ^( ASSIGN storage expression xEOS )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_ASSIGN.nextNode(), root_1);
						adaptor.addChild(root_1, stream_storage.nextTree());
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_1, stream_xEOS.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assignmentCore"


	public static class storage_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "storage"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:257:1: storage : LSQUARE ( COMMA )? slots ( COMMA )? RSQUARE -> ^( STORAGE[\"\"] slots ) ;
	public final MatlabParser.storage_return storage() throws RecognitionException {
		MatlabParser.storage_return retval = new MatlabParser.storage_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE201=null;
		Token COMMA202=null;
		Token COMMA204=null;
		Token RSQUARE205=null;
		ParserRuleReturnScope slots203 =null;

		Object LSQUARE201_tree=null;
		Object COMMA202_tree=null;
		Object COMMA204_tree=null;
		Object RSQUARE205_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_slots=new RewriteRuleSubtreeStream(adaptor,"rule slots");

		Balance_EnterStorageSquareBrace();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:258:44: ( LSQUARE ( COMMA )? slots ( COMMA )? RSQUARE -> ^( STORAGE[\"\"] slots ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:1: LSQUARE ( COMMA )? slots ( COMMA )? RSQUARE
			{
			LSQUARE201=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_storage2599); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE201);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:9: ( COMMA )?
			int alt59=2;
			int LA59_0 = input.LA(1);
			if ( (LA59_0==COMMA) ) {
				alt59=1;
			}
			switch (alt59) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:10: COMMA
					{
					COMMA202=(Token)match(input,COMMA,FOLLOW_COMMA_in_storage2602); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA202);

					}
					break;

			}

			pushFollow(FOLLOW_slots_in_storage2606);
			slots203=slots();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_slots.add(slots203.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:24: ( COMMA )?
			int alt60=2;
			int LA60_0 = input.LA(1);
			if ( (LA60_0==COMMA) ) {
				alt60=1;
			}
			switch (alt60) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:25: COMMA
					{
					COMMA204=(Token)match(input,COMMA,FOLLOW_COMMA_in_storage2609); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA204);

					}
					break;

			}

			RSQUARE205=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_storage2613); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE205);

			// AST REWRITE
			// elements: slots
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 259:41: -> ^( STORAGE[\"\"] slots )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:44: ^( STORAGE[\"\"] slots )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(STORAGE, ""), root_1);
				adaptor.addChild(root_1, stream_slots.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitStorageSquareBrace();
		}
		return retval;
	}
	// $ANTLR end "storage"


	public static class slots_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "slots"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:1: slots : slot ({...}? => ( COMMA )? slot )* -> ( slot )+ ;
	public final MatlabParser.slots_return slots() throws RecognitionException {
		MatlabParser.slots_return retval = new MatlabParser.slots_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA207=null;
		ParserRuleReturnScope slot206 =null;
		ParserRuleReturnScope slot208 =null;

		Object COMMA207_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_slot=new RewriteRuleSubtreeStream(adaptor,"rule slot");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:7: ( slot ({...}? => ( COMMA )? slot )* -> ( slot )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:9: slot ({...}? => ( COMMA )? slot )*
			{
			pushFollow(FOLLOW_slot_in_slots2635);
			slot206=slot();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_slot.add(slot206.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:14: ({...}? => ( COMMA )? slot )*
			loop62:
			while (true) {
				int alt62=2;
				int LA62_0 = input.LA(1);
				if ( (LA62_0==COMMA) ) {
					int LA62_1 = input.LA(2);
					if ( (LA62_1==ID||LA62_1==NOT||LA62_1==QUESTION) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
						alt62=1;
					}

				}
				else if ( (LA62_0==ID||LA62_0==NOT||LA62_0==QUESTION) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
					alt62=1;
				}

				switch (alt62) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:15: {...}? => ( COMMA )? slot
					{
					if ( !((Separator_CommaFollowsOrSpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "slots", "Separator_CommaFollowsOrSpacesPrecede()");
					}
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:60: ( COMMA )?
					int alt61=2;
					int LA61_0 = input.LA(1);
					if ( (LA61_0==COMMA) ) {
						alt61=1;
					}
					switch (alt61) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:61: COMMA
							{
							COMMA207=(Token)match(input,COMMA,FOLLOW_COMMA_in_slots2642); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA207);

							}
							break;

					}

					pushFollow(FOLLOW_slot_in_slots2646);
					slot208=slot();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_slot.add(slot208.getTree());
					}
					break;

				default :
					break loop62;
				}
			}

			// AST REWRITE
			// elements: slot
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 262:76: -> ( slot )+
			{
				if ( !(stream_slot.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_slot.hasNext() ) {
					adaptor.addChild(root_0, stream_slot.nextTree());
				}
				stream_slot.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "slots"


	public static class slot_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "slot"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:264:1: slot : ( chain -> chain | metaclass -> metaclass | NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) );
	public final MatlabParser.slot_return slot() throws RecognitionException {
		MatlabParser.slot_return retval = new MatlabParser.slot_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token NOT211=null;
		ParserRuleReturnScope chain209 =null;
		ParserRuleReturnScope metaclass210 =null;

		Object NOT211_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_chain=new RewriteRuleSubtreeStream(adaptor,"rule chain");
		RewriteRuleSubtreeStream stream_metaclass=new RewriteRuleSubtreeStream(adaptor,"rule metaclass");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:264:6: ( chain -> chain | metaclass -> metaclass | NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) )
			int alt63=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt63=1;
				}
				break;
			case QUESTION:
				{
				alt63=2;
				}
				break;
			case NOT:
				{
				alt63=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 63, 0, input);
				throw nvae;
			}
			switch (alt63) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:264:8: chain
					{
					pushFollow(FOLLOW_chain_in_slot2664);
					chain209=chain();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_chain.add(chain209.getTree());
					// AST REWRITE
					// elements: chain
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 264:14: -> chain
					{
						adaptor.addChild(root_0, stream_chain.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:265:5: metaclass
					{
					pushFollow(FOLLOW_metaclass_in_slot2674);
					metaclass210=metaclass();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_metaclass.add(metaclass210.getTree());
					// AST REWRITE
					// elements: metaclass
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 265:15: -> metaclass
					{
						adaptor.addChild(root_0, stream_metaclass.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:266:5: NOT
					{
					NOT211=(Token)match(input,NOT,FOLLOW_NOT_in_slot2684); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT211);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 266:9: -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:266:12: ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_1);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:266:22: ^( NAME[\"\"] ID[$NOT] )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_2);
						adaptor.addChild(root_2, (Object)adaptor.create(ID, NOT211));
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "slot"


	public static class action_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "action"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:271:1: action :{...}? => expression xEOS -> ^( ACTION[\"\"] expression xEOS ) ;
	public final MatlabParser.action_return action() throws RecognitionException {
		MatlabParser.action_return retval = new MatlabParser.action_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression212 =null;
		ParserRuleReturnScope xEOS213 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:271:8: ({...}? => expression xEOS -> ^( ACTION[\"\"] expression xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:271:10: {...}? => expression xEOS
			{
			if ( !((True())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "action", "True()");
			}
			pushFollow(FOLLOW_expression_in_action2715);
			expression212=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression212.getTree());
			pushFollow(FOLLOW_xEOS_in_action2717);
			xEOS213=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS213.getTree());
			// AST REWRITE
			// elements: xEOS, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 271:38: -> ^( ACTION[\"\"] expression xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:271:41: ^( ACTION[\"\"] expression xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ACTION, ""), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "action"


	public static class simpleCommand_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simpleCommand"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:1: simpleCommand :{...}? => var simpleTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS ) ;
	public final MatlabParser.simpleCommand_return simpleCommand() throws RecognitionException {
		MatlabParser.simpleCommand_return retval = new MatlabParser.simpleCommand_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope var214 =null;
		ParserRuleReturnScope simpleTexts215 =null;
		ParserRuleReturnScope xEOS216 =null;

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_simpleTexts=new RewriteRuleSubtreeStream(adaptor,"rule simpleTexts");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:15: ({...}? => var simpleTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:17: {...}? => var simpleTexts xEOS
			{
			if ( !((Command_IsEnabled())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "simpleCommand", "Command_IsEnabled()");
			}
			pushFollow(FOLLOW_var_in_simpleCommand2742);
			var214=var();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_var.add(var214.getTree());
			pushFollow(FOLLOW_simpleTexts_in_simpleCommand2744);
			simpleTexts215=simpleTexts();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_simpleTexts.add(simpleTexts215.getTree());
			pushFollow(FOLLOW_xEOS_in_simpleCommand2746);
			xEOS216=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS216.getTree());
			// AST REWRITE
			// elements: simpleTexts, var, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 275:63: -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:66: ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ACTION, ""), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:79: ^( PARENTHESIS[\"\"] var simpleTexts )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(PARENTHESIS, ""), root_2);
				adaptor.addChild(root_2, stream_var.nextTree());
				adaptor.addChild(root_2, stream_simpleTexts.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simpleCommand"


	public static class simpleTexts_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simpleTexts"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:1: simpleTexts : simpleText ({...}? => simpleText )* -> ( simpleText )+ ;
	public final MatlabParser.simpleTexts_return simpleTexts() throws RecognitionException {
		MatlabParser.simpleTexts_return retval = new MatlabParser.simpleTexts_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope simpleText217 =null;
		ParserRuleReturnScope simpleText218 =null;

		RewriteRuleSubtreeStream stream_simpleText=new RewriteRuleSubtreeStream(adaptor,"rule simpleText");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:13: ( simpleText ({...}? => simpleText )* -> ( simpleText )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:15: simpleText ({...}? => simpleText )*
			{
			pushFollow(FOLLOW_simpleText_in_simpleTexts2773);
			simpleText217=simpleText();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_simpleText.add(simpleText217.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:26: ({...}? => simpleText )*
			loop64:
			while (true) {
				int alt64=2;
				int LA64_0 = input.LA(1);
				if ( ((LA64_0 >= AND && LA64_0 <= COLON)||(LA64_0 >= COMMAND && LA64_0 <= CONTINUE)||(LA64_0 >= DEFAULTBLOCK && LA64_0 <= END)||(LA64_0 >= EQ && LA64_0 <= IMG)||(LA64_0 >= LDIV && LA64_0 <= LINECOMMENT3)||(LA64_0 >= LT && LA64_0 <= QUESTION)||(LA64_0 >= RDIV && LA64_0 <= RETURN)||(LA64_0 >= SHORTAND && LA64_0 <= TIMES)||(LA64_0 >= TRY && LA64_0 <= VCAT)) && ((Separator_SpacesPrecede()))) {
					alt64=1;
				}

				switch (alt64) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:27: {...}? => simpleText
					{
					if ( !((Separator_SpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "simpleTexts", "Separator_SpacesPrecede()");
					}
					pushFollow(FOLLOW_simpleText_in_simpleTexts2779);
					simpleText218=simpleText();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_simpleText.add(simpleText218.getTree());
					}
					break;

				default :
					break loop64;
				}
			}

			// AST REWRITE
			// elements: simpleText
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 277:71: -> ( simpleText )+
			{
				if ( !(stream_simpleText.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_simpleText.hasNext() ) {
					adaptor.addChild(root_0, stream_simpleText.nextTree());
				}
				stream_simpleText.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simpleTexts"


	public static class simpleText_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simpleText"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:279:1: simpleText : (x1= simpleBlock ) ( options {greedy=true; } :{...}? =>x2= simpleBlock )* -> STRING[$x1.start, text] ;
	public final MatlabParser.simpleText_return simpleText() throws RecognitionException {
		MatlabParser.simpleText_return retval = new MatlabParser.simpleText_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_simpleBlock=new RewriteRuleSubtreeStream(adaptor,"rule simpleBlock");

		String text = null;
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:280:29: ( (x1= simpleBlock ) ( options {greedy=true; } :{...}? =>x2= simpleBlock )* -> STRING[$x1.start, text] )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:2: (x1= simpleBlock ) ( options {greedy=true; } :{...}? =>x2= simpleBlock )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:2: (x1= simpleBlock )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:2: x1= simpleBlock
			{
			pushFollow(FOLLOW_simpleBlock_in_simpleText2805);
			x1=simpleBlock();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_simpleBlock.add(x1.getTree());
			if ( state.backtracking==0 ) {text = (x1!=null?((MatlabParser.simpleBlock_return)x1).blockText:null);}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:42: ( options {greedy=true; } :{...}? =>x2= simpleBlock )*
			loop65:
			while (true) {
				int alt65=2;
				int LA65_0 = input.LA(1);
				if ( (LA65_0==STRING) ) {
					int LA65_1 = input.LA(2);
					if ( ((!Separator_SpacesPrecede())) ) {
						alt65=1;
					}

				}
				else if ( ((LA65_0 >= AND && LA65_0 <= COLON)||(LA65_0 >= COMMAND && LA65_0 <= CONTINUE)||(LA65_0 >= DEFAULTBLOCK && LA65_0 <= END)||(LA65_0 >= EQ && LA65_0 <= IMG)||(LA65_0 >= LDIV && LA65_0 <= LINECOMMENT3)||(LA65_0 >= LT && LA65_0 <= QUESTION)||(LA65_0 >= RDIV && LA65_0 <= RETURN)||(LA65_0 >= SHORTAND && LA65_0 <= START)||(LA65_0 >= STRINGBLOCK && LA65_0 <= TIMES)||(LA65_0 >= TRY && LA65_0 <= VCAT)) ) {
					int LA65_2 = input.LA(2);
					if ( ((!Separator_SpacesPrecede())) ) {
						alt65=1;
					}

				}

				switch (alt65) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:67: {...}? =>x2= simpleBlock
					{
					if ( !((!Separator_SpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "simpleText", "!Separator_SpacesPrecede()");
					}
					pushFollow(FOLLOW_simpleBlock_in_simpleText2824);
					x2=simpleBlock();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_simpleBlock.add(x2.getTree());
					if ( state.backtracking==0 ) {text += (x2!=null?((MatlabParser.simpleBlock_return)x2).blockText:null);}
					}
					break;

				default :
					break loop65;
				}
			}

			if ( state.backtracking==0 ) {text = Text_QuoteString(text);}
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 281:174: -> STRING[$x1.start, text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STRING, (x1!=null?(x1.start):null), text));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simpleText"


	public static class simpleBlock_return extends ParserRuleReturnScope {
		public String blockText = null;
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simpleBlock"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:283:1: simpleBlock returns [String blockText = null] : (x1= STRING |x2=~ ( COMMA | SEMICOLON | EOL | STRING | CTRANS | TRANS | QUOTATION | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY ) );
	public final MatlabParser.simpleBlock_return simpleBlock() throws RecognitionException {
		MatlabParser.simpleBlock_return retval = new MatlabParser.simpleBlock_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token x1=null;
		Token x2=null;

		Object x1_tree=null;
		Object x2_tree=null;

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:283:47: (x1= STRING |x2=~ ( COMMA | SEMICOLON | EOL | STRING | CTRANS | TRANS | QUOTATION | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY ) )
			int alt66=2;
			int LA66_0 = input.LA(1);
			if ( (LA66_0==STRING) ) {
				alt66=1;
			}
			else if ( ((LA66_0 >= AND && LA66_0 <= COLON)||(LA66_0 >= COMMAND && LA66_0 <= CONTINUE)||(LA66_0 >= DEFAULTBLOCK && LA66_0 <= END)||(LA66_0 >= EQ && LA66_0 <= IMG)||(LA66_0 >= LDIV && LA66_0 <= LINECOMMENT3)||(LA66_0 >= LT && LA66_0 <= QUESTION)||(LA66_0 >= RDIV && LA66_0 <= RETURN)||(LA66_0 >= SHORTAND && LA66_0 <= START)||(LA66_0 >= STRINGBLOCK && LA66_0 <= TIMES)||(LA66_0 >= TRY && LA66_0 <= VCAT)) ) {
				alt66=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 66, 0, input);
				throw nvae;
			}

			switch (alt66) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:284:3: x1= STRING
					{
					root_0 = (Object)adaptor.nil();


					x1=(Token)match(input,STRING,FOLLOW_STRING_in_simpleBlock2852); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					x1_tree = (Object)adaptor.create(x1);
					adaptor.addChild(root_0, x1_tree);
					}

					if ( state.backtracking==0 ) {retval.blockText = Text_UnquoteString((x1!=null?x1.getText():null));}
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:285:3: x2=~ ( COMMA | SEMICOLON | EOL | STRING | CTRANS | TRANS | QUOTATION | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY )
					{
					root_0 = (Object)adaptor.nil();


					x2=input.LT(1);
					if ( (input.LA(1) >= AND && input.LA(1) <= COLON)||(input.LA(1) >= COMMAND && input.LA(1) <= CONTINUE)||(input.LA(1) >= DEFAULTBLOCK && input.LA(1) <= END)||(input.LA(1) >= EQ && input.LA(1) <= IMG)||(input.LA(1) >= LDIV && input.LA(1) <= LINECOMMENT3)||(input.LA(1) >= LT && input.LA(1) <= QUESTION)||(input.LA(1) >= RDIV && input.LA(1) <= RETURN)||(input.LA(1) >= SHORTAND && input.LA(1) <= START)||(input.LA(1) >= STRINGBLOCK && input.LA(1) <= TIMES)||(input.LA(1) >= TRY && input.LA(1) <= VCAT) ) {
						input.consume();
						if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(x2));
						state.errorRecovery=false;
						state.failed=false;
					}
					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						throw mse;
					}
					if ( state.backtracking==0 ) {retval.blockText = (x2!=null?x2.getText():null);}
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simpleBlock"


	public static class abortCommand_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "abortCommand"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:290:1: abortCommand :{...}? => var -> ABORT ;
	public final MatlabParser.abortCommand_return abortCommand() throws RecognitionException {
		MatlabParser.abortCommand_return retval = new MatlabParser.abortCommand_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope var219 =null;

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:290:14: ({...}? => var -> ABORT )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:290:16: {...}? => var
			{
			if ( !((Command_IsEnabled())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "abortCommand", "Command_IsEnabled()");
			}
			if ( state.backtracking==0 ) {Command_Mark();}
			pushFollow(FOLLOW_var_in_abortCommand2930);
			var219=var();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_var.add(var219.getTree());
			if ( state.backtracking==0 ) {Command_Abort();}
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 290:82: -> ABORT
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ABORT, "ABORT"));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "abortCommand"


	public static class standardCommand_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standardCommand"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:1: standardCommand : COMMAND standardTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS ) ;
	public final MatlabParser.standardCommand_return standardCommand() throws RecognitionException {
		MatlabParser.standardCommand_return retval = new MatlabParser.standardCommand_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMAND220=null;
		ParserRuleReturnScope standardTexts221 =null;
		ParserRuleReturnScope xEOS222 =null;

		Object COMMAND220_tree=null;
		RewriteRuleTokenStream stream_COMMAND=new RewriteRuleTokenStream(adaptor,"token COMMAND");
		RewriteRuleSubtreeStream stream_standardTexts=new RewriteRuleSubtreeStream(adaptor,"rule standardTexts");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:17: ( COMMAND standardTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:19: COMMAND standardTexts xEOS
			{
			COMMAND220=(Token)match(input,COMMAND,FOLLOW_COMMAND_in_standardCommand2947); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMAND.add(COMMAND220);

			pushFollow(FOLLOW_standardTexts_in_standardCommand2949);
			standardTexts221=standardTexts();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_standardTexts.add(standardTexts221.getTree());
			pushFollow(FOLLOW_xEOS_in_standardCommand2951);
			xEOS222=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS222.getTree());
			// AST REWRITE
			// elements: standardTexts, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 294:46: -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:49: ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ACTION, ""), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:62: ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(PARENTHESIS, ""), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:80: ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) )
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_3);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:90: ^( NAME[\"\"] ID[$COMMAND] )
				{
				Object root_4 = (Object)adaptor.nil();
				root_4 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_4);
				adaptor.addChild(root_4, (Object)adaptor.create(ID, COMMAND220));
				adaptor.addChild(root_3, root_4);
				}

				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_2, stream_standardTexts.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standardCommand"


	public static class standardTexts_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standardTexts"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:1: standardTexts : standardText ({...}? => standardText )* -> ( standardText )+ ;
	public final MatlabParser.standardTexts_return standardTexts() throws RecognitionException {
		MatlabParser.standardTexts_return retval = new MatlabParser.standardTexts_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope standardText223 =null;
		ParserRuleReturnScope standardText224 =null;

		RewriteRuleSubtreeStream stream_standardText=new RewriteRuleSubtreeStream(adaptor,"rule standardText");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:15: ( standardText ({...}? => standardText )* -> ( standardText )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:17: standardText ({...}? => standardText )*
			{
			pushFollow(FOLLOW_standardText_in_standardTexts2989);
			standardText223=standardText();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_standardText.add(standardText223.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:30: ({...}? => standardText )*
			loop67:
			while (true) {
				int alt67=2;
				int LA67_0 = input.LA(1);
				if ( (LA67_0==DEFAULTBLOCK||LA67_0==STRINGBLOCK) && ((Separator_SpacesPrecede()))) {
					alt67=1;
				}

				switch (alt67) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:31: {...}? => standardText
					{
					if ( !((Separator_SpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "standardTexts", "Separator_SpacesPrecede()");
					}
					pushFollow(FOLLOW_standardText_in_standardTexts2995);
					standardText224=standardText();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_standardText.add(standardText224.getTree());
					}
					break;

				default :
					break loop67;
				}
			}

			// AST REWRITE
			// elements: standardText
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 296:77: -> ( standardText )+
			{
				if ( !(stream_standardText.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_standardText.hasNext() ) {
					adaptor.addChild(root_0, stream_standardText.nextTree());
				}
				stream_standardText.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standardTexts"


	public static class standardText_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standardText"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:298:1: standardText : (x1= standardBlock ) ( options {greedy=true; } :{...}? =>x2= standardBlock )* -> STRING[$x1.start, text] ;
	public final MatlabParser.standardText_return standardText() throws RecognitionException {
		MatlabParser.standardText_return retval = new MatlabParser.standardText_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_standardBlock=new RewriteRuleSubtreeStream(adaptor,"rule standardBlock");

		String text = null;
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:299:29: ( (x1= standardBlock ) ( options {greedy=true; } :{...}? =>x2= standardBlock )* -> STRING[$x1.start, text] )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:2: (x1= standardBlock ) ( options {greedy=true; } :{...}? =>x2= standardBlock )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:2: (x1= standardBlock )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:2: x1= standardBlock
			{
			pushFollow(FOLLOW_standardBlock_in_standardText3021);
			x1=standardBlock();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_standardBlock.add(x1.getTree());
			if ( state.backtracking==0 ) {text = (x1!=null?((MatlabParser.standardBlock_return)x1).blockText:null);}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:44: ( options {greedy=true; } :{...}? =>x2= standardBlock )*
			loop68:
			while (true) {
				int alt68=2;
				int LA68_0 = input.LA(1);
				if ( (LA68_0==STRINGBLOCK) ) {
					int LA68_1 = input.LA(2);
					if ( ((!Separator_SpacesPrecede())) ) {
						alt68=1;
					}

				}
				else if ( (LA68_0==DEFAULTBLOCK) ) {
					int LA68_2 = input.LA(2);
					if ( ((!Separator_SpacesPrecede())) ) {
						alt68=1;
					}

				}

				switch (alt68) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:69: {...}? =>x2= standardBlock
					{
					if ( !((!Separator_SpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "standardText", "!Separator_SpacesPrecede()");
					}
					pushFollow(FOLLOW_standardBlock_in_standardText3040);
					x2=standardBlock();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_standardBlock.add(x2.getTree());
					if ( state.backtracking==0 ) {text += (x2!=null?((MatlabParser.standardBlock_return)x2).blockText:null);}
					}
					break;

				default :
					break loop68;
				}
			}

			if ( state.backtracking==0 ) {text = Text_QuoteString(text);}
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 300:178: -> STRING[$x1.start, text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STRING, (x1!=null?(x1.start):null), text));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standardText"


	public static class standardBlock_return extends ParserRuleReturnScope {
		public String blockText = null;
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standardBlock"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:302:1: standardBlock returns [String blockText = null] : (x1= STRINGBLOCK |x2= DEFAULTBLOCK );
	public final MatlabParser.standardBlock_return standardBlock() throws RecognitionException {
		MatlabParser.standardBlock_return retval = new MatlabParser.standardBlock_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token x1=null;
		Token x2=null;

		Object x1_tree=null;
		Object x2_tree=null;

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:302:49: (x1= STRINGBLOCK |x2= DEFAULTBLOCK )
			int alt69=2;
			int LA69_0 = input.LA(1);
			if ( (LA69_0==STRINGBLOCK) ) {
				alt69=1;
			}
			else if ( (LA69_0==DEFAULTBLOCK) ) {
				alt69=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 69, 0, input);
				throw nvae;
			}

			switch (alt69) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:303:4: x1= STRINGBLOCK
					{
					root_0 = (Object)adaptor.nil();


					x1=(Token)match(input,STRINGBLOCK,FOLLOW_STRINGBLOCK_in_standardBlock3069); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					x1_tree = (Object)adaptor.create(x1);
					adaptor.addChild(root_0, x1_tree);
					}

					if ( state.backtracking==0 ) {retval.blockText = Text_UnquoteString((x1!=null?x1.getText():null));}
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:304:4: x2= DEFAULTBLOCK
					{
					root_0 = (Object)adaptor.nil();


					x2=(Token)match(input,DEFAULTBLOCK,FOLLOW_DEFAULTBLOCK_in_standardBlock3078); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					x2_tree = (Object)adaptor.create(x2);
					adaptor.addChild(root_0, x2_tree);
					}

					if ( state.backtracking==0 ) {retval.blockText = (x2!=null?x2.getText():null);}
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standardBlock"


	public static class bang_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "bang"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:309:1: bang : EXCLAMATION LINE xEOL -> ^( EXCLAMATION STRING[$LINE, line] xEOL ) ;
	public final MatlabParser.bang_return bang() throws RecognitionException {
		MatlabParser.bang_return retval = new MatlabParser.bang_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EXCLAMATION225=null;
		Token LINE226=null;
		ParserRuleReturnScope xEOL227 =null;

		Object EXCLAMATION225_tree=null;
		Object LINE226_tree=null;
		RewriteRuleTokenStream stream_EXCLAMATION=new RewriteRuleTokenStream(adaptor,"token EXCLAMATION");
		RewriteRuleTokenStream stream_LINE=new RewriteRuleTokenStream(adaptor,"token LINE");
		RewriteRuleSubtreeStream stream_xEOL=new RewriteRuleSubtreeStream(adaptor,"rule xEOL");

		String line = null;
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:310:29: ( EXCLAMATION LINE xEOL -> ^( EXCLAMATION STRING[$LINE, line] xEOL ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:311:1: EXCLAMATION LINE xEOL
			{
			EXCLAMATION225=(Token)match(input,EXCLAMATION,FOLLOW_EXCLAMATION_in_bang3097); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EXCLAMATION.add(EXCLAMATION225);

			LINE226=(Token)match(input,LINE,FOLLOW_LINE_in_bang3099); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LINE.add(LINE226);

			if ( state.backtracking==0 ) {line = Text_QuoteString((LINE226!=null?LINE226.getText():null));}
			pushFollow(FOLLOW_xEOL_in_bang3103);
			xEOL227=xEOL();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOL.add(xEOL227.getTree());
			// AST REWRITE
			// elements: xEOL, EXCLAMATION
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 311:62: -> ^( EXCLAMATION STRING[$LINE, line] xEOL )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:311:65: ^( EXCLAMATION STRING[$LINE, line] xEOL )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_EXCLAMATION.nextNode(), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(STRING, LINE226, line));
				adaptor.addChild(root_1, stream_xEOL.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "bang"


	public static class breakDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "breakDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:315:1: breakDef : BREAK xEOS -> ^( BREAK xEOS ) ;
	public final MatlabParser.breakDef_return breakDef() throws RecognitionException {
		MatlabParser.breakDef_return retval = new MatlabParser.breakDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token BREAK228=null;
		ParserRuleReturnScope xEOS229 =null;

		Object BREAK228_tree=null;
		RewriteRuleTokenStream stream_BREAK=new RewriteRuleTokenStream(adaptor,"token BREAK");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:315:10: ( BREAK xEOS -> ^( BREAK xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:315:12: BREAK xEOS
			{
			BREAK228=(Token)match(input,BREAK,FOLLOW_BREAK_in_breakDef3125); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_BREAK.add(BREAK228);

			pushFollow(FOLLOW_xEOS_in_breakDef3127);
			xEOS229=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS229.getTree());
			// AST REWRITE
			// elements: BREAK, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 315:23: -> ^( BREAK xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:315:26: ^( BREAK xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_BREAK.nextNode(), root_1);
				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "breakDef"


	public static class continueDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "continueDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:319:1: continueDef : CONTINUE xEOS -> ^( CONTINUE xEOS ) ;
	public final MatlabParser.continueDef_return continueDef() throws RecognitionException {
		MatlabParser.continueDef_return retval = new MatlabParser.continueDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CONTINUE230=null;
		ParserRuleReturnScope xEOS231 =null;

		Object CONTINUE230_tree=null;
		RewriteRuleTokenStream stream_CONTINUE=new RewriteRuleTokenStream(adaptor,"token CONTINUE");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:319:13: ( CONTINUE xEOS -> ^( CONTINUE xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:319:15: CONTINUE xEOS
			{
			CONTINUE230=(Token)match(input,CONTINUE,FOLLOW_CONTINUE_in_continueDef3146); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CONTINUE.add(CONTINUE230);

			pushFollow(FOLLOW_xEOS_in_continueDef3148);
			xEOS231=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS231.getTree());
			// AST REWRITE
			// elements: xEOS, CONTINUE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 319:29: -> ^( CONTINUE xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:319:32: ^( CONTINUE xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_CONTINUE.nextNode(), root_1);
				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "continueDef"


	public static class forDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "forDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:1: forDef : FOR forHead statements END xEOS -> ^( FOR forHead ( statements )? xEOS ) ;
	public final MatlabParser.forDef_return forDef() throws RecognitionException {
		MatlabParser.forDef_return retval = new MatlabParser.forDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FOR232=null;
		Token END235=null;
		ParserRuleReturnScope forHead233 =null;
		ParserRuleReturnScope statements234 =null;
		ParserRuleReturnScope xEOS236 =null;

		Object FOR232_tree=null;
		Object END235_tree=null;
		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,"token FOR");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_forHead=new RewriteRuleSubtreeStream(adaptor,"rule forHead");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:8: ( FOR forHead statements END xEOS -> ^( FOR forHead ( statements )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:10: FOR forHead statements END xEOS
			{
			FOR232=(Token)match(input,FOR,FOLLOW_FOR_in_forDef3167); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FOR.add(FOR232);

			pushFollow(FOLLOW_forHead_in_forDef3169);
			forHead233=forHead();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_forHead.add(forHead233.getTree());
			pushFollow(FOLLOW_statements_in_forDef3171);
			statements234=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements234.getTree());
			END235=(Token)match(input,END,FOLLOW_END_in_forDef3173); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END235);

			pushFollow(FOLLOW_xEOS_in_forDef3175);
			xEOS236=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS236.getTree());
			// AST REWRITE
			// elements: xEOS, forHead, statements, FOR
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 323:42: -> ^( FOR forHead ( statements )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:45: ^( FOR forHead ( statements )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_FOR.nextNode(), root_1);
				adaptor.addChild(root_1, stream_forHead.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:59: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "forDef"


	public static class forHead_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "forHead"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:325:1: forHead : ( var ASSIGN expression -> var expression | LPAREN var ASSIGN expression RPAREN -> var expression );
	public final MatlabParser.forHead_return forHead() throws RecognitionException {
		MatlabParser.forHead_return retval = new MatlabParser.forHead_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASSIGN238=null;
		Token LPAREN240=null;
		Token ASSIGN242=null;
		Token RPAREN244=null;
		ParserRuleReturnScope var237 =null;
		ParserRuleReturnScope expression239 =null;
		ParserRuleReturnScope var241 =null;
		ParserRuleReturnScope expression243 =null;

		Object ASSIGN238_tree=null;
		Object LPAREN240_tree=null;
		Object ASSIGN242_tree=null;
		Object RPAREN244_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:325:9: ( var ASSIGN expression -> var expression | LPAREN var ASSIGN expression RPAREN -> var expression )
			int alt70=2;
			int LA70_0 = input.LA(1);
			if ( (LA70_0==ID) ) {
				alt70=1;
			}
			else if ( (LA70_0==LPAREN) ) {
				alt70=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 70, 0, input);
				throw nvae;
			}

			switch (alt70) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:325:11: var ASSIGN expression
					{
					pushFollow(FOLLOW_var_in_forHead3199);
					var237=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var237.getTree());
					ASSIGN238=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_forHead3201); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN238);

					pushFollow(FOLLOW_expression_in_forHead3203);
					expression239=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression239.getTree());
					// AST REWRITE
					// elements: var, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 325:33: -> var expression
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:326:5: LPAREN var ASSIGN expression RPAREN
					{
					LPAREN240=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_forHead3215); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN240);

					pushFollow(FOLLOW_var_in_forHead3217);
					var241=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var241.getTree());
					ASSIGN242=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_forHead3219); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN242);

					pushFollow(FOLLOW_expression_in_forHead3221);
					expression243=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression243.getTree());
					RPAREN244=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_forHead3223); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN244);

					// AST REWRITE
					// elements: var, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 326:41: -> var expression
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "forHead"


	public static class global_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "global"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:1: global : GLOBAL ( var )+ xEOS -> ^( GLOBAL ( var )+ xEOS ) ;
	public final MatlabParser.global_return global() throws RecognitionException {
		MatlabParser.global_return retval = new MatlabParser.global_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token GLOBAL245=null;
		ParserRuleReturnScope var246 =null;
		ParserRuleReturnScope xEOS247 =null;

		Object GLOBAL245_tree=null;
		RewriteRuleTokenStream stream_GLOBAL=new RewriteRuleTokenStream(adaptor,"token GLOBAL");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:8: ( GLOBAL ( var )+ xEOS -> ^( GLOBAL ( var )+ xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:10: GLOBAL ( var )+ xEOS
			{
			GLOBAL245=(Token)match(input,GLOBAL,FOLLOW_GLOBAL_in_global3242); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_GLOBAL.add(GLOBAL245);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:17: ( var )+
			int cnt71=0;
			loop71:
			while (true) {
				int alt71=2;
				int LA71_0 = input.LA(1);
				if ( (LA71_0==ID) ) {
					alt71=1;
				}

				switch (alt71) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:18: var
					{
					pushFollow(FOLLOW_var_in_global3245);
					var246=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var246.getTree());
					}
					break;

				default :
					if ( cnt71 >= 1 ) break loop71;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(71, input);
					throw eee;
				}
				cnt71++;
			}

			pushFollow(FOLLOW_xEOS_in_global3249);
			xEOS247=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS247.getTree());
			// AST REWRITE
			// elements: var, xEOS, GLOBAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 331:29: -> ^( GLOBAL ( var )+ xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:32: ^( GLOBAL ( var )+ xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_GLOBAL.nextNode(), root_1);
				if ( !(stream_var.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_var.hasNext() ) {
					adaptor.addChild(root_1, stream_var.nextTree());
				}
				stream_var.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "global"


	public static class ifDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ifDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:1: ifDef : ifPart ( elseIfPart )* ( elsePart )? END xEOS -> ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS ) ;
	public final MatlabParser.ifDef_return ifDef() throws RecognitionException {
		MatlabParser.ifDef_return retval = new MatlabParser.ifDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END251=null;
		ParserRuleReturnScope ifPart248 =null;
		ParserRuleReturnScope elseIfPart249 =null;
		ParserRuleReturnScope elsePart250 =null;
		ParserRuleReturnScope xEOS252 =null;

		Object END251_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_ifPart=new RewriteRuleSubtreeStream(adaptor,"rule ifPart");
		RewriteRuleSubtreeStream stream_elseIfPart=new RewriteRuleSubtreeStream(adaptor,"rule elseIfPart");
		RewriteRuleSubtreeStream stream_elsePart=new RewriteRuleSubtreeStream(adaptor,"rule elsePart");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:7: ( ifPart ( elseIfPart )* ( elsePart )? END xEOS -> ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:9: ifPart ( elseIfPart )* ( elsePart )? END xEOS
			{
			pushFollow(FOLLOW_ifPart_in_ifDef3273);
			ifPart248=ifPart();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_ifPart.add(ifPart248.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:16: ( elseIfPart )*
			loop72:
			while (true) {
				int alt72=2;
				int LA72_0 = input.LA(1);
				if ( (LA72_0==ELSEIF) ) {
					alt72=1;
				}

				switch (alt72) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:17: elseIfPart
					{
					pushFollow(FOLLOW_elseIfPart_in_ifDef3276);
					elseIfPart249=elseIfPart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_elseIfPart.add(elseIfPart249.getTree());
					}
					break;

				default :
					break loop72;
				}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:30: ( elsePart )?
			int alt73=2;
			int LA73_0 = input.LA(1);
			if ( (LA73_0==ELSE) ) {
				alt73=1;
			}
			switch (alt73) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:31: elsePart
					{
					pushFollow(FOLLOW_elsePart_in_ifDef3281);
					elsePart250=elsePart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_elsePart.add(elsePart250.getTree());
					}
					break;

			}

			END251=(Token)match(input,END,FOLLOW_END_in_ifDef3285); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END251);

			pushFollow(FOLLOW_xEOS_in_ifDef3287);
			xEOS252=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS252.getTree());
			// AST REWRITE
			// elements: elseIfPart, elsePart, xEOS, ifPart
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 335:51: -> ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:54: ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IFELSE, (ifPart248!=null?(ifPart248.start):null)), root_1);
				adaptor.addChild(root_1, stream_ifPart.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:85: ( elseIfPart )*
				while ( stream_elseIfPart.hasNext() ) {
					adaptor.addChild(root_1, stream_elseIfPart.nextTree());
				}
				stream_elseIfPart.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:99: ( elsePart )?
				if ( stream_elsePart.hasNext() ) {
					adaptor.addChild(root_1, stream_elsePart.nextTree());
				}
				stream_elsePart.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ifDef"


	public static class ifPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ifPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:1: ifPart : IF expression statements -> ^( IF expression ( statements )? ) ;
	public final MatlabParser.ifPart_return ifPart() throws RecognitionException {
		MatlabParser.ifPart_return retval = new MatlabParser.ifPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token IF253=null;
		ParserRuleReturnScope expression254 =null;
		ParserRuleReturnScope statements255 =null;

		Object IF253_tree=null;
		RewriteRuleTokenStream stream_IF=new RewriteRuleTokenStream(adaptor,"token IF");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:8: ( IF expression statements -> ^( IF expression ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:10: IF expression statements
			{
			IF253=(Token)match(input,IF,FOLLOW_IF_in_ifPart3317); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_IF.add(IF253);

			pushFollow(FOLLOW_expression_in_ifPart3319);
			expression254=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression254.getTree());
			pushFollow(FOLLOW_statements_in_ifPart3321);
			statements255=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements255.getTree());
			// AST REWRITE
			// elements: statements, expression, IF
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 337:35: -> ^( IF expression ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:38: ^( IF expression ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_IF.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:54: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ifPart"


	public static class elseIfPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "elseIfPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:1: elseIfPart : ELSEIF expression statements -> ^( ELSEIF expression ( statements )? ) ;
	public final MatlabParser.elseIfPart_return elseIfPart() throws RecognitionException {
		MatlabParser.elseIfPart_return retval = new MatlabParser.elseIfPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ELSEIF256=null;
		ParserRuleReturnScope expression257 =null;
		ParserRuleReturnScope statements258 =null;

		Object ELSEIF256_tree=null;
		RewriteRuleTokenStream stream_ELSEIF=new RewriteRuleTokenStream(adaptor,"token ELSEIF");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:12: ( ELSEIF expression statements -> ^( ELSEIF expression ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:14: ELSEIF expression statements
			{
			ELSEIF256=(Token)match(input,ELSEIF,FOLLOW_ELSEIF_in_elseIfPart3343); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ELSEIF.add(ELSEIF256);

			pushFollow(FOLLOW_expression_in_elseIfPart3345);
			expression257=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression257.getTree());
			pushFollow(FOLLOW_statements_in_elseIfPart3347);
			statements258=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements258.getTree());
			// AST REWRITE
			// elements: expression, ELSEIF, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 339:43: -> ^( ELSEIF expression ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:46: ^( ELSEIF expression ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_ELSEIF.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:66: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "elseIfPart"


	public static class elsePart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "elsePart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:1: elsePart : ELSE statements -> ^( ELSE ( statements )? ) ;
	public final MatlabParser.elsePart_return elsePart() throws RecognitionException {
		MatlabParser.elsePart_return retval = new MatlabParser.elsePart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ELSE259=null;
		ParserRuleReturnScope statements260 =null;

		Object ELSE259_tree=null;
		RewriteRuleTokenStream stream_ELSE=new RewriteRuleTokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:10: ( ELSE statements -> ^( ELSE ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:12: ELSE statements
			{
			ELSE259=(Token)match(input,ELSE,FOLLOW_ELSE_in_elsePart3369); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ELSE.add(ELSE259);

			pushFollow(FOLLOW_statements_in_elsePart3371);
			statements260=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements260.getTree());
			// AST REWRITE
			// elements: statements, ELSE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 341:28: -> ^( ELSE ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:31: ^( ELSE ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_ELSE.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:38: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "elsePart"


	public static class parfor_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parfor"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:1: parfor : PARFOR parforHead statements END xEOS -> ^( PARFOR parforHead ( statements )? xEOS ) ;
	public final MatlabParser.parfor_return parfor() throws RecognitionException {
		MatlabParser.parfor_return retval = new MatlabParser.parfor_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PARFOR261=null;
		Token END264=null;
		ParserRuleReturnScope parforHead262 =null;
		ParserRuleReturnScope statements263 =null;
		ParserRuleReturnScope xEOS265 =null;

		Object PARFOR261_tree=null;
		Object END264_tree=null;
		RewriteRuleTokenStream stream_PARFOR=new RewriteRuleTokenStream(adaptor,"token PARFOR");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_parforHead=new RewriteRuleSubtreeStream(adaptor,"rule parforHead");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:8: ( PARFOR parforHead statements END xEOS -> ^( PARFOR parforHead ( statements )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:10: PARFOR parforHead statements END xEOS
			{
			PARFOR261=(Token)match(input,PARFOR,FOLLOW_PARFOR_in_parfor3393); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PARFOR.add(PARFOR261);

			pushFollow(FOLLOW_parforHead_in_parfor3395);
			parforHead262=parforHead();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parforHead.add(parforHead262.getTree());
			pushFollow(FOLLOW_statements_in_parfor3397);
			statements263=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements263.getTree());
			END264=(Token)match(input,END,FOLLOW_END_in_parfor3399); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END264);

			pushFollow(FOLLOW_xEOS_in_parfor3401);
			xEOS265=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS265.getTree());
			// AST REWRITE
			// elements: xEOS, parforHead, PARFOR, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 345:48: -> ^( PARFOR parforHead ( statements )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:51: ^( PARFOR parforHead ( statements )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_PARFOR.nextNode(), root_1);
				adaptor.addChild(root_1, stream_parforHead.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:71: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parfor"


	public static class parforHead_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parforHead"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:1: parforHead : ( ( LPAREN var ASSIGN expression COMMA )=> LPAREN var ASSIGN expression COMMA expression RPAREN -> var ( expression )+ | LPAREN var ASSIGN expression RPAREN -> var expression | var ASSIGN expression -> var expression );
	public final MatlabParser.parforHead_return parforHead() throws RecognitionException {
		MatlabParser.parforHead_return retval = new MatlabParser.parforHead_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN266=null;
		Token ASSIGN268=null;
		Token COMMA270=null;
		Token RPAREN272=null;
		Token LPAREN273=null;
		Token ASSIGN275=null;
		Token RPAREN277=null;
		Token ASSIGN279=null;
		ParserRuleReturnScope var267 =null;
		ParserRuleReturnScope expression269 =null;
		ParserRuleReturnScope expression271 =null;
		ParserRuleReturnScope var274 =null;
		ParserRuleReturnScope expression276 =null;
		ParserRuleReturnScope var278 =null;
		ParserRuleReturnScope expression280 =null;

		Object LPAREN266_tree=null;
		Object ASSIGN268_tree=null;
		Object COMMA270_tree=null;
		Object RPAREN272_tree=null;
		Object LPAREN273_tree=null;
		Object ASSIGN275_tree=null;
		Object RPAREN277_tree=null;
		Object ASSIGN279_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:12: ( ( LPAREN var ASSIGN expression COMMA )=> LPAREN var ASSIGN expression COMMA expression RPAREN -> var ( expression )+ | LPAREN var ASSIGN expression RPAREN -> var expression | var ASSIGN expression -> var expression )
			int alt74=3;
			int LA74_0 = input.LA(1);
			if ( (LA74_0==LPAREN) ) {
				int LA74_1 = input.LA(2);
				if ( (synpred6_MatlabParser()) ) {
					alt74=1;
				}
				else if ( (true) ) {
					alt74=2;
				}

			}
			else if ( (LA74_0==ID) ) {
				alt74=3;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 74, 0, input);
				throw nvae;
			}

			switch (alt74) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:14: ( LPAREN var ASSIGN expression COMMA )=> LPAREN var ASSIGN expression COMMA expression RPAREN
					{
					LPAREN266=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parforHead3438); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN266);

					pushFollow(FOLLOW_var_in_parforHead3440);
					var267=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var267.getTree());
					ASSIGN268=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_parforHead3442); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN268);

					pushFollow(FOLLOW_expression_in_parforHead3444);
					expression269=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression269.getTree());
					COMMA270=(Token)match(input,COMMA,FOLLOW_COMMA_in_parforHead3446); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA270);

					pushFollow(FOLLOW_expression_in_parforHead3448);
					expression271=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression271.getTree());
					RPAREN272=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parforHead3450); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN272);

					// AST REWRITE
					// elements: var, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 347:106: -> var ( expression )+
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						if ( !(stream_expression.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_expression.hasNext() ) {
							adaptor.addChild(root_0, stream_expression.nextTree());
						}
						stream_expression.reset();

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:348:8: LPAREN var ASSIGN expression RPAREN
					{
					LPAREN273=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parforHead3468); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN273);

					pushFollow(FOLLOW_var_in_parforHead3470);
					var274=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var274.getTree());
					ASSIGN275=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_parforHead3472); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN275);

					pushFollow(FOLLOW_expression_in_parforHead3474);
					expression276=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression276.getTree());
					RPAREN277=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parforHead3476); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN277);

					// AST REWRITE
					// elements: expression, var
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 348:44: -> var expression
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:349:8: var ASSIGN expression
					{
					pushFollow(FOLLOW_var_in_parforHead3491);
					var278=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var278.getTree());
					ASSIGN279=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_parforHead3493); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN279);

					pushFollow(FOLLOW_expression_in_parforHead3495);
					expression280=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression280.getTree());
					// AST REWRITE
					// elements: var, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 349:30: -> var expression
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parforHead"


	public static class persistent_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "persistent"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:1: persistent : PERSISTENT ( var )+ xEOS -> ^( PERSISTENT ( var )+ xEOS ) ;
	public final MatlabParser.persistent_return persistent() throws RecognitionException {
		MatlabParser.persistent_return retval = new MatlabParser.persistent_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PERSISTENT281=null;
		ParserRuleReturnScope var282 =null;
		ParserRuleReturnScope xEOS283 =null;

		Object PERSISTENT281_tree=null;
		RewriteRuleTokenStream stream_PERSISTENT=new RewriteRuleTokenStream(adaptor,"token PERSISTENT");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:12: ( PERSISTENT ( var )+ xEOS -> ^( PERSISTENT ( var )+ xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:14: PERSISTENT ( var )+ xEOS
			{
			PERSISTENT281=(Token)match(input,PERSISTENT,FOLLOW_PERSISTENT_in_persistent3517); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PERSISTENT.add(PERSISTENT281);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:25: ( var )+
			int cnt75=0;
			loop75:
			while (true) {
				int alt75=2;
				int LA75_0 = input.LA(1);
				if ( (LA75_0==ID) ) {
					alt75=1;
				}

				switch (alt75) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:26: var
					{
					pushFollow(FOLLOW_var_in_persistent3520);
					var282=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var282.getTree());
					}
					break;

				default :
					if ( cnt75 >= 1 ) break loop75;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(75, input);
					throw eee;
				}
				cnt75++;
			}

			pushFollow(FOLLOW_xEOS_in_persistent3524);
			xEOS283=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS283.getTree());
			// AST REWRITE
			// elements: var, xEOS, PERSISTENT
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 354:37: -> ^( PERSISTENT ( var )+ xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:40: ^( PERSISTENT ( var )+ xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_PERSISTENT.nextNode(), root_1);
				if ( !(stream_var.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_var.hasNext() ) {
					adaptor.addChild(root_1, stream_var.nextTree());
				}
				stream_var.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "persistent"


	public static class returnDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "returnDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:358:1: returnDef : RETURN xEOS -> ^( RETURN xEOS ) ;
	public final MatlabParser.returnDef_return returnDef() throws RecognitionException {
		MatlabParser.returnDef_return retval = new MatlabParser.returnDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token RETURN284=null;
		ParserRuleReturnScope xEOS285 =null;

		Object RETURN284_tree=null;
		RewriteRuleTokenStream stream_RETURN=new RewriteRuleTokenStream(adaptor,"token RETURN");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:358:11: ( RETURN xEOS -> ^( RETURN xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:358:13: RETURN xEOS
			{
			RETURN284=(Token)match(input,RETURN,FOLLOW_RETURN_in_returnDef3548); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RETURN.add(RETURN284);

			pushFollow(FOLLOW_xEOS_in_returnDef3550);
			xEOS285=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS285.getTree());
			// AST REWRITE
			// elements: xEOS, RETURN
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 358:25: -> ^( RETURN xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:358:28: ^( RETURN xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_RETURN.nextNode(), root_1);
				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "returnDef"


	public static class spmd_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "spmd"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:1: spmd : SPMD ( options {greedy=true; } : spmdHead )? statements END xEOS -> ^( SPMD ( spmdHead )? ( statements )? xEOS ) ;
	public final MatlabParser.spmd_return spmd() throws RecognitionException {
		MatlabParser.spmd_return retval = new MatlabParser.spmd_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SPMD286=null;
		Token END289=null;
		ParserRuleReturnScope spmdHead287 =null;
		ParserRuleReturnScope statements288 =null;
		ParserRuleReturnScope xEOS290 =null;

		Object SPMD286_tree=null;
		Object END289_tree=null;
		RewriteRuleTokenStream stream_SPMD=new RewriteRuleTokenStream(adaptor,"token SPMD");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_spmdHead=new RewriteRuleSubtreeStream(adaptor,"rule spmdHead");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:6: ( SPMD ( options {greedy=true; } : spmdHead )? statements END xEOS -> ^( SPMD ( spmdHead )? ( statements )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:8: SPMD ( options {greedy=true; } : spmdHead )? statements END xEOS
			{
			SPMD286=(Token)match(input,SPMD,FOLLOW_SPMD_in_spmd3569); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SPMD.add(SPMD286);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:13: ( options {greedy=true; } : spmdHead )?
			int alt76=2;
			int LA76_0 = input.LA(1);
			if ( (LA76_0==LPAREN) ) {
				int LA76_1 = input.LA(2);
				if ( (!(((True())))) ) {
					alt76=1;
				}
			}
			switch (alt76) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:38: spmdHead
					{
					pushFollow(FOLLOW_spmdHead_in_spmd3580);
					spmdHead287=spmdHead();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_spmdHead.add(spmdHead287.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_statements_in_spmd3584);
			statements288=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements288.getTree());
			END289=(Token)match(input,END,FOLLOW_END_in_spmd3586); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END289);

			pushFollow(FOLLOW_xEOS_in_spmd3588);
			xEOS290=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS290.getTree());
			// AST REWRITE
			// elements: statements, xEOS, SPMD, spmdHead
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 362:69: -> ^( SPMD ( spmdHead )? ( statements )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:72: ^( SPMD ( spmdHead )? ( statements )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_SPMD.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:79: ( spmdHead )?
				if ( stream_spmdHead.hasNext() ) {
					adaptor.addChild(root_1, stream_spmdHead.nextTree());
				}
				stream_spmdHead.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:91: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "spmd"


	public static class spmdHead_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "spmdHead"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:1: spmdHead : LPAREN expression ( COMMA expression )? RPAREN -> ( expression )+ ;
	public final MatlabParser.spmdHead_return spmdHead() throws RecognitionException {
		MatlabParser.spmdHead_return retval = new MatlabParser.spmdHead_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN291=null;
		Token COMMA293=null;
		Token RPAREN295=null;
		ParserRuleReturnScope expression292 =null;
		ParserRuleReturnScope expression294 =null;

		Object LPAREN291_tree=null;
		Object COMMA293_tree=null;
		Object RPAREN295_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:10: ( LPAREN expression ( COMMA expression )? RPAREN -> ( expression )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:12: LPAREN expression ( COMMA expression )? RPAREN
			{
			LPAREN291=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_spmdHead3615); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN291);

			pushFollow(FOLLOW_expression_in_spmdHead3617);
			expression292=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression292.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:30: ( COMMA expression )?
			int alt77=2;
			int LA77_0 = input.LA(1);
			if ( (LA77_0==COMMA) ) {
				alt77=1;
			}
			switch (alt77) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:31: COMMA expression
					{
					COMMA293=(Token)match(input,COMMA,FOLLOW_COMMA_in_spmdHead3620); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA293);

					pushFollow(FOLLOW_expression_in_spmdHead3622);
					expression294=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression294.getTree());
					}
					break;

			}

			RPAREN295=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_spmdHead3626); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN295);

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 364:57: -> ( expression )+
			{
				if ( !(stream_expression.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.hasNext() ) {
					adaptor.addChild(root_0, stream_expression.nextTree());
				}
				stream_expression.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "spmdHead"


	public static class switchDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "switchDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:1: switchDef : switchPart ( casePart )* ( otherwisePart )? END xEOS -> ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS ) ;
	public final MatlabParser.switchDef_return switchDef() throws RecognitionException {
		MatlabParser.switchDef_return retval = new MatlabParser.switchDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END299=null;
		ParserRuleReturnScope switchPart296 =null;
		ParserRuleReturnScope casePart297 =null;
		ParserRuleReturnScope otherwisePart298 =null;
		ParserRuleReturnScope xEOS300 =null;

		Object END299_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_casePart=new RewriteRuleSubtreeStream(adaptor,"rule casePart");
		RewriteRuleSubtreeStream stream_otherwisePart=new RewriteRuleSubtreeStream(adaptor,"rule otherwisePart");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_switchPart=new RewriteRuleSubtreeStream(adaptor,"rule switchPart");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:11: ( switchPart ( casePart )* ( otherwisePart )? END xEOS -> ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:13: switchPart ( casePart )* ( otherwisePart )? END xEOS
			{
			pushFollow(FOLLOW_switchPart_in_switchDef3644);
			switchPart296=switchPart();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_switchPart.add(switchPart296.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:24: ( casePart )*
			loop78:
			while (true) {
				int alt78=2;
				int LA78_0 = input.LA(1);
				if ( (LA78_0==CASE) ) {
					alt78=1;
				}

				switch (alt78) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:25: casePart
					{
					pushFollow(FOLLOW_casePart_in_switchDef3647);
					casePart297=casePart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_casePart.add(casePart297.getTree());
					}
					break;

				default :
					break loop78;
				}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:36: ( otherwisePart )?
			int alt79=2;
			int LA79_0 = input.LA(1);
			if ( (LA79_0==OTHERWISE) ) {
				alt79=1;
			}
			switch (alt79) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:37: otherwisePart
					{
					pushFollow(FOLLOW_otherwisePart_in_switchDef3652);
					otherwisePart298=otherwisePart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_otherwisePart.add(otherwisePart298.getTree());
					}
					break;

			}

			END299=(Token)match(input,END,FOLLOW_END_in_switchDef3656); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END299);

			pushFollow(FOLLOW_xEOS_in_switchDef3658);
			xEOS300=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS300.getTree());
			// AST REWRITE
			// elements: casePart, xEOS, otherwisePart, switchPart
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 368:62: -> ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:65: ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SWITCHCASE, (switchPart296!=null?(switchPart296.start):null)), root_1);
				adaptor.addChild(root_1, stream_switchPart.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:108: ( casePart )*
				while ( stream_casePart.hasNext() ) {
					adaptor.addChild(root_1, stream_casePart.nextTree());
				}
				stream_casePart.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:120: ( otherwisePart )?
				if ( stream_otherwisePart.hasNext() ) {
					adaptor.addChild(root_1, stream_otherwisePart.nextTree());
				}
				stream_otherwisePart.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "switchDef"


	public static class switchPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "switchPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:1: switchPart : SWITCH expression ( xEOS )* -> ^( SWITCH expression ) ;
	public final MatlabParser.switchPart_return switchPart() throws RecognitionException {
		MatlabParser.switchPart_return retval = new MatlabParser.switchPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SWITCH301=null;
		ParserRuleReturnScope expression302 =null;
		ParserRuleReturnScope xEOS303 =null;

		Object SWITCH301_tree=null;
		RewriteRuleTokenStream stream_SWITCH=new RewriteRuleTokenStream(adaptor,"token SWITCH");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:12: ( SWITCH expression ( xEOS )* -> ^( SWITCH expression ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:14: SWITCH expression ( xEOS )*
			{
			SWITCH301=(Token)match(input,SWITCH,FOLLOW_SWITCH_in_switchPart3688); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SWITCH.add(SWITCH301);

			pushFollow(FOLLOW_expression_in_switchPart3690);
			expression302=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression302.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:32: ( xEOS )*
			loop80:
			while (true) {
				int alt80=2;
				int LA80_0 = input.LA(1);
				if ( (LA80_0==COMMA||LA80_0==EOL||LA80_0==SEMICOLON) ) {
					alt80=1;
				}

				switch (alt80) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:33: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_switchPart3693);
					xEOS303=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS303.getTree());
					}
					break;

				default :
					break loop80;
				}
			}

			// AST REWRITE
			// elements: expression, SWITCH
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 370:40: -> ^( SWITCH expression )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:43: ^( SWITCH expression )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_SWITCH.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "switchPart"


	public static class casePart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "casePart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:1: casePart : CASE expression xEOS statements -> ^( CASE expression ( statements )? ) ;
	public final MatlabParser.casePart_return casePart() throws RecognitionException {
		MatlabParser.casePart_return retval = new MatlabParser.casePart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CASE304=null;
		ParserRuleReturnScope expression305 =null;
		ParserRuleReturnScope xEOS306 =null;
		ParserRuleReturnScope statements307 =null;

		Object CASE304_tree=null;
		RewriteRuleTokenStream stream_CASE=new RewriteRuleTokenStream(adaptor,"token CASE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:10: ( CASE expression xEOS statements -> ^( CASE expression ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:12: CASE expression xEOS statements
			{
			CASE304=(Token)match(input,CASE,FOLLOW_CASE_in_casePart3712); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CASE.add(CASE304);

			pushFollow(FOLLOW_expression_in_casePart3714);
			expression305=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression305.getTree());
			pushFollow(FOLLOW_xEOS_in_casePart3716);
			xEOS306=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS306.getTree());
			pushFollow(FOLLOW_statements_in_casePart3718);
			statements307=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements307.getTree());
			// AST REWRITE
			// elements: statements, CASE, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 372:44: -> ^( CASE expression ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:47: ^( CASE expression ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_CASE.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:65: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "casePart"


	public static class otherwisePart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "otherwisePart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:1: otherwisePart : OTHERWISE statements -> ^( OTHERWISE ( statements )? ) ;
	public final MatlabParser.otherwisePart_return otherwisePart() throws RecognitionException {
		MatlabParser.otherwisePart_return retval = new MatlabParser.otherwisePart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token OTHERWISE308=null;
		ParserRuleReturnScope statements309 =null;

		Object OTHERWISE308_tree=null;
		RewriteRuleTokenStream stream_OTHERWISE=new RewriteRuleTokenStream(adaptor,"token OTHERWISE");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:15: ( OTHERWISE statements -> ^( OTHERWISE ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:17: OTHERWISE statements
			{
			OTHERWISE308=(Token)match(input,OTHERWISE,FOLLOW_OTHERWISE_in_otherwisePart3740); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_OTHERWISE.add(OTHERWISE308);

			pushFollow(FOLLOW_statements_in_otherwisePart3742);
			statements309=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements309.getTree());
			// AST REWRITE
			// elements: OTHERWISE, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 374:38: -> ^( OTHERWISE ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:41: ^( OTHERWISE ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_OTHERWISE.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:53: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "otherwisePart"


	public static class tryDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "tryDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:1: tryDef : tryPart ( catchPart )? END xEOS -> ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS ) ;
	public final MatlabParser.tryDef_return tryDef() throws RecognitionException {
		MatlabParser.tryDef_return retval = new MatlabParser.tryDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END312=null;
		ParserRuleReturnScope tryPart310 =null;
		ParserRuleReturnScope catchPart311 =null;
		ParserRuleReturnScope xEOS313 =null;

		Object END312_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_tryPart=new RewriteRuleSubtreeStream(adaptor,"rule tryPart");
		RewriteRuleSubtreeStream stream_catchPart=new RewriteRuleSubtreeStream(adaptor,"rule catchPart");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:8: ( tryPart ( catchPart )? END xEOS -> ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:10: tryPart ( catchPart )? END xEOS
			{
			pushFollow(FOLLOW_tryPart_in_tryDef3764);
			tryPart310=tryPart();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_tryPart.add(tryPart310.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:18: ( catchPart )?
			int alt81=2;
			int LA81_0 = input.LA(1);
			if ( (LA81_0==CATCH) ) {
				alt81=1;
			}
			switch (alt81) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:19: catchPart
					{
					pushFollow(FOLLOW_catchPart_in_tryDef3767);
					catchPart311=catchPart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_catchPart.add(catchPart311.getTree());
					}
					break;

			}

			END312=(Token)match(input,END,FOLLOW_END_in_tryDef3771); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END312);

			pushFollow(FOLLOW_xEOS_in_tryDef3773);
			xEOS313=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS313.getTree());
			// AST REWRITE
			// elements: tryPart, catchPart, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 378:40: -> ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:43: ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TRYCATCH, (tryPart310!=null?(tryPart310.start):null)), root_1);
				adaptor.addChild(root_1, stream_tryPart.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:78: ( catchPart )?
				if ( stream_catchPart.hasNext() ) {
					adaptor.addChild(root_1, stream_catchPart.nextTree());
				}
				stream_catchPart.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "tryDef"


	public static class tryPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "tryPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:1: tryPart : TRY statements -> ^( TRY ( statements )? ) ;
	public final MatlabParser.tryPart_return tryPart() throws RecognitionException {
		MatlabParser.tryPart_return retval = new MatlabParser.tryPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TRY314=null;
		ParserRuleReturnScope statements315 =null;

		Object TRY314_tree=null;
		RewriteRuleTokenStream stream_TRY=new RewriteRuleTokenStream(adaptor,"token TRY");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:9: ( TRY statements -> ^( TRY ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:11: TRY statements
			{
			TRY314=(Token)match(input,TRY,FOLLOW_TRY_in_tryPart3798); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TRY.add(TRY314);

			pushFollow(FOLLOW_statements_in_tryPart3800);
			statements315=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements315.getTree());
			// AST REWRITE
			// elements: statements, TRY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 380:26: -> ^( TRY ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:29: ^( TRY ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_TRY.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:35: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "tryPart"


	public static class catchPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "catchPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:1: catchPart : CATCH ( options {greedy=true; } :{...}? => capturePortion )? statements -> ^( CATCH ( capturePortion )? ( statements )? ) ;
	public final MatlabParser.catchPart_return catchPart() throws RecognitionException {
		MatlabParser.catchPart_return retval = new MatlabParser.catchPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CATCH316=null;
		ParserRuleReturnScope capturePortion317 =null;
		ParserRuleReturnScope statements318 =null;

		Object CATCH316_tree=null;
		RewriteRuleTokenStream stream_CATCH=new RewriteRuleTokenStream(adaptor,"token CATCH");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_capturePortion=new RewriteRuleSubtreeStream(adaptor,"rule capturePortion");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:11: ( CATCH ( options {greedy=true; } :{...}? => capturePortion )? statements -> ^( CATCH ( capturePortion )? ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:13: CATCH ( options {greedy=true; } :{...}? => capturePortion )? statements
			{
			CATCH316=(Token)match(input,CATCH,FOLLOW_CATCH_in_catchPart3820); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CATCH.add(CATCH316);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:19: ( options {greedy=true; } :{...}? => capturePortion )?
			int alt82=2;
			int LA82_0 = input.LA(1);
			if ( (LA82_0==ID) && (((Command_IsEnabled())||(True())))) {
				int LA82_1 = input.LA(2);
				if ( (LA82_1==SEMICOLON) && (((Command_IsEnabled())||(True())))) {
					int LA82_6 = input.LA(3);
					if ( ((True())) ) {
						alt82=1;
					}
				}
				else if ( (LA82_1==COMMA) && (((Command_IsEnabled())||(True())))) {
					int LA82_7 = input.LA(3);
					if ( ((True())) ) {
						alt82=1;
					}
				}
				else if ( (LA82_1==EOL) && (((Command_IsEnabled())||(True())))) {
					int LA82_8 = input.LA(3);
					if ( ((True())) ) {
						alt82=1;
					}
				}
			}
			switch (alt82) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:44: {...}? => capturePortion
					{
					if ( !((True())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "catchPart", "True()");
					}
					pushFollow(FOLLOW_capturePortion_in_catchPart3834);
					capturePortion317=capturePortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_capturePortion.add(capturePortion317.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_statements_in_catchPart3838);
			statements318=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements318.getTree());
			// AST REWRITE
			// elements: statements, capturePortion, CATCH
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 382:84: -> ^( CATCH ( capturePortion )? ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:87: ^( CATCH ( capturePortion )? ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_CATCH.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:95: ( capturePortion )?
				if ( stream_capturePortion.hasNext() ) {
					adaptor.addChild(root_1, stream_capturePortion.nextTree());
				}
				stream_capturePortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:113: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catchPart"


	public static class capturePortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "capturePortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:384:1: capturePortion : var xEOS -> var ;
	public final MatlabParser.capturePortion_return capturePortion() throws RecognitionException {
		MatlabParser.capturePortion_return retval = new MatlabParser.capturePortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope var319 =null;
		ParserRuleReturnScope xEOS320 =null;

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:384:16: ( var xEOS -> var )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:384:18: var xEOS
			{
			pushFollow(FOLLOW_var_in_capturePortion3863);
			var319=var();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_var.add(var319.getTree());
			pushFollow(FOLLOW_xEOS_in_capturePortion3865);
			xEOS320=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS320.getTree());
			// AST REWRITE
			// elements: var
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 384:27: -> var
			{
				adaptor.addChild(root_0, stream_var.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "capturePortion"


	public static class whileDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "whileDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:1: whileDef : WHILE expression statements END xEOS -> ^( WHILE expression ( statements )? xEOS ) ;
	public final MatlabParser.whileDef_return whileDef() throws RecognitionException {
		MatlabParser.whileDef_return retval = new MatlabParser.whileDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token WHILE321=null;
		Token END324=null;
		ParserRuleReturnScope expression322 =null;
		ParserRuleReturnScope statements323 =null;
		ParserRuleReturnScope xEOS325 =null;

		Object WHILE321_tree=null;
		Object END324_tree=null;
		RewriteRuleTokenStream stream_WHILE=new RewriteRuleTokenStream(adaptor,"token WHILE");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:10: ( WHILE expression statements END xEOS -> ^( WHILE expression ( statements )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:12: WHILE expression statements END xEOS
			{
			WHILE321=(Token)match(input,WHILE,FOLLOW_WHILE_in_whileDef3880); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_WHILE.add(WHILE321);

			pushFollow(FOLLOW_expression_in_whileDef3882);
			expression322=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression322.getTree());
			pushFollow(FOLLOW_statements_in_whileDef3884);
			statements323=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements323.getTree());
			END324=(Token)match(input,END,FOLLOW_END_in_whileDef3886); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END324);

			pushFollow(FOLLOW_xEOS_in_whileDef3888);
			xEOS325=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS325.getTree());
			// AST REWRITE
			// elements: expression, xEOS, WHILE, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 388:49: -> ^( WHILE expression ( statements )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:52: ^( WHILE expression ( statements )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_WHILE.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:71: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "whileDef"


	public static class expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:392:1: expression : expression11 -> expression11 ;
	public final MatlabParser.expression_return expression() throws RecognitionException {
		MatlabParser.expression_return retval = new MatlabParser.expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression11326 =null;

		RewriteRuleSubtreeStream stream_expression11=new RewriteRuleSubtreeStream(adaptor,"rule expression11");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:392:12: ( expression11 -> expression11 )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:392:14: expression11
			{
			pushFollow(FOLLOW_expression11_in_expression3914);
			expression11326=expression11();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression11.add(expression11326.getTree());
			// AST REWRITE
			// elements: expression11
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 392:27: -> expression11
			{
				adaptor.addChild(root_0, stream_expression11.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression"


	public static class expression11_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression11"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:1: expression11 : (x1= expression10 -> $x1) ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )* ;
	public final MatlabParser.expression11_return expression11() throws RecognitionException {
		MatlabParser.expression11_return retval = new MatlabParser.expression11_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SHORTOR327=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object SHORTOR327_tree=null;
		RewriteRuleTokenStream stream_SHORTOR=new RewriteRuleTokenStream(adaptor,"token SHORTOR");
		RewriteRuleSubtreeStream stream_expression10=new RewriteRuleSubtreeStream(adaptor,"rule expression10");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:14: ( (x1= expression10 -> $x1) ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:16: (x1= expression10 -> $x1) ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:16: (x1= expression10 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:17: x1= expression10
			{
			pushFollow(FOLLOW_expression10_in_expression113930);
			x1=expression10();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression10.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 394:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:41: ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )*
			loop83:
			while (true) {
				int alt83=2;
				int LA83_0 = input.LA(1);
				if ( (LA83_0==SHORTOR) ) {
					alt83=1;
				}

				switch (alt83) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:66: SHORTOR x2= expression10
					{
					SHORTOR327=(Token)match(input,SHORTOR,FOLLOW_SHORTOR_in_expression113947); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SHORTOR.add(SHORTOR327);

					pushFollow(FOLLOW_expression10_in_expression113951);
					x2=expression10();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression10.add(x2.getTree());
					// AST REWRITE
					// elements: x2, expression11, SHORTOR
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 394:90: -> ^( SHORTOR $expression11 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:93: ^( SHORTOR $expression11 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_SHORTOR.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop83;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression11"


	public static class expression10_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression10"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:1: expression10 : (x1= expression09 -> $x1) ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )* ;
	public final MatlabParser.expression10_return expression10() throws RecognitionException {
		MatlabParser.expression10_return retval = new MatlabParser.expression10_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SHORTAND328=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object SHORTAND328_tree=null;
		RewriteRuleTokenStream stream_SHORTAND=new RewriteRuleTokenStream(adaptor,"token SHORTAND");
		RewriteRuleSubtreeStream stream_expression09=new RewriteRuleSubtreeStream(adaptor,"rule expression09");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:14: ( (x1= expression09 -> $x1) ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:16: (x1= expression09 -> $x1) ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:16: (x1= expression09 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:17: x1= expression09
			{
			pushFollow(FOLLOW_expression09_in_expression103977);
			x1=expression09();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression09.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 396:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:41: ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )*
			loop84:
			while (true) {
				int alt84=2;
				int LA84_0 = input.LA(1);
				if ( (LA84_0==SHORTAND) ) {
					alt84=1;
				}

				switch (alt84) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:66: SHORTAND x2= expression09
					{
					SHORTAND328=(Token)match(input,SHORTAND,FOLLOW_SHORTAND_in_expression103994); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SHORTAND.add(SHORTAND328);

					pushFollow(FOLLOW_expression09_in_expression103998);
					x2=expression09();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression09.add(x2.getTree());
					// AST REWRITE
					// elements: x2, SHORTAND, expression10
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 396:91: -> ^( SHORTAND $expression10 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:94: ^( SHORTAND $expression10 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_SHORTAND.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop84;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression10"


	public static class expression09_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression09"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:1: expression09 : (x1= expression08 -> $x1) ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )* ;
	public final MatlabParser.expression09_return expression09() throws RecognitionException {
		MatlabParser.expression09_return retval = new MatlabParser.expression09_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token OR329=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object OR329_tree=null;
		RewriteRuleTokenStream stream_OR=new RewriteRuleTokenStream(adaptor,"token OR");
		RewriteRuleSubtreeStream stream_expression08=new RewriteRuleSubtreeStream(adaptor,"rule expression08");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:14: ( (x1= expression08 -> $x1) ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:16: (x1= expression08 -> $x1) ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:16: (x1= expression08 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:17: x1= expression08
			{
			pushFollow(FOLLOW_expression08_in_expression094024);
			x1=expression08();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression08.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 398:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:41: ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )*
			loop85:
			while (true) {
				int alt85=2;
				int LA85_0 = input.LA(1);
				if ( (LA85_0==OR) ) {
					alt85=1;
				}

				switch (alt85) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:66: OR x2= expression08
					{
					OR329=(Token)match(input,OR,FOLLOW_OR_in_expression094041); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OR.add(OR329);

					pushFollow(FOLLOW_expression08_in_expression094045);
					x2=expression08();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression08.add(x2.getTree());
					// AST REWRITE
					// elements: x2, OR, expression09
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 398:85: -> ^( OR $expression09 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:88: ^( OR $expression09 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_OR.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop85;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression09"


	public static class expression08_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression08"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:1: expression08 : (x1= expression07 -> $x1) ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )* ;
	public final MatlabParser.expression08_return expression08() throws RecognitionException {
		MatlabParser.expression08_return retval = new MatlabParser.expression08_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AND330=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object AND330_tree=null;
		RewriteRuleTokenStream stream_AND=new RewriteRuleTokenStream(adaptor,"token AND");
		RewriteRuleSubtreeStream stream_expression07=new RewriteRuleSubtreeStream(adaptor,"rule expression07");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:14: ( (x1= expression07 -> $x1) ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:16: (x1= expression07 -> $x1) ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:16: (x1= expression07 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:17: x1= expression07
			{
			pushFollow(FOLLOW_expression07_in_expression084071);
			x1=expression07();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression07.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 400:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:41: ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )*
			loop86:
			while (true) {
				int alt86=2;
				int LA86_0 = input.LA(1);
				if ( (LA86_0==AND) ) {
					alt86=1;
				}

				switch (alt86) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:66: AND x2= expression07
					{
					AND330=(Token)match(input,AND,FOLLOW_AND_in_expression084088); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AND.add(AND330);

					pushFollow(FOLLOW_expression07_in_expression084092);
					x2=expression07();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression07.add(x2.getTree());
					// AST REWRITE
					// elements: x2, AND, expression08
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 400:86: -> ^( AND $expression08 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:89: ^( AND $expression08 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_AND.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop86;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression08"


	public static class expression07_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression07"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:1: expression07 : (x1= expression06 -> $x1) ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )* ;
	public final MatlabParser.expression07_return expression07() throws RecognitionException {
		MatlabParser.expression07_return retval = new MatlabParser.expression07_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator06=new RewriteRuleSubtreeStream(adaptor,"rule operator06");
		RewriteRuleSubtreeStream stream_expression06=new RewriteRuleSubtreeStream(adaptor,"rule expression06");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:14: ( (x1= expression06 -> $x1) ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:16: (x1= expression06 -> $x1) ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:16: (x1= expression06 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:17: x1= expression06
			{
			pushFollow(FOLLOW_expression06_in_expression074118);
			x1=expression06();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression06.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 402:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:41: ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )*
			loop87:
			while (true) {
				int alt87=2;
				switch ( input.LA(1) ) {
				case LT:
					{
					alt87=1;
					}
					break;
				case LTEQ:
					{
					alt87=1;
					}
					break;
				case GT:
					{
					alt87=1;
					}
					break;
				case GTEQ:
					{
					alt87=1;
					}
					break;
				case EQ:
					{
					alt87=1;
					}
					break;
				case NOTEQ:
					{
					alt87=1;
					}
					break;
				}
				switch (alt87) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:66: op= operator06 x2= expression06
					{
					pushFollow(FOLLOW_operator06_in_expression074137);
					op=operator06();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator06.add(op.getTree());
					pushFollow(FOLLOW_expression06_in_expression074141);
					x2=expression06();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression06.add(x2.getTree());
					// AST REWRITE
					// elements: expression07, op, x2
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 402:96: -> ^( $op $expression07 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:99: ^( $op $expression07 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop87;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression07"


	public static class operator06_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator06"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:404:1: operator06 : ( LT -> LT | LTEQ -> LTEQ | GT -> GT | GTEQ -> GTEQ | EQ -> EQ | NOTEQ -> NOTEQ );
	public final MatlabParser.operator06_return operator06() throws RecognitionException {
		MatlabParser.operator06_return retval = new MatlabParser.operator06_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LT331=null;
		Token LTEQ332=null;
		Token GT333=null;
		Token GTEQ334=null;
		Token EQ335=null;
		Token NOTEQ336=null;

		Object LT331_tree=null;
		Object LTEQ332_tree=null;
		Object GT333_tree=null;
		Object GTEQ334_tree=null;
		Object EQ335_tree=null;
		Object NOTEQ336_tree=null;
		RewriteRuleTokenStream stream_LTEQ=new RewriteRuleTokenStream(adaptor,"token LTEQ");
		RewriteRuleTokenStream stream_LT=new RewriteRuleTokenStream(adaptor,"token LT");
		RewriteRuleTokenStream stream_GTEQ=new RewriteRuleTokenStream(adaptor,"token GTEQ");
		RewriteRuleTokenStream stream_EQ=new RewriteRuleTokenStream(adaptor,"token EQ");
		RewriteRuleTokenStream stream_GT=new RewriteRuleTokenStream(adaptor,"token GT");
		RewriteRuleTokenStream stream_NOTEQ=new RewriteRuleTokenStream(adaptor,"token NOTEQ");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:404:12: ( LT -> LT | LTEQ -> LTEQ | GT -> GT | GTEQ -> GTEQ | EQ -> EQ | NOTEQ -> NOTEQ )
			int alt88=6;
			switch ( input.LA(1) ) {
			case LT:
				{
				alt88=1;
				}
				break;
			case LTEQ:
				{
				alt88=2;
				}
				break;
			case GT:
				{
				alt88=3;
				}
				break;
			case GTEQ:
				{
				alt88=4;
				}
				break;
			case EQ:
				{
				alt88=5;
				}
				break;
			case NOTEQ:
				{
				alt88=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 88, 0, input);
				throw nvae;
			}
			switch (alt88) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:404:14: LT
					{
					LT331=(Token)match(input,LT,FOLLOW_LT_in_operator064165); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LT.add(LT331);

					// AST REWRITE
					// elements: LT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 404:17: -> LT
					{
						adaptor.addChild(root_0, stream_LT.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:405:8: LTEQ
					{
					LTEQ332=(Token)match(input,LTEQ,FOLLOW_LTEQ_in_operator064178); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LTEQ.add(LTEQ332);

					// AST REWRITE
					// elements: LTEQ
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 405:13: -> LTEQ
					{
						adaptor.addChild(root_0, stream_LTEQ.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:406:8: GT
					{
					GT333=(Token)match(input,GT,FOLLOW_GT_in_operator064191); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_GT.add(GT333);

					// AST REWRITE
					// elements: GT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 406:11: -> GT
					{
						adaptor.addChild(root_0, stream_GT.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:407:8: GTEQ
					{
					GTEQ334=(Token)match(input,GTEQ,FOLLOW_GTEQ_in_operator064204); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_GTEQ.add(GTEQ334);

					// AST REWRITE
					// elements: GTEQ
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 407:13: -> GTEQ
					{
						adaptor.addChild(root_0, stream_GTEQ.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:408:8: EQ
					{
					EQ335=(Token)match(input,EQ,FOLLOW_EQ_in_operator064217); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EQ.add(EQ335);

					// AST REWRITE
					// elements: EQ
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 408:11: -> EQ
					{
						adaptor.addChild(root_0, stream_EQ.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:409:8: NOTEQ
					{
					NOTEQ336=(Token)match(input,NOTEQ,FOLLOW_NOTEQ_in_operator064230); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOTEQ.add(NOTEQ336);

					// AST REWRITE
					// elements: NOTEQ
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 409:14: -> NOTEQ
					{
						adaptor.addChild(root_0, stream_NOTEQ.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator06"


	public static class expression06_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression06"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:1: expression06 : (x1= expression05 -> $x1) ( options {greedy=true; } : ( ( COLON expression05 COLON expression05 )=> COLON x2= expression05 COLON x3= expression05 -> ^( COLON $expression06 $x2 $x3) ) | ( ( COLON expression05 )=> COLON x4= expression05 -> ^( COLON $expression06 $x4) ) )* ;
	public final MatlabParser.expression06_return expression06() throws RecognitionException {
		MatlabParser.expression06_return retval = new MatlabParser.expression06_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COLON337=null;
		Token COLON338=null;
		Token COLON339=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;
		ParserRuleReturnScope x3 =null;
		ParserRuleReturnScope x4 =null;

		Object COLON337_tree=null;
		Object COLON338_tree=null;
		Object COLON339_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expression05=new RewriteRuleSubtreeStream(adaptor,"rule expression05");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:14: ( (x1= expression05 -> $x1) ( options {greedy=true; } : ( ( COLON expression05 COLON expression05 )=> COLON x2= expression05 COLON x3= expression05 -> ^( COLON $expression06 $x2 $x3) ) | ( ( COLON expression05 )=> COLON x4= expression05 -> ^( COLON $expression06 $x4) ) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:16: (x1= expression05 -> $x1) ( options {greedy=true; } : ( ( COLON expression05 COLON expression05 )=> COLON x2= expression05 COLON x3= expression05 -> ^( COLON $expression06 $x2 $x3) ) | ( ( COLON expression05 )=> COLON x4= expression05 -> ^( COLON $expression06 $x4) ) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:16: (x1= expression05 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:17: x1= expression05
			{
			pushFollow(FOLLOW_expression05_in_expression064251);
			x1=expression05();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression05.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 412:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:41: ( options {greedy=true; } : ( ( COLON expression05 COLON expression05 )=> COLON x2= expression05 COLON x3= expression05 -> ^( COLON $expression06 $x2 $x3) ) | ( ( COLON expression05 )=> COLON x4= expression05 -> ^( COLON $expression06 $x4) ) )*
			loop89:
			while (true) {
				int alt89=3;
				int LA89_0 = input.LA(1);
				if ( (LA89_0==COLON) ) {
					int LA89_6 = input.LA(2);
					if ( (synpred7_MatlabParser()) ) {
						alt89=1;
					}
					else if ( (synpred8_MatlabParser()) ) {
						alt89=2;
					}

				}

				switch (alt89) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:66: ( ( COLON expression05 COLON expression05 )=> COLON x2= expression05 COLON x3= expression05 -> ^( COLON $expression06 $x2 $x3) )
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:66: ( ( COLON expression05 COLON expression05 )=> COLON x2= expression05 COLON x3= expression05 -> ^( COLON $expression06 $x2 $x3) )
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:67: ( COLON expression05 COLON expression05 )=> COLON x2= expression05 COLON x3= expression05
					{
					COLON337=(Token)match(input,COLON,FOLLOW_COLON_in_expression064280); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON337);

					pushFollow(FOLLOW_expression05_in_expression064284);
					x2=expression05();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression05.add(x2.getTree());
					COLON338=(Token)match(input,COLON,FOLLOW_COLON_in_expression064286); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON338);

					pushFollow(FOLLOW_expression05_in_expression064290);
					x3=expression05();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression05.add(x3.getTree());
					// AST REWRITE
					// elements: x3, x2, COLON, expression06
					// token labels: 
					// rule labels: x2, x3, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_x3=new RewriteRuleSubtreeStream(adaptor,"rule x3",x3!=null?x3.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 412:153: -> ^( COLON $expression06 $x2 $x3)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:156: ^( COLON $expression06 $x2 $x3)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_COLON.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_1, stream_x3.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:190: ( ( COLON expression05 )=> COLON x4= expression05 -> ^( COLON $expression06 $x4) )
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:190: ( ( COLON expression05 )=> COLON x4= expression05 -> ^( COLON $expression06 $x4) )
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:191: ( COLON expression05 )=> COLON x4= expression05
					{
					COLON339=(Token)match(input,COLON,FOLLOW_COLON_in_expression064318); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON339);

					pushFollow(FOLLOW_expression05_in_expression064322);
					x4=expression05();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression05.add(x4.getTree());
					// AST REWRITE
					// elements: COLON, expression06, x4
					// token labels: 
					// rule labels: x4, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x4=new RewriteRuleSubtreeStream(adaptor,"rule x4",x4!=null?x4.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 412:236: -> ^( COLON $expression06 $x4)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:239: ^( COLON $expression06 $x4)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_COLON.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x4.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}

					}
					break;

				default :
					break loop89;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression06"


	public static class expression05_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression05"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:1: expression05 : (x1= expression04 -> $x1) ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )* ;
	public final MatlabParser.expression05_return expression05() throws RecognitionException {
		MatlabParser.expression05_return retval = new MatlabParser.expression05_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator04=new RewriteRuleSubtreeStream(adaptor,"rule operator04");
		RewriteRuleSubtreeStream stream_expression04=new RewriteRuleSubtreeStream(adaptor,"rule expression04");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:14: ( (x1= expression04 -> $x1) ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:16: (x1= expression04 -> $x1) ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:16: (x1= expression04 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:17: x1= expression04
			{
			pushFollow(FOLLOW_expression04_in_expression054349);
			x1=expression04();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression04.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 414:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:41: ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )*
			loop90:
			while (true) {
				int alt90=2;
				int LA90_0 = input.LA(1);
				if ( (LA90_0==PLUS) && (((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {
					int LA90_3 = input.LA(2);
					if ( ((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())) ) {
						alt90=1;
					}

				}
				else if ( (LA90_0==MINUS) && (((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {
					int LA90_4 = input.LA(2);
					if ( ((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())) ) {
						alt90=1;
					}

				}

				switch (alt90) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:66: {...}? =>op= operator04 x2= expression04
					{
					if ( !((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "expression05", "!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight()");
					}
					pushFollow(FOLLOW_operator04_in_expression054371);
					op=operator04();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator04.add(op.getTree());
					pushFollow(FOLLOW_expression04_in_expression054375);
					x2=expression04();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression04.add(x2.getTree());
					// AST REWRITE
					// elements: x2, op, expression05
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 414:156: -> ^( $op $expression05 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:159: ^( $op $expression05 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop90;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression05"


	public static class operator04_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator04"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:416:1: operator04 : ( PLUS -> PLUS | MINUS -> MINUS );
	public final MatlabParser.operator04_return operator04() throws RecognitionException {
		MatlabParser.operator04_return retval = new MatlabParser.operator04_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLUS340=null;
		Token MINUS341=null;

		Object PLUS340_tree=null;
		Object MINUS341_tree=null;
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:416:12: ( PLUS -> PLUS | MINUS -> MINUS )
			int alt91=2;
			int LA91_0 = input.LA(1);
			if ( (LA91_0==PLUS) ) {
				alt91=1;
			}
			else if ( (LA91_0==MINUS) ) {
				alt91=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 91, 0, input);
				throw nvae;
			}

			switch (alt91) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:416:14: PLUS
					{
					PLUS340=(Token)match(input,PLUS,FOLLOW_PLUS_in_operator044399); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PLUS.add(PLUS340);

					// AST REWRITE
					// elements: PLUS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 416:19: -> PLUS
					{
						adaptor.addChild(root_0, stream_PLUS.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:417:8: MINUS
					{
					MINUS341=(Token)match(input,MINUS,FOLLOW_MINUS_in_operator044412); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(MINUS341);

					// AST REWRITE
					// elements: MINUS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 417:14: -> MINUS
					{
						adaptor.addChild(root_0, stream_MINUS.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator04"


	public static class expression04_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression04"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:1: expression04 : (x1= expression03 -> $x1) ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )* ;
	public final MatlabParser.expression04_return expression04() throws RecognitionException {
		MatlabParser.expression04_return retval = new MatlabParser.expression04_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator03=new RewriteRuleSubtreeStream(adaptor,"rule operator03");
		RewriteRuleSubtreeStream stream_expression03=new RewriteRuleSubtreeStream(adaptor,"rule expression03");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:14: ( (x1= expression03 -> $x1) ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:16: (x1= expression03 -> $x1) ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:16: (x1= expression03 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:17: x1= expression03
			{
			pushFollow(FOLLOW_expression03_in_expression044433);
			x1=expression03();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression03.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 420:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:41: ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )*
			loop92:
			while (true) {
				int alt92=2;
				switch ( input.LA(1) ) {
				case TIMES:
					{
					alt92=1;
					}
					break;
				case RDIV:
					{
					alt92=1;
					}
					break;
				case LDIV:
					{
					alt92=1;
					}
					break;
				case MTIMES:
					{
					alt92=1;
					}
					break;
				case MRDIV:
					{
					alt92=1;
					}
					break;
				case MLDIV:
					{
					alt92=1;
					}
					break;
				}
				switch (alt92) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:66: op= operator03 x2= expression03
					{
					pushFollow(FOLLOW_operator03_in_expression044452);
					op=operator03();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator03.add(op.getTree());
					pushFollow(FOLLOW_expression03_in_expression044456);
					x2=expression03();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression03.add(x2.getTree());
					// AST REWRITE
					// elements: op, expression04, x2
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 420:96: -> ^( $op $expression04 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:99: ^( $op $expression04 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop92;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression04"


	public static class operator03_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator03"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:422:1: operator03 : ( TIMES -> TIMES | RDIV -> RDIV | LDIV -> LDIV | MTIMES -> MTIMES | MRDIV -> MRDIV | MLDIV -> MLDIV );
	public final MatlabParser.operator03_return operator03() throws RecognitionException {
		MatlabParser.operator03_return retval = new MatlabParser.operator03_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TIMES342=null;
		Token RDIV343=null;
		Token LDIV344=null;
		Token MTIMES345=null;
		Token MRDIV346=null;
		Token MLDIV347=null;

		Object TIMES342_tree=null;
		Object RDIV343_tree=null;
		Object LDIV344_tree=null;
		Object MTIMES345_tree=null;
		Object MRDIV346_tree=null;
		Object MLDIV347_tree=null;
		RewriteRuleTokenStream stream_MLDIV=new RewriteRuleTokenStream(adaptor,"token MLDIV");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LDIV=new RewriteRuleTokenStream(adaptor,"token LDIV");
		RewriteRuleTokenStream stream_RDIV=new RewriteRuleTokenStream(adaptor,"token RDIV");
		RewriteRuleTokenStream stream_MTIMES=new RewriteRuleTokenStream(adaptor,"token MTIMES");
		RewriteRuleTokenStream stream_MRDIV=new RewriteRuleTokenStream(adaptor,"token MRDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:422:12: ( TIMES -> TIMES | RDIV -> RDIV | LDIV -> LDIV | MTIMES -> MTIMES | MRDIV -> MRDIV | MLDIV -> MLDIV )
			int alt93=6;
			switch ( input.LA(1) ) {
			case TIMES:
				{
				alt93=1;
				}
				break;
			case RDIV:
				{
				alt93=2;
				}
				break;
			case LDIV:
				{
				alt93=3;
				}
				break;
			case MTIMES:
				{
				alt93=4;
				}
				break;
			case MRDIV:
				{
				alt93=5;
				}
				break;
			case MLDIV:
				{
				alt93=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 93, 0, input);
				throw nvae;
			}
			switch (alt93) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:422:14: TIMES
					{
					TIMES342=(Token)match(input,TIMES,FOLLOW_TIMES_in_operator034480); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_TIMES.add(TIMES342);

					// AST REWRITE
					// elements: TIMES
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 422:20: -> TIMES
					{
						adaptor.addChild(root_0, stream_TIMES.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:423:8: RDIV
					{
					RDIV343=(Token)match(input,RDIV,FOLLOW_RDIV_in_operator034493); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RDIV.add(RDIV343);

					// AST REWRITE
					// elements: RDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 423:13: -> RDIV
					{
						adaptor.addChild(root_0, stream_RDIV.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:424:8: LDIV
					{
					LDIV344=(Token)match(input,LDIV,FOLLOW_LDIV_in_operator034506); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LDIV.add(LDIV344);

					// AST REWRITE
					// elements: LDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 424:13: -> LDIV
					{
						adaptor.addChild(root_0, stream_LDIV.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:425:8: MTIMES
					{
					MTIMES345=(Token)match(input,MTIMES,FOLLOW_MTIMES_in_operator034519); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MTIMES.add(MTIMES345);

					// AST REWRITE
					// elements: MTIMES
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 425:15: -> MTIMES
					{
						adaptor.addChild(root_0, stream_MTIMES.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:426:8: MRDIV
					{
					MRDIV346=(Token)match(input,MRDIV,FOLLOW_MRDIV_in_operator034532); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MRDIV.add(MRDIV346);

					// AST REWRITE
					// elements: MRDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 426:14: -> MRDIV
					{
						adaptor.addChild(root_0, stream_MRDIV.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:427:8: MLDIV
					{
					MLDIV347=(Token)match(input,MLDIV,FOLLOW_MLDIV_in_operator034545); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MLDIV.add(MLDIV347);

					// AST REWRITE
					// elements: MLDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 427:14: -> MLDIV
					{
						adaptor.addChild(root_0, stream_MLDIV.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator03"


	public static class expression03_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression03"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:430:1: expression03 : (op= operator02 x1= expression03 -> ^( $op $x1) |x2= expression02 -> $x2);
	public final MatlabParser.expression03_return expression03() throws RecognitionException {
		MatlabParser.expression03_return retval = new MatlabParser.expression03_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator02=new RewriteRuleSubtreeStream(adaptor,"rule operator02");
		RewriteRuleSubtreeStream stream_expression03=new RewriteRuleSubtreeStream(adaptor,"rule expression03");
		RewriteRuleSubtreeStream stream_expression02=new RewriteRuleSubtreeStream(adaptor,"rule expression02");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:430:14: (op= operator02 x1= expression03 -> ^( $op $x1) |x2= expression02 -> $x2)
			int alt94=2;
			int LA94_0 = input.LA(1);
			if ( (LA94_0==MINUS||LA94_0==NOT||LA94_0==PLUS) ) {
				alt94=1;
			}
			else if ( (LA94_0==ID||LA94_0==IMAGINARY||LA94_0==LCURLY||(LA94_0 >= LPAREN && LA94_0 <= LSQUARE)||LA94_0==REAL||LA94_0==STRING) ) {
				alt94=2;
			}
			else if ( (LA94_0==END) && ((Index_IsActive()))) {
				alt94=2;
			}
			else if ( (LA94_0==AT||LA94_0==QUESTION) ) {
				alt94=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 94, 0, input);
				throw nvae;
			}

			switch (alt94) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:430:16: op= operator02 x1= expression03
					{
					pushFollow(FOLLOW_operator02_in_expression034565);
					op=operator02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator02.add(op.getTree());
					pushFollow(FOLLOW_expression03_in_expression034569);
					x1=expression03();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression03.add(x1.getTree());
					// AST REWRITE
					// elements: x1, op
					// token labels: 
					// rule labels: op, x1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 430:46: -> ^( $op $x1)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:430:49: ^( $op $x1)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_x1.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:431:7: x2= expression02
					{
					pushFollow(FOLLOW_expression02_in_expression034589);
					x2=expression02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression02.add(x2.getTree());
					// AST REWRITE
					// elements: x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 431:23: -> $x2
					{
						adaptor.addChild(root_0, stream_x2.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression03"


	public static class operator02_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator02"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:434:1: operator02 : ( PLUS -> POSITIVE[$PLUS] | MINUS -> NEGATIVE[$MINUS] | NOT -> NOT );
	public final MatlabParser.operator02_return operator02() throws RecognitionException {
		MatlabParser.operator02_return retval = new MatlabParser.operator02_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLUS348=null;
		Token MINUS349=null;
		Token NOT350=null;

		Object PLUS348_tree=null;
		Object MINUS349_tree=null;
		Object NOT350_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:434:12: ( PLUS -> POSITIVE[$PLUS] | MINUS -> NEGATIVE[$MINUS] | NOT -> NOT )
			int alt95=3;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt95=1;
				}
				break;
			case MINUS:
				{
				alt95=2;
				}
				break;
			case NOT:
				{
				alt95=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 95, 0, input);
				throw nvae;
			}
			switch (alt95) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:434:14: PLUS
					{
					PLUS348=(Token)match(input,PLUS,FOLLOW_PLUS_in_operator024607); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PLUS.add(PLUS348);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 434:19: -> POSITIVE[$PLUS]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(POSITIVE, PLUS348));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:435:8: MINUS
					{
					MINUS349=(Token)match(input,MINUS,FOLLOW_MINUS_in_operator024621); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(MINUS349);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 435:14: -> NEGATIVE[$MINUS]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(NEGATIVE, MINUS349));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:436:8: NOT
					{
					NOT350=(Token)match(input,NOT,FOLLOW_NOT_in_operator024635); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT350);

					// AST REWRITE
					// elements: NOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 436:12: -> NOT
					{
						adaptor.addChild(root_0, stream_NOT.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator02"


	public static class expression02_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression02"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:1: expression02 : (x1= expression00 -> $x1) ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )* ;
	public final MatlabParser.expression02_return expression02() throws RecognitionException {
		MatlabParser.expression02_return retval = new MatlabParser.expression02_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TRANS351=null;
		Token CTRANS352=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x2 =null;

		Object TRANS351_tree=null;
		Object CTRANS352_tree=null;
		RewriteRuleTokenStream stream_TRANS=new RewriteRuleTokenStream(adaptor,"token TRANS");
		RewriteRuleTokenStream stream_CTRANS=new RewriteRuleTokenStream(adaptor,"token CTRANS");
		RewriteRuleSubtreeStream stream_operator01=new RewriteRuleSubtreeStream(adaptor,"rule operator01");
		RewriteRuleSubtreeStream stream_expression01=new RewriteRuleSubtreeStream(adaptor,"rule expression01");
		RewriteRuleSubtreeStream stream_expression00=new RewriteRuleSubtreeStream(adaptor,"rule expression00");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:14: ( (x1= expression00 -> $x1) ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:16: (x1= expression00 -> $x1) ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:16: (x1= expression00 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:17: x1= expression00
			{
			pushFollow(FOLLOW_expression00_in_expression024656);
			x1=expression00();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression00.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 439:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:440:7: ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )*
			loop96:
			while (true) {
				int alt96=4;
				switch ( input.LA(1) ) {
				case POW:
					{
					alt96=1;
					}
					break;
				case MPOW:
					{
					alt96=1;
					}
					break;
				case TRANS:
					{
					alt96=2;
					}
					break;
				case CTRANS:
					{
					alt96=3;
					}
					break;
				}
				switch (alt96) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:441:9: (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) )
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:441:9: (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) )
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:441:10: op= operator01 x2= expression01
					{
					pushFollow(FOLLOW_operator01_in_expression024691);
					op=operator01();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator01.add(op.getTree());
					pushFollow(FOLLOW_expression01_in_expression024695);
					x2=expression01();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression01.add(x2.getTree());
					// AST REWRITE
					// elements: expression02, x2, op
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 441:40: -> ^( $op $expression02 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:441:43: ^( $op $expression02 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:442:9: ( TRANS -> ^( TRANS $expression02) )
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:442:9: ( TRANS -> ^( TRANS $expression02) )
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:442:10: TRANS
					{
					TRANS351=(Token)match(input,TRANS,FOLLOW_TRANS_in_expression024720); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_TRANS.add(TRANS351);

					// AST REWRITE
					// elements: expression02, TRANS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 442:16: -> ^( TRANS $expression02)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:442:19: ^( TRANS $expression02)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_TRANS.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:443:9: ( CTRANS -> ^( CTRANS $expression02) )
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:443:9: ( CTRANS -> ^( CTRANS $expression02) )
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:443:10: CTRANS
					{
					CTRANS352=(Token)match(input,CTRANS,FOLLOW_CTRANS_in_expression024741); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CTRANS.add(CTRANS352);

					// AST REWRITE
					// elements: CTRANS, expression02
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 443:17: -> ^( CTRANS $expression02)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:443:20: ^( CTRANS $expression02)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_CTRANS.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}

					}
					break;

				default :
					break loop96;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression02"


	public static class operator01_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator01"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:446:1: operator01 : ( POW -> POW | MPOW -> MPOW );
	public final MatlabParser.operator01_return operator01() throws RecognitionException {
		MatlabParser.operator01_return retval = new MatlabParser.operator01_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token POW353=null;
		Token MPOW354=null;

		Object POW353_tree=null;
		Object MPOW354_tree=null;
		RewriteRuleTokenStream stream_POW=new RewriteRuleTokenStream(adaptor,"token POW");
		RewriteRuleTokenStream stream_MPOW=new RewriteRuleTokenStream(adaptor,"token MPOW");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:446:12: ( POW -> POW | MPOW -> MPOW )
			int alt97=2;
			int LA97_0 = input.LA(1);
			if ( (LA97_0==POW) ) {
				alt97=1;
			}
			else if ( (LA97_0==MPOW) ) {
				alt97=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 97, 0, input);
				throw nvae;
			}

			switch (alt97) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:446:14: POW
					{
					POW353=(Token)match(input,POW,FOLLOW_POW_in_operator014769); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_POW.add(POW353);

					// AST REWRITE
					// elements: POW
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 446:18: -> POW
					{
						adaptor.addChild(root_0, stream_POW.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:447:8: MPOW
					{
					MPOW354=(Token)match(input,MPOW,FOLLOW_MPOW_in_operator014782); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MPOW.add(MPOW354);

					// AST REWRITE
					// elements: MPOW
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 447:13: -> MPOW
					{
						adaptor.addChild(root_0, stream_MPOW.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator01"


	public static class expression01_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression01"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:450:1: expression01 : (op= operator02 x1= expression01 -> ^( $op $x1) |x2= expression00 -> $x2);
	public final MatlabParser.expression01_return expression01() throws RecognitionException {
		MatlabParser.expression01_return retval = new MatlabParser.expression01_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator02=new RewriteRuleSubtreeStream(adaptor,"rule operator02");
		RewriteRuleSubtreeStream stream_expression01=new RewriteRuleSubtreeStream(adaptor,"rule expression01");
		RewriteRuleSubtreeStream stream_expression00=new RewriteRuleSubtreeStream(adaptor,"rule expression00");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:450:14: (op= operator02 x1= expression01 -> ^( $op $x1) |x2= expression00 -> $x2)
			int alt98=2;
			int LA98_0 = input.LA(1);
			if ( (LA98_0==MINUS||LA98_0==NOT||LA98_0==PLUS) ) {
				alt98=1;
			}
			else if ( (LA98_0==ID||LA98_0==IMAGINARY||LA98_0==LCURLY||(LA98_0 >= LPAREN && LA98_0 <= LSQUARE)||LA98_0==REAL||LA98_0==STRING) ) {
				alt98=2;
			}
			else if ( (LA98_0==END) && ((Index_IsActive()))) {
				alt98=2;
			}
			else if ( (LA98_0==AT||LA98_0==QUESTION) ) {
				alt98=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 98, 0, input);
				throw nvae;
			}

			switch (alt98) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:450:16: op= operator02 x1= expression01
					{
					pushFollow(FOLLOW_operator02_in_expression014802);
					op=operator02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator02.add(op.getTree());
					pushFollow(FOLLOW_expression01_in_expression014806);
					x1=expression01();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression01.add(x1.getTree());
					// AST REWRITE
					// elements: x1, op
					// token labels: 
					// rule labels: op, x1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 450:46: -> ^( $op $x1)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:450:49: ^( $op $x1)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_x1.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:451:7: x2= expression00
					{
					pushFollow(FOLLOW_expression00_in_expression014826);
					x2=expression00();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression00.add(x2.getTree());
					// AST REWRITE
					// elements: x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 451:23: -> $x2
					{
						adaptor.addChild(root_0, stream_x2.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression01"


	public static class expression00_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression00"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:454:1: expression00 : atom -> atom ;
	public final MatlabParser.expression00_return expression00() throws RecognitionException {
		MatlabParser.expression00_return retval = new MatlabParser.expression00_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope atom355 =null;

		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:454:14: ( atom -> atom )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:454:16: atom
			{
			pushFollow(FOLLOW_atom_in_expression004844);
			atom355=atom();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_atom.add(atom355.getTree());
			// AST REWRITE
			// elements: atom
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 454:21: -> atom
			{
				adaptor.addChild(root_0, stream_atom.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression00"


	public static class atom_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "atom"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:458:1: atom : ( chain -> chain | real -> real | imaginary -> imaginary | stringDef -> stringDef | regularArray -> regularArray | cellArray -> cellArray | parenthesized -> parenthesized | end -> end | functionHandle -> functionHandle | anonymousFunction -> anonymousFunction | metaclass -> metaclass );
	public final MatlabParser.atom_return atom() throws RecognitionException {
		MatlabParser.atom_return retval = new MatlabParser.atom_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope chain356 =null;
		ParserRuleReturnScope real357 =null;
		ParserRuleReturnScope imaginary358 =null;
		ParserRuleReturnScope stringDef359 =null;
		ParserRuleReturnScope regularArray360 =null;
		ParserRuleReturnScope cellArray361 =null;
		ParserRuleReturnScope parenthesized362 =null;
		ParserRuleReturnScope end363 =null;
		ParserRuleReturnScope functionHandle364 =null;
		ParserRuleReturnScope anonymousFunction365 =null;
		ParserRuleReturnScope metaclass366 =null;

		RewriteRuleSubtreeStream stream_chain=new RewriteRuleSubtreeStream(adaptor,"rule chain");
		RewriteRuleSubtreeStream stream_stringDef=new RewriteRuleSubtreeStream(adaptor,"rule stringDef");
		RewriteRuleSubtreeStream stream_cellArray=new RewriteRuleSubtreeStream(adaptor,"rule cellArray");
		RewriteRuleSubtreeStream stream_imaginary=new RewriteRuleSubtreeStream(adaptor,"rule imaginary");
		RewriteRuleSubtreeStream stream_functionHandle=new RewriteRuleSubtreeStream(adaptor,"rule functionHandle");
		RewriteRuleSubtreeStream stream_parenthesized=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized");
		RewriteRuleSubtreeStream stream_anonymousFunction=new RewriteRuleSubtreeStream(adaptor,"rule anonymousFunction");
		RewriteRuleSubtreeStream stream_end=new RewriteRuleSubtreeStream(adaptor,"rule end");
		RewriteRuleSubtreeStream stream_real=new RewriteRuleSubtreeStream(adaptor,"rule real");
		RewriteRuleSubtreeStream stream_regularArray=new RewriteRuleSubtreeStream(adaptor,"rule regularArray");
		RewriteRuleSubtreeStream stream_metaclass=new RewriteRuleSubtreeStream(adaptor,"rule metaclass");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:458:6: ( chain -> chain | real -> real | imaginary -> imaginary | stringDef -> stringDef | regularArray -> regularArray | cellArray -> cellArray | parenthesized -> parenthesized | end -> end | functionHandle -> functionHandle | anonymousFunction -> anonymousFunction | metaclass -> metaclass )
			int alt99=11;
			int LA99_0 = input.LA(1);
			if ( (LA99_0==ID) ) {
				alt99=1;
			}
			else if ( (LA99_0==REAL) ) {
				alt99=2;
			}
			else if ( (LA99_0==IMAGINARY) ) {
				alt99=3;
			}
			else if ( (LA99_0==STRING) ) {
				alt99=4;
			}
			else if ( (LA99_0==LSQUARE) ) {
				alt99=5;
			}
			else if ( (LA99_0==LCURLY) ) {
				alt99=6;
			}
			else if ( (LA99_0==LPAREN) ) {
				alt99=7;
			}
			else if ( (LA99_0==END) && ((Index_IsActive()))) {
				alt99=8;
			}
			else if ( (LA99_0==AT) ) {
				int LA99_9 = input.LA(2);
				if ( (LA99_9==ID) ) {
					alt99=9;
				}
				else if ( (LA99_9==LPAREN) ) {
					alt99=10;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 99, 9, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA99_0==QUESTION) ) {
				alt99=11;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 99, 0, input);
				throw nvae;
			}

			switch (alt99) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:458:8: chain
					{
					pushFollow(FOLLOW_chain_in_atom4859);
					chain356=chain();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_chain.add(chain356.getTree());
					// AST REWRITE
					// elements: chain
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 458:14: -> chain
					{
						adaptor.addChild(root_0, stream_chain.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:459:8: real
					{
					pushFollow(FOLLOW_real_in_atom4872);
					real357=real();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_real.add(real357.getTree());
					// AST REWRITE
					// elements: real
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 459:13: -> real
					{
						adaptor.addChild(root_0, stream_real.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:460:5: imaginary
					{
					pushFollow(FOLLOW_imaginary_in_atom4882);
					imaginary358=imaginary();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_imaginary.add(imaginary358.getTree());
					// AST REWRITE
					// elements: imaginary
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 460:15: -> imaginary
					{
						adaptor.addChild(root_0, stream_imaginary.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:461:5: stringDef
					{
					pushFollow(FOLLOW_stringDef_in_atom4892);
					stringDef359=stringDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_stringDef.add(stringDef359.getTree());
					// AST REWRITE
					// elements: stringDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 461:15: -> stringDef
					{
						adaptor.addChild(root_0, stream_stringDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:462:5: regularArray
					{
					pushFollow(FOLLOW_regularArray_in_atom4902);
					regularArray360=regularArray();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_regularArray.add(regularArray360.getTree());
					// AST REWRITE
					// elements: regularArray
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 462:18: -> regularArray
					{
						adaptor.addChild(root_0, stream_regularArray.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:463:5: cellArray
					{
					pushFollow(FOLLOW_cellArray_in_atom4912);
					cellArray361=cellArray();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_cellArray.add(cellArray361.getTree());
					// AST REWRITE
					// elements: cellArray
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 463:15: -> cellArray
					{
						adaptor.addChild(root_0, stream_cellArray.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:464:5: parenthesized
					{
					pushFollow(FOLLOW_parenthesized_in_atom4922);
					parenthesized362=parenthesized();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesized.add(parenthesized362.getTree());
					// AST REWRITE
					// elements: parenthesized
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 464:19: -> parenthesized
					{
						adaptor.addChild(root_0, stream_parenthesized.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:465:5: end
					{
					pushFollow(FOLLOW_end_in_atom4932);
					end363=end();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_end.add(end363.getTree());
					// AST REWRITE
					// elements: end
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 465:9: -> end
					{
						adaptor.addChild(root_0, stream_end.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:466:5: functionHandle
					{
					pushFollow(FOLLOW_functionHandle_in_atom4942);
					functionHandle364=functionHandle();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_functionHandle.add(functionHandle364.getTree());
					// AST REWRITE
					// elements: functionHandle
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 466:20: -> functionHandle
					{
						adaptor.addChild(root_0, stream_functionHandle.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:467:5: anonymousFunction
					{
					pushFollow(FOLLOW_anonymousFunction_in_atom4952);
					anonymousFunction365=anonymousFunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_anonymousFunction.add(anonymousFunction365.getTree());
					// AST REWRITE
					// elements: anonymousFunction
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 467:23: -> anonymousFunction
					{
						adaptor.addChild(root_0, stream_anonymousFunction.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:468:5: metaclass
					{
					pushFollow(FOLLOW_metaclass_in_atom4962);
					metaclass366=metaclass();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_metaclass.add(metaclass366.getTree());
					// AST REWRITE
					// elements: metaclass
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 468:15: -> metaclass
					{
						adaptor.addChild(root_0, stream_metaclass.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "atom"


	public static class chain_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "chain"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:473:1: chain : (x1= var -> $x1) ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )* ;
	public final MatlabParser.chain_return chain() throws RecognitionException {
		MatlabParser.chain_return retval = new MatlabParser.chain_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;
		ParserRuleReturnScope x3 =null;
		ParserRuleReturnScope x4 =null;
		ParserRuleReturnScope x5 =null;
		ParserRuleReturnScope x6 =null;

		RewriteRuleSubtreeStream stream_parenthesisOperator=new RewriteRuleSubtreeStream(adaptor,"rule parenthesisOperator");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_dotExpressionOperator=new RewriteRuleSubtreeStream(adaptor,"rule dotExpressionOperator");
		RewriteRuleSubtreeStream stream_curlyBraceOperator=new RewriteRuleSubtreeStream(adaptor,"rule curlyBraceOperator");
		RewriteRuleSubtreeStream stream_atBaseOperator=new RewriteRuleSubtreeStream(adaptor,"rule atBaseOperator");
		RewriteRuleSubtreeStream stream_dotNameOperator=new RewriteRuleSubtreeStream(adaptor,"rule dotNameOperator");

		Chain_Begin();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:474:24: ( (x1= var -> $x1) ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:475:2: (x1= var -> $x1) ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:475:2: (x1= var -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:475:2: x1= var
			{
			pushFollow(FOLLOW_var_in_chain4987);
			x1=var();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_var.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 475:9: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:5: ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )*
			loop100:
			while (true) {
				int alt100=6;
				alt100 = dfa100.predict(input);
				switch (alt100) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:5: ( DOT LPAREN )=>x2= dotExpressionOperator
					{
					pushFollow(FOLLOW_dotExpressionOperator_in_chain5008);
					x2=dotExpressionOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dotExpressionOperator.add(x2.getTree());
					// AST REWRITE
					// elements: chain, x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 476:45: -> ^( DOTEXPRESSION[$x2.start] $chain $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:48: ^( DOTEXPRESSION[$x2.start] $chain $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DOTEXPRESSION, (x2!=null?(x2.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:477:5: x3= dotNameOperator
					{
					pushFollow(FOLLOW_dotNameOperator_in_chain5029);
					x3=dotNameOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dotNameOperator.add(x3.getTree());
					// AST REWRITE
					// elements: chain, x3
					// token labels: 
					// rule labels: x3, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x3=new RewriteRuleSubtreeStream(adaptor,"rule x3",x3!=null?x3.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 477:24: -> ^( DOTNAME[$x3.start] $chain $x3)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:477:27: ^( DOTNAME[$x3.start] $chain $x3)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DOTNAME, (x3!=null?(x3.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x3.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:478:5: x4= parenthesisOperator
					{
					pushFollow(FOLLOW_parenthesisOperator_in_chain5050);
					x4=parenthesisOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesisOperator.add(x4.getTree());
					// AST REWRITE
					// elements: x4, chain
					// token labels: 
					// rule labels: x4, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x4=new RewriteRuleSubtreeStream(adaptor,"rule x4",x4!=null?x4.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 478:28: -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:478:31: ^( PARENTHESIS[$x4.start] $chain ( $x4)? )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PARENTHESIS, (x4!=null?(x4.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:478:63: ( $x4)?
						if ( stream_x4.hasNext() ) {
							adaptor.addChild(root_1, stream_x4.nextTree());
						}
						stream_x4.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:479:5: x5= curlyBraceOperator
					{
					pushFollow(FOLLOW_curlyBraceOperator_in_chain5074);
					x5=curlyBraceOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_curlyBraceOperator.add(x5.getTree());
					// AST REWRITE
					// elements: chain, x5
					// token labels: 
					// rule labels: x5, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x5=new RewriteRuleSubtreeStream(adaptor,"rule x5",x5!=null?x5.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 479:27: -> ^( CURLYBRACE[$x5.start] $chain $x5)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:479:30: ^( CURLYBRACE[$x5.start] $chain $x5)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CURLYBRACE, (x5!=null?(x5.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x5.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:480:5: x6= atBaseOperator
					{
					pushFollow(FOLLOW_atBaseOperator_in_chain5095);
					x6=atBaseOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_atBaseOperator.add(x6.getTree());
					// AST REWRITE
					// elements: chain, x6
					// token labels: 
					// rule labels: x6, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x6=new RewriteRuleSubtreeStream(adaptor,"rule x6",x6!=null?x6.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 480:23: -> ^( ATBASE[$x6.start] $chain $x6)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:480:26: ^( ATBASE[$x6.start] $chain $x6)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ATBASE, (x6!=null?(x6.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x6.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop100;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Chain_End();
		}
		return retval;
	}
	// $ANTLR end "chain"


	public static class var_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "var"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:484:1: var : name -> ^( VAR[\"\"] name ) ;
	public final MatlabParser.var_return var() throws RecognitionException {
		MatlabParser.var_return retval = new MatlabParser.var_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name367 =null;

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:484:5: ( name -> ^( VAR[\"\"] name ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:484:7: name
			{
			pushFollow(FOLLOW_name_in_var5124);
			name367=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name367.getTree());
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 484:12: -> ^( VAR[\"\"] name )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:484:15: ^( VAR[\"\"] name )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "var"


	public static class dotExpressionOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dotExpressionOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:486:1: dotExpressionOperator :{...}? => DOT LPAREN expression RPAREN -> expression ;
	public final MatlabParser.dotExpressionOperator_return dotExpressionOperator() throws RecognitionException {
		MatlabParser.dotExpressionOperator_return retval = new MatlabParser.dotExpressionOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT368=null;
		Token LPAREN369=null;
		Token RPAREN371=null;
		ParserRuleReturnScope expression370 =null;

		Object DOT368_tree=null;
		Object LPAREN369_tree=null;
		Object RPAREN371_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		Balance_EnterParenthesis();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:487:37: ({...}? => DOT LPAREN expression RPAREN -> expression )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:488:1: {...}? => DOT LPAREN expression RPAREN
			{
			if ( !((Chain_MayAddDotExpression())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dotExpressionOperator", "Chain_MayAddDotExpression()");
			}
			DOT368=(Token)match(input,DOT,FOLLOW_DOT_in_dotExpressionOperator5150); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOT.add(DOT368);

			LPAREN369=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_dotExpressionOperator5152); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN369);

			pushFollow(FOLLOW_expression_in_dotExpressionOperator5154);
			expression370=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression370.getTree());
			RPAREN371=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_dotExpressionOperator5156); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN371);

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 488:63: -> expression
			{
				adaptor.addChild(root_0, stream_expression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitParenthesis(); Chain_AddedDotExpression();
		}
		return retval;
	}
	// $ANTLR end "dotExpressionOperator"


	public static class dotNameOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dotNameOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:491:1: dotNameOperator :{...}? => DOT anyName -> anyName ;
	public final MatlabParser.dotNameOperator_return dotNameOperator() throws RecognitionException {
		MatlabParser.dotNameOperator_return retval = new MatlabParser.dotNameOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT372=null;
		ParserRuleReturnScope anyName373 =null;

		Object DOT372_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_anyName=new RewriteRuleSubtreeStream(adaptor,"rule anyName");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:491:17: ({...}? => DOT anyName -> anyName )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:491:19: {...}? => DOT anyName
			{
			if ( !((Chain_MayAddDotName())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dotNameOperator", "Chain_MayAddDotName()");
			}
			DOT372=(Token)match(input,DOT,FOLLOW_DOT_in_dotNameOperator5176); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOT.add(DOT372);

			pushFollow(FOLLOW_anyName_in_dotNameOperator5178);
			anyName373=anyName();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_anyName.add(anyName373.getTree());
			// AST REWRITE
			// elements: anyName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 491:58: -> anyName
			{
				adaptor.addChild(root_0, stream_anyName.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Chain_AddedDotName();
		}
		return retval;
	}
	// $ANTLR end "dotNameOperator"


	public static class anyName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "anyName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:494:1: anyName : xANYID -> ^( NAME[\"\"] xANYID ) ;
	public final MatlabParser.anyName_return anyName() throws RecognitionException {
		MatlabParser.anyName_return retval = new MatlabParser.anyName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xANYID374 =null;

		RewriteRuleSubtreeStream stream_xANYID=new RewriteRuleSubtreeStream(adaptor,"rule xANYID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:494:9: ( xANYID -> ^( NAME[\"\"] xANYID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:494:11: xANYID
			{
			pushFollow(FOLLOW_xANYID_in_anyName5195);
			xANYID374=xANYID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xANYID.add(xANYID374.getTree());
			// AST REWRITE
			// elements: xANYID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 494:18: -> ^( NAME[\"\"] xANYID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:494:21: ^( NAME[\"\"] xANYID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xANYID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "anyName"


	public static class parenthesisOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parenthesisOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:496:1: parenthesisOperator :{...}? =>{...}? => LPAREN ( arguments )? RPAREN -> ( arguments )? ;
	public final MatlabParser.parenthesisOperator_return parenthesisOperator() throws RecognitionException {
		MatlabParser.parenthesisOperator_return retval = new MatlabParser.parenthesisOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN375=null;
		Token RPAREN377=null;
		ParserRuleReturnScope arguments376 =null;

		Object LPAREN375_tree=null;
		Object RPAREN377_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");

		Index_EnterParenthesis(); Balance_EnterParenthesis();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:497:63: ({...}? =>{...}? => LPAREN ( arguments )? RPAREN -> ( arguments )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:498:1: {...}? =>{...}? => LPAREN ( arguments )? RPAREN
			{
			if ( !((Chain_MayAddParenthesis())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parenthesisOperator", "Chain_MayAddParenthesis()");
			}
			if ( !((!Balance_InCreationOrStore_SpacesOnLeft())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parenthesisOperator", "!Balance_InCreationOrStore_SpacesOnLeft()");
			}
			LPAREN375=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesisOperator5224); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN375);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:498:86: ( arguments )?
			int alt101=2;
			int LA101_0 = input.LA(1);
			if ( (LA101_0==ID||LA101_0==IMAGINARY||LA101_0==LCURLY||(LA101_0 >= LPAREN && LA101_0 <= LSQUARE)||LA101_0==MINUS||LA101_0==NOT||LA101_0==PLUS||LA101_0==REAL||LA101_0==STRING) ) {
				alt101=1;
			}
			else if ( (LA101_0==END) && ((Index_IsActive()))) {
				alt101=1;
			}
			else if ( (LA101_0==AT||LA101_0==COLON||LA101_0==QUESTION) ) {
				alt101=1;
			}
			switch (alt101) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:498:87: arguments
					{
					pushFollow(FOLLOW_arguments_in_parenthesisOperator5227);
					arguments376=arguments();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_arguments.add(arguments376.getTree());
					}
					break;

			}

			RPAREN377=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesisOperator5231); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN377);

			// AST REWRITE
			// elements: arguments
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 498:106: -> ( arguments )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:498:109: ( arguments )?
				if ( stream_arguments.hasNext() ) {
					adaptor.addChild(root_0, stream_arguments.nextTree());
				}
				stream_arguments.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitParenthesis(); Index_ExitParenthesis(); Chain_AddedParenthesis();
		}
		return retval;
	}
	// $ANTLR end "parenthesisOperator"


	public static class arguments_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "arguments"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:1: arguments : argument ( COMMA argument )* -> ( argument )+ ;
	public final MatlabParser.arguments_return arguments() throws RecognitionException {
		MatlabParser.arguments_return retval = new MatlabParser.arguments_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA379=null;
		ParserRuleReturnScope argument378 =null;
		ParserRuleReturnScope argument380 =null;

		Object COMMA379_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_argument=new RewriteRuleSubtreeStream(adaptor,"rule argument");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:11: ( argument ( COMMA argument )* -> ( argument )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:13: argument ( COMMA argument )*
			{
			pushFollow(FOLLOW_argument_in_arguments5251);
			argument378=argument();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_argument.add(argument378.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:22: ( COMMA argument )*
			loop102:
			while (true) {
				int alt102=2;
				int LA102_0 = input.LA(1);
				if ( (LA102_0==COMMA) ) {
					alt102=1;
				}

				switch (alt102) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:23: COMMA argument
					{
					COMMA379=(Token)match(input,COMMA,FOLLOW_COMMA_in_arguments5254); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA379);

					pushFollow(FOLLOW_argument_in_arguments5256);
					argument380=argument();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_argument.add(argument380.getTree());
					}
					break;

				default :
					break loop102;
				}
			}

			// AST REWRITE
			// elements: argument
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 501:40: -> ( argument )+
			{
				if ( !(stream_argument.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_argument.hasNext() ) {
					adaptor.addChild(root_0, stream_argument.nextTree());
				}
				stream_argument.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "arguments"


	public static class argument_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "argument"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:503:1: argument : ( expression -> expression | COLON -> ALL[$COLON] );
	public final MatlabParser.argument_return argument() throws RecognitionException {
		MatlabParser.argument_return retval = new MatlabParser.argument_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COLON382=null;
		ParserRuleReturnScope expression381 =null;

		Object COLON382_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:503:10: ( expression -> expression | COLON -> ALL[$COLON] )
			int alt103=2;
			int LA103_0 = input.LA(1);
			if ( (LA103_0==ID||LA103_0==IMAGINARY||LA103_0==LCURLY||(LA103_0 >= LPAREN && LA103_0 <= LSQUARE)||LA103_0==MINUS||LA103_0==NOT||LA103_0==PLUS||LA103_0==REAL||LA103_0==STRING) ) {
				alt103=1;
			}
			else if ( (LA103_0==END) && ((Index_IsActive()))) {
				alt103=1;
			}
			else if ( (LA103_0==AT||LA103_0==QUESTION) ) {
				alt103=1;
			}
			else if ( (LA103_0==COLON) ) {
				alt103=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 103, 0, input);
				throw nvae;
			}

			switch (alt103) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:503:12: expression
					{
					pushFollow(FOLLOW_expression_in_argument5274);
					expression381=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression381.getTree());
					// AST REWRITE
					// elements: expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 503:23: -> expression
					{
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:504:6: COLON
					{
					COLON382=(Token)match(input,COLON,FOLLOW_COLON_in_argument5285); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON382);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 504:12: -> ALL[$COLON]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ALL, COLON382));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "argument"


	public static class curlyBraceOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "curlyBraceOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:507:1: curlyBraceOperator :{...}? =>{...}? => LCURLY arguments RCURLY -> arguments ;
	public final MatlabParser.curlyBraceOperator_return curlyBraceOperator() throws RecognitionException {
		MatlabParser.curlyBraceOperator_return retval = new MatlabParser.curlyBraceOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LCURLY383=null;
		Token RCURLY385=null;
		ParserRuleReturnScope arguments384 =null;

		Object LCURLY383_tree=null;
		Object RCURLY385_tree=null;
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");

		Index_EnterCurlyBrace(); Balance_EnterIndexCurlyBrace();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:508:66: ({...}? =>{...}? => LCURLY arguments RCURLY -> arguments )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:509:1: {...}? =>{...}? => LCURLY arguments RCURLY
			{
			if ( !((Chain_MayAddCurlyBrace())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "curlyBraceOperator", "Chain_MayAddCurlyBrace()");
			}
			if ( !((!Balance_InCreationOrStore_SpacesOnLeft())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "curlyBraceOperator", "!Balance_InCreationOrStore_SpacesOnLeft()");
			}
			LCURLY383=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_curlyBraceOperator5313); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY383);

			pushFollow(FOLLOW_arguments_in_curlyBraceOperator5315);
			arguments384=arguments();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_arguments.add(arguments384.getTree());
			RCURLY385=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_curlyBraceOperator5317); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY385);

			// AST REWRITE
			// elements: arguments
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 509:102: -> arguments
			{
				adaptor.addChild(root_0, stream_arguments.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitIndexCurlyBrace(); Index_ExitCurlyBrace(); Chain_AddedCurlyBrace();
		}
		return retval;
	}
	// $ANTLR end "curlyBraceOperator"


	public static class atBaseOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "atBaseOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:512:1: atBaseOperator :{...}? =>{...}? => AT classReference -> classReference ;
	public final MatlabParser.atBaseOperator_return atBaseOperator() throws RecognitionException {
		MatlabParser.atBaseOperator_return retval = new MatlabParser.atBaseOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AT386=null;
		ParserRuleReturnScope classReference387 =null;

		Object AT386_tree=null;
		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:512:16: ({...}? =>{...}? => AT classReference -> classReference )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:512:18: {...}? =>{...}? => AT classReference
			{
			if ( !((Chain_MayAddAtBase())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "atBaseOperator", "Chain_MayAddAtBase()");
			}
			if ( !((!Balance_InCreationOrStore_SpacesOnLeft())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "atBaseOperator", "!Balance_InCreationOrStore_SpacesOnLeft()");
			}
			AT386=(Token)match(input,AT,FOLLOW_AT_in_atBaseOperator5340); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_AT.add(AT386);

			pushFollow(FOLLOW_classReference_in_atBaseOperator5342);
			classReference387=classReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classReference.add(classReference387.getTree());
			// AST REWRITE
			// elements: classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 512:109: -> classReference
			{
				adaptor.addChild(root_0, stream_classReference.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Chain_AddedAtBase();
		}
		return retval;
	}
	// $ANTLR end "atBaseOperator"


	public static class real_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "real"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:517:1: real : REAL -> REAL ;
	public final MatlabParser.real_return real() throws RecognitionException {
		MatlabParser.real_return retval = new MatlabParser.real_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REAL388=null;

		Object REAL388_tree=null;
		RewriteRuleTokenStream stream_REAL=new RewriteRuleTokenStream(adaptor,"token REAL");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:517:6: ( REAL -> REAL )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:517:8: REAL
			{
			REAL388=(Token)match(input,REAL,FOLLOW_REAL_in_real5361); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL.add(REAL388);

			// AST REWRITE
			// elements: REAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 517:13: -> REAL
			{
				adaptor.addChild(root_0, stream_REAL.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "real"


	public static class imaginary_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "imaginary"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:521:1: imaginary : IMAGINARY -> IMAGINARY ;
	public final MatlabParser.imaginary_return imaginary() throws RecognitionException {
		MatlabParser.imaginary_return retval = new MatlabParser.imaginary_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token IMAGINARY389=null;

		Object IMAGINARY389_tree=null;
		RewriteRuleTokenStream stream_IMAGINARY=new RewriteRuleTokenStream(adaptor,"token IMAGINARY");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:521:11: ( IMAGINARY -> IMAGINARY )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:521:13: IMAGINARY
			{
			IMAGINARY389=(Token)match(input,IMAGINARY,FOLLOW_IMAGINARY_in_imaginary5376); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_IMAGINARY.add(IMAGINARY389);

			// AST REWRITE
			// elements: IMAGINARY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 521:23: -> IMAGINARY
			{
				adaptor.addChild(root_0, stream_IMAGINARY.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "imaginary"


	public static class stringDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "stringDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:525:1: stringDef : STRING -> STRING ;
	public final MatlabParser.stringDef_return stringDef() throws RecognitionException {
		MatlabParser.stringDef_return retval = new MatlabParser.stringDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token STRING390=null;

		Object STRING390_tree=null;
		RewriteRuleTokenStream stream_STRING=new RewriteRuleTokenStream(adaptor,"token STRING");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:525:11: ( STRING -> STRING )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:525:13: STRING
			{
			STRING390=(Token)match(input,STRING,FOLLOW_STRING_in_stringDef5391); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_STRING.add(STRING390);

			// AST REWRITE
			// elements: STRING
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 525:20: -> STRING
			{
				adaptor.addChild(root_0, stream_STRING.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "stringDef"


	public static class regularArray_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "regularArray"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:531:1: regularArray : LSQUARE rows RSQUARE -> ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) ) ;
	public final MatlabParser.regularArray_return regularArray() throws RecognitionException {
		MatlabParser.regularArray_return retval = new MatlabParser.regularArray_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE391=null;
		Token RSQUARE393=null;
		ParserRuleReturnScope rows392 =null;

		Object LSQUARE391_tree=null;
		Object RSQUARE393_tree=null;
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_rows=new RewriteRuleSubtreeStream(adaptor,"rule rows");

		Balance_EnterCreationSquareBrace();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:532:45: ( LSQUARE rows RSQUARE -> ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:533:1: LSQUARE rows RSQUARE
			{
			LSQUARE391=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_regularArray5413); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE391);

			pushFollow(FOLLOW_rows_in_regularArray5415);
			rows392=rows();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_rows.add(rows392.getTree());
			RSQUARE393=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_regularArray5417); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE393);

			// AST REWRITE
			// elements: rows
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 533:22: -> ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:533:25: ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(REGULARARRAY, LSQUARE391), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:533:50: ^( VCAT[\"\"] rows )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(VCAT, ""), root_2);
				adaptor.addChild(root_2, stream_rows.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitCreationSquareBrace();
		}
		return retval;
	}
	// $ANTLR end "regularArray"


	public static class rows_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rows"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:1: rows : row ( ( SEMICOLON | EOL ) row )* -> ( row )+ ;
	public final MatlabParser.rows_return rows() throws RecognitionException {
		MatlabParser.rows_return retval = new MatlabParser.rows_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SEMICOLON395=null;
		Token EOL396=null;
		ParserRuleReturnScope row394 =null;
		ParserRuleReturnScope row397 =null;

		Object SEMICOLON395_tree=null;
		Object EOL396_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleSubtreeStream stream_row=new RewriteRuleSubtreeStream(adaptor,"rule row");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:6: ( row ( ( SEMICOLON | EOL ) row )* -> ( row )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:8: row ( ( SEMICOLON | EOL ) row )*
			{
			pushFollow(FOLLOW_row_in_rows5444);
			row394=row();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_row.add(row394.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:12: ( ( SEMICOLON | EOL ) row )*
			loop105:
			while (true) {
				int alt105=2;
				int LA105_0 = input.LA(1);
				if ( (LA105_0==EOL||LA105_0==SEMICOLON) ) {
					alt105=1;
				}

				switch (alt105) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:13: ( SEMICOLON | EOL ) row
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:13: ( SEMICOLON | EOL )
					int alt104=2;
					int LA104_0 = input.LA(1);
					if ( (LA104_0==SEMICOLON) ) {
						alt104=1;
					}
					else if ( (LA104_0==EOL) ) {
						alt104=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 104, 0, input);
						throw nvae;
					}

					switch (alt104) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:14: SEMICOLON
							{
							SEMICOLON395=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_rows5448); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON395);

							}
							break;
						case 2 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:26: EOL
							{
							EOL396=(Token)match(input,EOL,FOLLOW_EOL_in_rows5452); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EOL.add(EOL396);

							}
							break;

					}

					pushFollow(FOLLOW_row_in_rows5455);
					row397=row();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_row.add(row397.getTree());
					}
					break;

				default :
					break loop105;
				}
			}

			// AST REWRITE
			// elements: row
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 536:37: -> ( row )+
			{
				if ( !(stream_row.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_row.hasNext() ) {
					adaptor.addChild(root_0, stream_row.nextTree());
				}
				stream_row.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rows"


	public static class row_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "row"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:1: row : ( ( COMMA )? columns ( COMMA )? -> ^( HCAT[\"\"] columns ) | COMMA -> HCAT[\"\"] | () -> HCAT[\"\"] );
	public final MatlabParser.row_return row() throws RecognitionException {
		MatlabParser.row_return retval = new MatlabParser.row_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA398=null;
		Token COMMA400=null;
		Token COMMA401=null;
		ParserRuleReturnScope columns399 =null;

		Object COMMA398_tree=null;
		Object COMMA400_tree=null;
		Object COMMA401_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_columns=new RewriteRuleSubtreeStream(adaptor,"rule columns");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:5: ( ( COMMA )? columns ( COMMA )? -> ^( HCAT[\"\"] columns ) | COMMA -> HCAT[\"\"] | () -> HCAT[\"\"] )
			int alt108=3;
			int LA108_0 = input.LA(1);
			if ( (LA108_0==COMMA) ) {
				switch ( input.LA(2) ) {
				case NOT:
					{
					alt108=1;
					}
					break;
				case AT:
				case END:
				case ID:
				case IMAGINARY:
				case LCURLY:
				case LPAREN:
				case LSQUARE:
				case MINUS:
				case PLUS:
				case QUESTION:
				case REAL:
				case STRING:
					{
					alt108=1;
					}
					break;
				case EOL:
				case RCURLY:
				case RSQUARE:
				case SEMICOLON:
					{
					alt108=2;
					}
					break;
				default:
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 108, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}
			}
			else if ( (LA108_0==ID||LA108_0==IMAGINARY||LA108_0==LCURLY||(LA108_0 >= LPAREN && LA108_0 <= LSQUARE)||LA108_0==MINUS||LA108_0==NOT||LA108_0==PLUS||LA108_0==REAL||LA108_0==STRING) ) {
				alt108=1;
			}
			else if ( (LA108_0==END) && ((Index_IsActive()))) {
				alt108=1;
			}
			else if ( (LA108_0==AT||LA108_0==QUESTION) ) {
				alt108=1;
			}
			else if ( (LA108_0==EOL||LA108_0==RCURLY||(LA108_0 >= RSQUARE && LA108_0 <= SEMICOLON)) ) {
				alt108=3;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 108, 0, input);
				throw nvae;
			}

			switch (alt108) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:7: ( COMMA )? columns ( COMMA )?
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:7: ( COMMA )?
					int alt106=2;
					int LA106_0 = input.LA(1);
					if ( (LA106_0==COMMA) ) {
						alt106=1;
					}
					switch (alt106) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:8: COMMA
							{
							COMMA398=(Token)match(input,COMMA,FOLLOW_COMMA_in_row5474); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA398);

							}
							break;

					}

					pushFollow(FOLLOW_columns_in_row5478);
					columns399=columns();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_columns.add(columns399.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:24: ( COMMA )?
					int alt107=2;
					int LA107_0 = input.LA(1);
					if ( (LA107_0==COMMA) ) {
						alt107=1;
					}
					switch (alt107) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:25: COMMA
							{
							COMMA400=(Token)match(input,COMMA,FOLLOW_COMMA_in_row5481); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA400);

							}
							break;

					}

					// AST REWRITE
					// elements: columns
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 538:33: -> ^( HCAT[\"\"] columns )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:36: ^( HCAT[\"\"] columns )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(HCAT, ""), root_1);
						adaptor.addChild(root_1, stream_columns.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:539:4: COMMA
					{
					COMMA401=(Token)match(input,COMMA,FOLLOW_COMMA_in_row5497); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA401);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 539:10: -> HCAT[\"\"]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(HCAT, ""));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:540:4: ()
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:540:4: ()
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:540:5: 
					{
					}

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 540:7: -> HCAT[\"\"]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(HCAT, ""));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "row"


	public static class columns_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "columns"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:1: columns : column ({...}? => ( COMMA )? column )* -> ( column )+ ;
	public final MatlabParser.columns_return columns() throws RecognitionException {
		MatlabParser.columns_return retval = new MatlabParser.columns_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA403=null;
		ParserRuleReturnScope column402 =null;
		ParserRuleReturnScope column404 =null;

		Object COMMA403_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_column=new RewriteRuleSubtreeStream(adaptor,"rule column");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:9: ( column ({...}? => ( COMMA )? column )* -> ( column )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:11: column ({...}? => ( COMMA )? column )*
			{
			pushFollow(FOLLOW_column_in_columns5523);
			column402=column();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_column.add(column402.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:18: ({...}? => ( COMMA )? column )*
			loop110:
			while (true) {
				int alt110=2;
				int LA110_0 = input.LA(1);
				if ( (LA110_0==COMMA) ) {
					int LA110_1 = input.LA(2);
					if ( (LA110_1==NOT) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
						alt110=1;
					}
					else if ( (LA110_1==AT||LA110_1==END||LA110_1==ID||LA110_1==IMAGINARY||LA110_1==LCURLY||(LA110_1 >= LPAREN && LA110_1 <= LSQUARE)||LA110_1==MINUS||LA110_1==PLUS||LA110_1==QUESTION||LA110_1==REAL||LA110_1==STRING) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
						alt110=1;
					}

				}
				else if ( (LA110_0==ID||LA110_0==IMAGINARY||LA110_0==LCURLY||(LA110_0 >= LPAREN && LA110_0 <= LSQUARE)||LA110_0==MINUS||LA110_0==NOT||LA110_0==PLUS||LA110_0==REAL||LA110_0==STRING) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
					alt110=1;
				}
				else if ( (LA110_0==END) && (((Index_IsActive())&&(Separator_CommaFollowsOrSpacesPrecede())))) {
					alt110=1;
				}
				else if ( (LA110_0==AT||LA110_0==QUESTION) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
					alt110=1;
				}

				switch (alt110) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:19: {...}? => ( COMMA )? column
					{
					if ( !((Separator_CommaFollowsOrSpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "columns", "Separator_CommaFollowsOrSpacesPrecede()");
					}
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:64: ( COMMA )?
					int alt109=2;
					int LA109_0 = input.LA(1);
					if ( (LA109_0==COMMA) ) {
						alt109=1;
					}
					switch (alt109) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:65: COMMA
							{
							COMMA403=(Token)match(input,COMMA,FOLLOW_COMMA_in_columns5530); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA403);

							}
							break;

					}

					pushFollow(FOLLOW_column_in_columns5534);
					column404=column();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column.add(column404.getTree());
					}
					break;

				default :
					break loop110;
				}
			}

			// AST REWRITE
			// elements: column
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 543:82: -> ( column )+
			{
				if ( !(stream_column.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_column.hasNext() ) {
					adaptor.addChild(root_0, stream_column.nextTree());
				}
				stream_column.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "columns"


	public static class column_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "column"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:1: column : ( ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )=> NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) | expression -> expression );
	public final MatlabParser.column_return column() throws RecognitionException {
		MatlabParser.column_return retval = new MatlabParser.column_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token NOT405=null;
		ParserRuleReturnScope expression406 =null;

		Object NOT405_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:8: ( ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )=> NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) | expression -> expression )
			int alt111=2;
			int LA111_0 = input.LA(1);
			if ( (LA111_0==NOT) ) {
				int LA111_1 = input.LA(2);
				if ( (synpred10_MatlabParser()) ) {
					alt111=1;
				}
				else if ( (true) ) {
					alt111=2;
				}

			}
			else if ( (LA111_0==ID||LA111_0==IMAGINARY||LA111_0==LCURLY||(LA111_0 >= LPAREN && LA111_0 <= LSQUARE)||LA111_0==MINUS||LA111_0==PLUS||LA111_0==REAL||LA111_0==STRING) ) {
				alt111=2;
			}
			else if ( (LA111_0==END) && ((Index_IsActive()))) {
				alt111=2;
			}
			else if ( (LA111_0==AT||LA111_0==QUESTION) ) {
				alt111=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 111, 0, input);
				throw nvae;
			}

			switch (alt111) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:10: ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )=> NOT
					{
					NOT405=(Token)match(input,NOT,FOLLOW_NOT_in_column5573); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT405);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 545:58: -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:61: ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_1);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:71: ^( NAME[\"\"] ID[$NOT] )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_2);
						adaptor.addChild(root_2, (Object)adaptor.create(ID, NOT405));
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:546:7: expression
					{
					pushFollow(FOLLOW_expression_in_column5596);
					expression406=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression406.getTree());
					// AST REWRITE
					// elements: expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 546:18: -> expression
					{
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "column"


	public static class cellArray_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cellArray"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:551:1: cellArray : LCURLY rows RCURLY -> ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) ) ;
	public final MatlabParser.cellArray_return cellArray() throws RecognitionException {
		MatlabParser.cellArray_return retval = new MatlabParser.cellArray_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LCURLY407=null;
		Token RCURLY409=null;
		ParserRuleReturnScope rows408 =null;

		Object LCURLY407_tree=null;
		Object RCURLY409_tree=null;
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_rows=new RewriteRuleSubtreeStream(adaptor,"rule rows");

		Balance_EnterCreationCurlyBrace();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:552:44: ( LCURLY rows RCURLY -> ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:553:1: LCURLY rows RCURLY
			{
			LCURLY407=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_cellArray5620); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY407);

			pushFollow(FOLLOW_rows_in_cellArray5622);
			rows408=rows();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_rows.add(rows408.getTree());
			RCURLY409=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_cellArray5624); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY409);

			// AST REWRITE
			// elements: rows
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 553:20: -> ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:553:23: ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CELLARRAY, LCURLY407), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:553:44: ^( VCAT[\"\"] rows )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(VCAT, ""), root_2);
				adaptor.addChild(root_2, stream_rows.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitCreationCurlyBrace();
		}
		return retval;
	}
	// $ANTLR end "cellArray"


	public static class parenthesized_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parenthesized"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:558:1: parenthesized : LPAREN expression RPAREN -> expression ;
	public final MatlabParser.parenthesized_return parenthesized() throws RecognitionException {
		MatlabParser.parenthesized_return retval = new MatlabParser.parenthesized_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN410=null;
		Token RPAREN412=null;
		ParserRuleReturnScope expression411 =null;

		Object LPAREN410_tree=null;
		Object RPAREN412_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		Balance_EnterParenthesis();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:559:37: ( LPAREN expression RPAREN -> expression )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:560:1: LPAREN expression RPAREN
			{
			LPAREN410=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized5658); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN410);

			pushFollow(FOLLOW_expression_in_parenthesized5660);
			expression411=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression411.getTree());
			RPAREN412=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized5662); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN412);

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 560:26: -> expression
			{
				adaptor.addChild(root_0, stream_expression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitParenthesis();
		}
		return retval;
	}
	// $ANTLR end "parenthesized"


	public static class end_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "end"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:565:1: end :{...}? => END -> END ;
	public final MatlabParser.end_return end() throws RecognitionException {
		MatlabParser.end_return retval = new MatlabParser.end_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END413=null;

		Object END413_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:565:5: ({...}? => END -> END )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:565:7: {...}? => END
			{
			if ( !((Index_IsActive())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "end", "Index_IsActive()");
			}
			END413=(Token)match(input,END,FOLLOW_END_in_end5684); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END413);

			// AST REWRITE
			// elements: END
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 565:33: -> END
			{
				adaptor.addChild(root_0, stream_END.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "end"


	public static class functionHandle_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionHandle"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:569:1: functionHandle : AT functionReference -> ^( FUNCTIONHANDLE[$AT] functionReference ) ;
	public final MatlabParser.functionHandle_return functionHandle() throws RecognitionException {
		MatlabParser.functionHandle_return retval = new MatlabParser.functionHandle_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AT414=null;
		ParserRuleReturnScope functionReference415 =null;

		Object AT414_tree=null;
		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_functionReference=new RewriteRuleSubtreeStream(adaptor,"rule functionReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:569:16: ( AT functionReference -> ^( FUNCTIONHANDLE[$AT] functionReference ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:569:18: AT functionReference
			{
			AT414=(Token)match(input,AT,FOLLOW_AT_in_functionHandle5699); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_AT.add(AT414);

			pushFollow(FOLLOW_functionReference_in_functionHandle5701);
			functionReference415=functionReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_functionReference.add(functionReference415.getTree());
			// AST REWRITE
			// elements: functionReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 569:39: -> ^( FUNCTIONHANDLE[$AT] functionReference )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:569:42: ^( FUNCTIONHANDLE[$AT] functionReference )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNCTIONHANDLE, AT414), root_1);
				adaptor.addChild(root_1, stream_functionReference.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionHandle"


	public static class functionReference_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionReference"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:571:1: functionReference : fullFunctioName -> ^( FUNCTIONREF[\"\"] fullFunctioName ) ;
	public final MatlabParser.functionReference_return functionReference() throws RecognitionException {
		MatlabParser.functionReference_return retval = new MatlabParser.functionReference_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope fullFunctioName416 =null;

		RewriteRuleSubtreeStream stream_fullFunctioName=new RewriteRuleSubtreeStream(adaptor,"rule fullFunctioName");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:571:19: ( fullFunctioName -> ^( FUNCTIONREF[\"\"] fullFunctioName ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:571:21: fullFunctioName
			{
			pushFollow(FOLLOW_fullFunctioName_in_functionReference5719);
			fullFunctioName416=fullFunctioName();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_fullFunctioName.add(fullFunctioName416.getTree());
			// AST REWRITE
			// elements: fullFunctioName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 571:37: -> ^( FUNCTIONREF[\"\"] fullFunctioName )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:571:40: ^( FUNCTIONREF[\"\"] fullFunctioName )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNCTIONREF, ""), root_1);
				adaptor.addChild(root_1, stream_fullFunctioName.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionReference"


	public static class fullFunctioName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "fullFunctioName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:1: fullFunctioName : xID ( DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) ;
	public final MatlabParser.fullFunctioName_return fullFunctioName() throws RecognitionException {
		MatlabParser.fullFunctioName_return retval = new MatlabParser.fullFunctioName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT418=null;
		ParserRuleReturnScope xID417 =null;
		ParserRuleReturnScope xANYID419 =null;

		Object DOT418_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_xANYID=new RewriteRuleSubtreeStream(adaptor,"rule xANYID");
		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:17: ( xID ( DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:19: xID ( DOT xANYID )*
			{
			pushFollow(FOLLOW_xID_in_fullFunctioName5737);
			xID417=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID417.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:23: ( DOT xANYID )*
			loop112:
			while (true) {
				int alt112=2;
				int LA112_0 = input.LA(1);
				if ( (LA112_0==DOT) ) {
					alt112=1;
				}

				switch (alt112) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:24: DOT xANYID
					{
					DOT418=(Token)match(input,DOT,FOLLOW_DOT_in_fullFunctioName5740); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DOT.add(DOT418);

					pushFollow(FOLLOW_xANYID_in_fullFunctioName5742);
					xANYID419=xANYID();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xANYID.add(xANYID419.getTree());
					}
					break;

				default :
					break loop112;
				}
			}

			// AST REWRITE
			// elements: xANYID, xID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 573:37: -> ^( NAME[\"\"] xID ( xANYID )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:40: ^( NAME[\"\"] xID ( xANYID )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:55: ( xANYID )*
				while ( stream_xANYID.hasNext() ) {
					adaptor.addChild(root_1, stream_xANYID.nextTree());
				}
				stream_xANYID.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "fullFunctioName"


	public static class anonymousFunction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "anonymousFunction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:1: anonymousFunction : AT inputPortion expression -> ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression ) ;
	public final MatlabParser.anonymousFunction_return anonymousFunction() throws RecognitionException {
		MatlabParser.anonymousFunction_return retval = new MatlabParser.anonymousFunction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AT420=null;
		ParserRuleReturnScope inputPortion421 =null;
		ParserRuleReturnScope expression422 =null;

		Object AT420_tree=null;
		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:19: ( AT inputPortion expression -> ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:21: AT inputPortion expression
			{
			AT420=(Token)match(input,AT,FOLLOW_AT_in_anonymousFunction5769); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_AT.add(AT420);

			pushFollow(FOLLOW_inputPortion_in_anonymousFunction5771);
			inputPortion421=inputPortion();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion421.getTree());
			pushFollow(FOLLOW_expression_in_anonymousFunction5773);
			expression422=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression422.getTree());
			// AST REWRITE
			// elements: inputPortion, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 577:48: -> ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:51: ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ANONYMOUSFUNCTION, AT420), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:76: ( inputPortion )?
				if ( stream_inputPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_inputPortion.nextTree());
				}
				stream_inputPortion.reset();

				adaptor.addChild(root_1, stream_expression.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "anonymousFunction"


	public static class metaclass_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "metaclass"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:581:1: metaclass : QUESTION classReference -> ^( QUESTION classReference ) ;
	public final MatlabParser.metaclass_return metaclass() throws RecognitionException {
		MatlabParser.metaclass_return retval = new MatlabParser.metaclass_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token QUESTION423=null;
		ParserRuleReturnScope classReference424 =null;

		Object QUESTION423_tree=null;
		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:581:11: ( QUESTION classReference -> ^( QUESTION classReference ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:581:13: QUESTION classReference
			{
			QUESTION423=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_metaclass5798); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION423);

			pushFollow(FOLLOW_classReference_in_metaclass5800);
			classReference424=classReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classReference.add(classReference424.getTree());
			// AST REWRITE
			// elements: QUESTION, classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 581:37: -> ^( QUESTION classReference )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:581:40: ^( QUESTION classReference )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_QUESTION.nextNode(), root_1);
				adaptor.addChild(root_1, stream_classReference.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "metaclass"


	public static class xEOS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xEOS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:585:1: xEOS : ( SEMICOLON -> NOPRINT[$SEMICOLON] | COMMA -> PRINT[$COMMA] | EOL -> PRINT[$EOL] );
	public final MatlabParser.xEOS_return xEOS() throws RecognitionException {
		MatlabParser.xEOS_return retval = new MatlabParser.xEOS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SEMICOLON425=null;
		Token COMMA426=null;
		Token EOL427=null;

		Object SEMICOLON425_tree=null;
		Object COMMA426_tree=null;
		Object EOL427_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:585:6: ( SEMICOLON -> NOPRINT[$SEMICOLON] | COMMA -> PRINT[$COMMA] | EOL -> PRINT[$EOL] )
			int alt113=3;
			switch ( input.LA(1) ) {
			case SEMICOLON:
				{
				alt113=1;
				}
				break;
			case COMMA:
				{
				alt113=2;
				}
				break;
			case EOL:
				{
				alt113=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 113, 0, input);
				throw nvae;
			}
			switch (alt113) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:585:8: SEMICOLON
					{
					SEMICOLON425=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_xEOS5819); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON425);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 585:18: -> NOPRINT[$SEMICOLON]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(NOPRINT, SEMICOLON425));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:586:5: COMMA
					{
					COMMA426=(Token)match(input,COMMA,FOLLOW_COMMA_in_xEOS5830); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA426);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 586:11: -> PRINT[$COMMA]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(PRINT, COMMA426));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:587:5: EOL
					{
					EOL427=(Token)match(input,EOL,FOLLOW_EOL_in_xEOS5841); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL427);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 587:9: -> PRINT[$EOL]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(PRINT, EOL427));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xEOS"


	public static class xEOL_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xEOL"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:590:1: xEOL : EOL -> PRINT[$EOL] ;
	public final MatlabParser.xEOL_return xEOL() throws RecognitionException {
		MatlabParser.xEOL_return retval = new MatlabParser.xEOL_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL428=null;

		Object EOL428_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:590:6: ( EOL -> PRINT[$EOL] )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:590:8: EOL
			{
			EOL428=(Token)match(input,EOL,FOLLOW_EOL_in_xEOL5857); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOL.add(EOL428);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 590:12: -> PRINT[$EOL]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PRINT, EOL428));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xEOL"


	public static class xID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:592:1: xID : ID -> ID ;
	public final MatlabParser.xID_return xID() throws RecognitionException {
		MatlabParser.xID_return retval = new MatlabParser.xID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID429=null;

		Object ID429_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:592:5: ( ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:592:7: ID
			{
			ID429=(Token)match(input,ID,FOLLOW_ID_in_xID5871); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID429);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 592:10: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xID"


	public static class xANYID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xANYID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:594:1: xANYID : ( ID -> ID | BREAK -> ID[$BREAK] | CASE -> ID[$CASE] | CATCH -> ID[$CATCH] | CLASSDEF -> ID[$CLASSDEF] | CONTINUE -> ID[$CONTINUE] | ELSE -> ID[$ELSE] | ELSEIF -> ID[$ELSEIF] | END -> ID[$END] | FOR -> ID[$FOR] | FUNCTION -> ID[$FUNCTION] | GLOBAL -> ID[$GLOBAL] | IF -> ID[$IF] | OTHERWISE -> ID[$OTHERWISE] | PARFOR -> ID[$PARFOR] | PERSISTENT -> ID[$PERSISTENT] | RETURN -> ID[$RETURN] | SPMD -> ID[$SPMD] | SWITCH -> ID[$SWITCH] | TRY -> ID[$TRY] | WHILE -> ID[$WHILE] );
	public final MatlabParser.xANYID_return xANYID() throws RecognitionException {
		MatlabParser.xANYID_return retval = new MatlabParser.xANYID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID430=null;
		Token BREAK431=null;
		Token CASE432=null;
		Token CATCH433=null;
		Token CLASSDEF434=null;
		Token CONTINUE435=null;
		Token ELSE436=null;
		Token ELSEIF437=null;
		Token END438=null;
		Token FOR439=null;
		Token FUNCTION440=null;
		Token GLOBAL441=null;
		Token IF442=null;
		Token OTHERWISE443=null;
		Token PARFOR444=null;
		Token PERSISTENT445=null;
		Token RETURN446=null;
		Token SPMD447=null;
		Token SWITCH448=null;
		Token TRY449=null;
		Token WHILE450=null;

		Object ID430_tree=null;
		Object BREAK431_tree=null;
		Object CASE432_tree=null;
		Object CATCH433_tree=null;
		Object CLASSDEF434_tree=null;
		Object CONTINUE435_tree=null;
		Object ELSE436_tree=null;
		Object ELSEIF437_tree=null;
		Object END438_tree=null;
		Object FOR439_tree=null;
		Object FUNCTION440_tree=null;
		Object GLOBAL441_tree=null;
		Object IF442_tree=null;
		Object OTHERWISE443_tree=null;
		Object PARFOR444_tree=null;
		Object PERSISTENT445_tree=null;
		Object RETURN446_tree=null;
		Object SPMD447_tree=null;
		Object SWITCH448_tree=null;
		Object TRY449_tree=null;
		Object WHILE450_tree=null;
		RewriteRuleTokenStream stream_ELSEIF=new RewriteRuleTokenStream(adaptor,"token ELSEIF");
		RewriteRuleTokenStream stream_PERSISTENT=new RewriteRuleTokenStream(adaptor,"token PERSISTENT");
		RewriteRuleTokenStream stream_CLASSDEF=new RewriteRuleTokenStream(adaptor,"token CLASSDEF");
		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,"token FOR");
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleTokenStream stream_CASE=new RewriteRuleTokenStream(adaptor,"token CASE");
		RewriteRuleTokenStream stream_CONTINUE=new RewriteRuleTokenStream(adaptor,"token CONTINUE");
		RewriteRuleTokenStream stream_RETURN=new RewriteRuleTokenStream(adaptor,"token RETURN");
		RewriteRuleTokenStream stream_SPMD=new RewriteRuleTokenStream(adaptor,"token SPMD");
		RewriteRuleTokenStream stream_CATCH=new RewriteRuleTokenStream(adaptor,"token CATCH");
		RewriteRuleTokenStream stream_PARFOR=new RewriteRuleTokenStream(adaptor,"token PARFOR");
		RewriteRuleTokenStream stream_BREAK=new RewriteRuleTokenStream(adaptor,"token BREAK");
		RewriteRuleTokenStream stream_GLOBAL=new RewriteRuleTokenStream(adaptor,"token GLOBAL");
		RewriteRuleTokenStream stream_OTHERWISE=new RewriteRuleTokenStream(adaptor,"token OTHERWISE");
		RewriteRuleTokenStream stream_ELSE=new RewriteRuleTokenStream(adaptor,"token ELSE");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_SWITCH=new RewriteRuleTokenStream(adaptor,"token SWITCH");
		RewriteRuleTokenStream stream_TRY=new RewriteRuleTokenStream(adaptor,"token TRY");
		RewriteRuleTokenStream stream_WHILE=new RewriteRuleTokenStream(adaptor,"token WHILE");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");
		RewriteRuleTokenStream stream_IF=new RewriteRuleTokenStream(adaptor,"token IF");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:594:8: ( ID -> ID | BREAK -> ID[$BREAK] | CASE -> ID[$CASE] | CATCH -> ID[$CATCH] | CLASSDEF -> ID[$CLASSDEF] | CONTINUE -> ID[$CONTINUE] | ELSE -> ID[$ELSE] | ELSEIF -> ID[$ELSEIF] | END -> ID[$END] | FOR -> ID[$FOR] | FUNCTION -> ID[$FUNCTION] | GLOBAL -> ID[$GLOBAL] | IF -> ID[$IF] | OTHERWISE -> ID[$OTHERWISE] | PARFOR -> ID[$PARFOR] | PERSISTENT -> ID[$PERSISTENT] | RETURN -> ID[$RETURN] | SPMD -> ID[$SPMD] | SWITCH -> ID[$SWITCH] | TRY -> ID[$TRY] | WHILE -> ID[$WHILE] )
			int alt114=21;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt114=1;
				}
				break;
			case BREAK:
				{
				alt114=2;
				}
				break;
			case CASE:
				{
				alt114=3;
				}
				break;
			case CATCH:
				{
				alt114=4;
				}
				break;
			case CLASSDEF:
				{
				alt114=5;
				}
				break;
			case CONTINUE:
				{
				alt114=6;
				}
				break;
			case ELSE:
				{
				alt114=7;
				}
				break;
			case ELSEIF:
				{
				alt114=8;
				}
				break;
			case END:
				{
				alt114=9;
				}
				break;
			case FOR:
				{
				alt114=10;
				}
				break;
			case FUNCTION:
				{
				alt114=11;
				}
				break;
			case GLOBAL:
				{
				alt114=12;
				}
				break;
			case IF:
				{
				alt114=13;
				}
				break;
			case OTHERWISE:
				{
				alt114=14;
				}
				break;
			case PARFOR:
				{
				alt114=15;
				}
				break;
			case PERSISTENT:
				{
				alt114=16;
				}
				break;
			case RETURN:
				{
				alt114=17;
				}
				break;
			case SPMD:
				{
				alt114=18;
				}
				break;
			case SWITCH:
				{
				alt114=19;
				}
				break;
			case TRY:
				{
				alt114=20;
				}
				break;
			case WHILE:
				{
				alt114=21;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 114, 0, input);
				throw nvae;
			}
			switch (alt114) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:594:10: ID
					{
					ID430=(Token)match(input,ID,FOLLOW_ID_in_xANYID5884); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(ID430);

					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 594:13: -> ID
					{
						adaptor.addChild(root_0, stream_ID.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:595:7: BREAK
					{
					BREAK431=(Token)match(input,BREAK,FOLLOW_BREAK_in_xANYID5896); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_BREAK.add(BREAK431);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 595:13: -> ID[$BREAK]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, BREAK431));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:596:7: CASE
					{
					CASE432=(Token)match(input,CASE,FOLLOW_CASE_in_xANYID5909); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CASE.add(CASE432);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 596:12: -> ID[$CASE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, CASE432));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:597:7: CATCH
					{
					CATCH433=(Token)match(input,CATCH,FOLLOW_CATCH_in_xANYID5922); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CATCH.add(CATCH433);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 597:13: -> ID[$CATCH]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, CATCH433));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:598:7: CLASSDEF
					{
					CLASSDEF434=(Token)match(input,CLASSDEF,FOLLOW_CLASSDEF_in_xANYID5935); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CLASSDEF.add(CLASSDEF434);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 598:16: -> ID[$CLASSDEF]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, CLASSDEF434));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:599:7: CONTINUE
					{
					CONTINUE435=(Token)match(input,CONTINUE,FOLLOW_CONTINUE_in_xANYID5948); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CONTINUE.add(CONTINUE435);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 599:16: -> ID[$CONTINUE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, CONTINUE435));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:600:7: ELSE
					{
					ELSE436=(Token)match(input,ELSE,FOLLOW_ELSE_in_xANYID5961); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ELSE.add(ELSE436);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 600:12: -> ID[$ELSE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, ELSE436));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:601:7: ELSEIF
					{
					ELSEIF437=(Token)match(input,ELSEIF,FOLLOW_ELSEIF_in_xANYID5974); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ELSEIF.add(ELSEIF437);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 601:14: -> ID[$ELSEIF]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, ELSEIF437));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:602:7: END
					{
					END438=(Token)match(input,END,FOLLOW_END_in_xANYID5987); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_END.add(END438);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 602:11: -> ID[$END]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, END438));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:603:7: FOR
					{
					FOR439=(Token)match(input,FOR,FOLLOW_FOR_in_xANYID6000); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_FOR.add(FOR439);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 603:11: -> ID[$FOR]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, FOR439));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:604:7: FUNCTION
					{
					FUNCTION440=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_xANYID6013); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION440);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 604:16: -> ID[$FUNCTION]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, FUNCTION440));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 12 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:605:7: GLOBAL
					{
					GLOBAL441=(Token)match(input,GLOBAL,FOLLOW_GLOBAL_in_xANYID6026); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_GLOBAL.add(GLOBAL441);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 605:14: -> ID[$GLOBAL]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, GLOBAL441));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 13 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:606:7: IF
					{
					IF442=(Token)match(input,IF,FOLLOW_IF_in_xANYID6039); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_IF.add(IF442);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 606:10: -> ID[$IF]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, IF442));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 14 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:607:7: OTHERWISE
					{
					OTHERWISE443=(Token)match(input,OTHERWISE,FOLLOW_OTHERWISE_in_xANYID6052); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OTHERWISE.add(OTHERWISE443);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 607:17: -> ID[$OTHERWISE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, OTHERWISE443));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 15 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:608:7: PARFOR
					{
					PARFOR444=(Token)match(input,PARFOR,FOLLOW_PARFOR_in_xANYID6065); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PARFOR.add(PARFOR444);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 608:14: -> ID[$PARFOR]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, PARFOR444));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 16 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:609:7: PERSISTENT
					{
					PERSISTENT445=(Token)match(input,PERSISTENT,FOLLOW_PERSISTENT_in_xANYID6078); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PERSISTENT.add(PERSISTENT445);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 609:18: -> ID[$PERSISTENT]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, PERSISTENT445));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 17 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:610:7: RETURN
					{
					RETURN446=(Token)match(input,RETURN,FOLLOW_RETURN_in_xANYID6091); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RETURN.add(RETURN446);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 610:14: -> ID[$RETURN]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, RETURN446));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 18 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:611:7: SPMD
					{
					SPMD447=(Token)match(input,SPMD,FOLLOW_SPMD_in_xANYID6104); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SPMD.add(SPMD447);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 611:12: -> ID[$SPMD]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, SPMD447));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 19 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:612:7: SWITCH
					{
					SWITCH448=(Token)match(input,SWITCH,FOLLOW_SWITCH_in_xANYID6117); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SWITCH.add(SWITCH448);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 612:14: -> ID[$SWITCH]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, SWITCH448));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 20 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:613:7: TRY
					{
					TRY449=(Token)match(input,TRY,FOLLOW_TRY_in_xANYID6130); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_TRY.add(TRY449);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 613:11: -> ID[$TRY]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, TRY449));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 21 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:614:7: WHILE
					{
					WHILE450=(Token)match(input,WHILE,FOLLOW_WHILE_in_xANYID6143); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_WHILE.add(WHILE450);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 614:13: -> ID[$WHILE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, WHILE450));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xANYID"


	public static class xFUNCTIONID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xFUNCTIONID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:617:1: xFUNCTIONID : ( ID -> ID | END -> ID[$END] );
	public final MatlabParser.xFUNCTIONID_return xFUNCTIONID() throws RecognitionException {
		MatlabParser.xFUNCTIONID_return retval = new MatlabParser.xFUNCTIONID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID451=null;
		Token END452=null;

		Object ID451_tree=null;
		Object END452_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:617:13: ( ID -> ID | END -> ID[$END] )
			int alt115=2;
			int LA115_0 = input.LA(1);
			if ( (LA115_0==ID) ) {
				alt115=1;
			}
			else if ( (LA115_0==END) ) {
				alt115=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 115, 0, input);
				throw nvae;
			}

			switch (alt115) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:617:15: ID
					{
					ID451=(Token)match(input,ID,FOLLOW_ID_in_xFUNCTIONID6161); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(ID451);

					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 617:18: -> ID
					{
						adaptor.addChild(root_0, stream_ID.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:618:6: END
					{
					END452=(Token)match(input,END,FOLLOW_END_in_xFUNCTIONID6172); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_END.add(END452);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 618:10: -> ID[$END]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, END452));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xFUNCTIONID"


	public static class xPARAMETERID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xPARAMETERID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:621:1: xPARAMETERID : ( ID -> ID | NOT -> ID[$NOT] );
	public final MatlabParser.xPARAMETERID_return xPARAMETERID() throws RecognitionException {
		MatlabParser.xPARAMETERID_return retval = new MatlabParser.xPARAMETERID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID453=null;
		Token NOT454=null;

		Object ID453_tree=null;
		Object NOT454_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:621:14: ( ID -> ID | NOT -> ID[$NOT] )
			int alt116=2;
			int LA116_0 = input.LA(1);
			if ( (LA116_0==ID) ) {
				alt116=1;
			}
			else if ( (LA116_0==NOT) ) {
				alt116=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 116, 0, input);
				throw nvae;
			}

			switch (alt116) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:621:16: ID
					{
					ID453=(Token)match(input,ID,FOLLOW_ID_in_xPARAMETERID6189); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(ID453);

					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 621:19: -> ID
					{
						adaptor.addChild(root_0, stream_ID.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:622:7: NOT
					{
					NOT454=(Token)match(input,NOT,FOLLOW_NOT_in_xPARAMETERID6201); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT454);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 622:11: -> ID[$NOT]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, NOT454));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xPARAMETERID"


	public static class xEVENTS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xEVENTS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:625:1: xEVENTS :{...}? => ID -> ID ;
	public final MatlabParser.xEVENTS_return xEVENTS() throws RecognitionException {
		MatlabParser.xEVENTS_return retval = new MatlabParser.xEVENTS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID455=null;

		Object ID455_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:625:9: ({...}? => ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:625:11: {...}? => ID
			{
			if ( !((Keyword_EventsIdFollows())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xEVENTS", "Keyword_EventsIdFollows()");
			}
			ID455=(Token)match(input,ID,FOLLOW_ID_in_xEVENTS6222); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID455);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 625:45: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xEVENTS"


	public static class xPROPERTIES_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xPROPERTIES"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:627:1: xPROPERTIES :{...}? => ID -> ID ;
	public final MatlabParser.xPROPERTIES_return xPROPERTIES() throws RecognitionException {
		MatlabParser.xPROPERTIES_return retval = new MatlabParser.xPROPERTIES_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID456=null;

		Object ID456_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:627:13: ({...}? => ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:627:15: {...}? => ID
			{
			if ( !((Keyword_PropertiesIdFollows())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xPROPERTIES", "Keyword_PropertiesIdFollows()");
			}
			ID456=(Token)match(input,ID,FOLLOW_ID_in_xPROPERTIES6238); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID456);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 627:53: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xPROPERTIES"


	public static class xMETHODS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xMETHODS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:629:1: xMETHODS :{...}? => ID -> ID ;
	public final MatlabParser.xMETHODS_return xMETHODS() throws RecognitionException {
		MatlabParser.xMETHODS_return retval = new MatlabParser.xMETHODS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID457=null;

		Object ID457_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:629:10: ({...}? => ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:629:12: {...}? => ID
			{
			if ( !((Keyword_MethodsIdFollows())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xMETHODS", "Keyword_MethodsIdFollows()");
			}
			ID457=(Token)match(input,ID,FOLLOW_ID_in_xMETHODS6254); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID457);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 629:47: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xMETHODS"


	public static class xENUMERATION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xENUMERATION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:631:1: xENUMERATION :{...}? => ID -> ID ;
	public final MatlabParser.xENUMERATION_return xENUMERATION() throws RecognitionException {
		MatlabParser.xENUMERATION_return retval = new MatlabParser.xENUMERATION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID458=null;

		Object ID458_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:631:14: ({...}? => ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:631:16: {...}? => ID
			{
			if ( !((Keyword_EnumerationIdFollows())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xENUMERATION", "Keyword_EnumerationIdFollows()");
			}
			ID458=(Token)match(input,ID,FOLLOW_ID_in_xENUMERATION6270); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID458);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 631:55: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xENUMERATION"


	public static class aspectFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:1: aspectFile : ( EOL )* aspectDef ( EOL )* EOF -> ^( ASPECTFILE[\"\"] aspectDef ) ;
	public final MatlabParser.aspectFile_return aspectFile() throws RecognitionException {
		MatlabParser.aspectFile_return retval = new MatlabParser.aspectFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL459=null;
		Token EOL461=null;
		Token EOF462=null;
		ParserRuleReturnScope aspectDef460 =null;

		Object EOL459_tree=null;
		Object EOL461_tree=null;
		Object EOF462_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_aspectDef=new RewriteRuleSubtreeStream(adaptor,"rule aspectDef");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:12: ( ( EOL )* aspectDef ( EOL )* EOF -> ^( ASPECTFILE[\"\"] aspectDef ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:14: ( EOL )* aspectDef ( EOL )* EOF
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:14: ( EOL )*
			loop117:
			while (true) {
				int alt117=2;
				int LA117_0 = input.LA(1);
				if ( (LA117_0==EOL) ) {
					alt117=1;
				}

				switch (alt117) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:15: EOL
					{
					EOL459=(Token)match(input,EOL,FOLLOW_EOL_in_aspectFile6286); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL459);

					}
					break;

				default :
					break loop117;
				}
			}

			pushFollow(FOLLOW_aspectDef_in_aspectFile6290);
			aspectDef460=aspectDef();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectDef.add(aspectDef460.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:31: ( EOL )*
			loop118:
			while (true) {
				int alt118=2;
				int LA118_0 = input.LA(1);
				if ( (LA118_0==EOL) ) {
					alt118=1;
				}

				switch (alt118) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:32: EOL
					{
					EOL461=(Token)match(input,EOL,FOLLOW_EOL_in_aspectFile6293); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL461);

					}
					break;

				default :
					break loop118;
				}
			}

			EOF462=(Token)match(input,EOF,FOLLOW_EOF_in_aspectFile6297); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF462);

			// AST REWRITE
			// elements: aspectDef
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 635:42: -> ^( ASPECTFILE[\"\"] aspectDef )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:45: ^( ASPECTFILE[\"\"] aspectDef )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTFILE, ""), root_1);
				adaptor.addChild(root_1, stream_aspectDef.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectFile"


	public static class aspectDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:1: aspectDef : ASPECT name xEOS aspectSections END -> ^( ASPECTDEF name ( aspectSections )? ) ;
	public final MatlabParser.aspectDef_return aspectDef() throws RecognitionException {
		MatlabParser.aspectDef_return retval = new MatlabParser.aspectDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASPECT463=null;
		Token END467=null;
		ParserRuleReturnScope name464 =null;
		ParserRuleReturnScope xEOS465 =null;
		ParserRuleReturnScope aspectSections466 =null;

		Object ASPECT463_tree=null;
		Object END467_tree=null;
		RewriteRuleTokenStream stream_ASPECT=new RewriteRuleTokenStream(adaptor,"token ASPECT");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_aspectSections=new RewriteRuleSubtreeStream(adaptor,"rule aspectSections");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:11: ( ASPECT name xEOS aspectSections END -> ^( ASPECTDEF name ( aspectSections )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:13: ASPECT name xEOS aspectSections END
			{
			ASPECT463=(Token)match(input,ASPECT,FOLLOW_ASPECT_in_aspectDef6315); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASPECT.add(ASPECT463);

			pushFollow(FOLLOW_name_in_aspectDef6317);
			name464=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name464.getTree());
			pushFollow(FOLLOW_xEOS_in_aspectDef6319);
			xEOS465=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS465.getTree());
			pushFollow(FOLLOW_aspectSections_in_aspectDef6321);
			aspectSections466=aspectSections();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectSections.add(aspectSections466.getTree());
			END467=(Token)match(input,END,FOLLOW_END_in_aspectDef6323); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END467);

			// AST REWRITE
			// elements: name, aspectSections
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 637:49: -> ^( ASPECTDEF name ( aspectSections )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:52: ^( ASPECTDEF name ( aspectSections )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTDEF, "ASPECTDEF"), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:69: ( aspectSections )?
				if ( stream_aspectSections.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectSections.nextTree());
				}
				stream_aspectSections.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectDef"


	public static class aspectSections_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSections"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:1: aspectSections : ( aspectSection | xEOS )* -> ( aspectSection )* ;
	public final MatlabParser.aspectSections_return aspectSections() throws RecognitionException {
		MatlabParser.aspectSections_return retval = new MatlabParser.aspectSections_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectSection468 =null;
		ParserRuleReturnScope xEOS469 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_aspectSection=new RewriteRuleSubtreeStream(adaptor,"rule aspectSection");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:16: ( ( aspectSection | xEOS )* -> ( aspectSection )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:18: ( aspectSection | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:18: ( aspectSection | xEOS )*
			loop119:
			while (true) {
				int alt119=3;
				int LA119_0 = input.LA(1);
				if ( (LA119_0==ID) && (((Keyword_IdFollows("patterns"))||(Keyword_EnumerationIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_IdFollows("actions"))||(Keyword_EventsIdFollows())||(Keyword_MethodsIdFollows())))) {
					alt119=1;
				}
				else if ( (LA119_0==COMMA||LA119_0==EOL||LA119_0==SEMICOLON) ) {
					alt119=2;
				}

				switch (alt119) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:19: aspectSection
					{
					pushFollow(FOLLOW_aspectSection_in_aspectSections6346);
					aspectSection468=aspectSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectSection.add(aspectSection468.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:35: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_aspectSections6350);
					xEOS469=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS469.getTree());
					}
					break;

				default :
					break loop119;
				}
			}

			// AST REWRITE
			// elements: aspectSection
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 639:42: -> ( aspectSection )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:45: ( aspectSection )*
				while ( stream_aspectSection.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectSection.nextTree());
				}
				stream_aspectSection.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSections"


	public static class aspectSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:641:1: aspectSection : ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection | aspectPatternSection -> aspectPatternSection | aspectActionSection -> aspectActionSection );
	public final MatlabParser.aspectSection_return aspectSection() throws RecognitionException {
		MatlabParser.aspectSection_return retval = new MatlabParser.aspectSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope eventSection470 =null;
		ParserRuleReturnScope propertySection471 =null;
		ParserRuleReturnScope methodSection472 =null;
		ParserRuleReturnScope enumerationSection473 =null;
		ParserRuleReturnScope aspectPatternSection474 =null;
		ParserRuleReturnScope aspectActionSection475 =null;

		RewriteRuleSubtreeStream stream_propertySection=new RewriteRuleSubtreeStream(adaptor,"rule propertySection");
		RewriteRuleSubtreeStream stream_methodSection=new RewriteRuleSubtreeStream(adaptor,"rule methodSection");
		RewriteRuleSubtreeStream stream_aspectPatternSection=new RewriteRuleSubtreeStream(adaptor,"rule aspectPatternSection");
		RewriteRuleSubtreeStream stream_eventSection=new RewriteRuleSubtreeStream(adaptor,"rule eventSection");
		RewriteRuleSubtreeStream stream_aspectActionSection=new RewriteRuleSubtreeStream(adaptor,"rule aspectActionSection");
		RewriteRuleSubtreeStream stream_enumerationSection=new RewriteRuleSubtreeStream(adaptor,"rule enumerationSection");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:641:15: ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection | aspectPatternSection -> aspectPatternSection | aspectActionSection -> aspectActionSection )
			int alt120=6;
			int LA120_0 = input.LA(1);
			if ( (LA120_0==ID) && (((Keyword_IdFollows("patterns"))||(Keyword_EnumerationIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_IdFollows("actions"))||(Keyword_EventsIdFollows())||(Keyword_MethodsIdFollows())))) {
				int LA120_1 = input.LA(2);
				if ( ((Keyword_EventsIdFollows())) ) {
					alt120=1;
				}
				else if ( ((Keyword_PropertiesIdFollows())) ) {
					alt120=2;
				}
				else if ( ((Keyword_MethodsIdFollows())) ) {
					alt120=3;
				}
				else if ( ((Keyword_EnumerationIdFollows())) ) {
					alt120=4;
				}
				else if ( ((Keyword_IdFollows("patterns"))) ) {
					alt120=5;
				}
				else if ( ((Keyword_IdFollows("actions"))) ) {
					alt120=6;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 120, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt120) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:641:17: eventSection
					{
					pushFollow(FOLLOW_eventSection_in_aspectSection6368);
					eventSection470=eventSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_eventSection.add(eventSection470.getTree());
					// AST REWRITE
					// elements: eventSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 641:30: -> eventSection
					{
						adaptor.addChild(root_0, stream_eventSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:642:8: propertySection
					{
					pushFollow(FOLLOW_propertySection_in_aspectSection6381);
					propertySection471=propertySection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_propertySection.add(propertySection471.getTree());
					// AST REWRITE
					// elements: propertySection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 642:24: -> propertySection
					{
						adaptor.addChild(root_0, stream_propertySection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:643:11: methodSection
					{
					pushFollow(FOLLOW_methodSection_in_aspectSection6397);
					methodSection472=methodSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodSection.add(methodSection472.getTree());
					// AST REWRITE
					// elements: methodSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 643:25: -> methodSection
					{
						adaptor.addChild(root_0, stream_methodSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:644:11: enumerationSection
					{
					pushFollow(FOLLOW_enumerationSection_in_aspectSection6413);
					enumerationSection473=enumerationSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_enumerationSection.add(enumerationSection473.getTree());
					// AST REWRITE
					// elements: enumerationSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 644:30: -> enumerationSection
					{
						adaptor.addChild(root_0, stream_enumerationSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:645:8: aspectPatternSection
					{
					pushFollow(FOLLOW_aspectPatternSection_in_aspectSection6426);
					aspectPatternSection474=aspectPatternSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectPatternSection.add(aspectPatternSection474.getTree());
					// AST REWRITE
					// elements: aspectPatternSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 645:29: -> aspectPatternSection
					{
						adaptor.addChild(root_0, stream_aspectPatternSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:646:8: aspectActionSection
					{
					pushFollow(FOLLOW_aspectActionSection_in_aspectSection6439);
					aspectActionSection475=aspectActionSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectActionSection.add(aspectActionSection475.getTree());
					// AST REWRITE
					// elements: aspectActionSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 646:28: -> aspectActionSection
					{
						adaptor.addChild(root_0, stream_aspectActionSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSection"


	public static class aspectActionSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActionSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:1: aspectActionSection : wACTIONS aspectActions END -> ^( ASPECTACTIONSECTION[$wACTIONS.start] ( aspectActions )? ) ;
	public final MatlabParser.aspectActionSection_return aspectActionSection() throws RecognitionException {
		MatlabParser.aspectActionSection_return retval = new MatlabParser.aspectActionSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END478=null;
		ParserRuleReturnScope wACTIONS476 =null;
		ParserRuleReturnScope aspectActions477 =null;

		Object END478_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_wACTIONS=new RewriteRuleSubtreeStream(adaptor,"rule wACTIONS");
		RewriteRuleSubtreeStream stream_aspectActions=new RewriteRuleSubtreeStream(adaptor,"rule aspectActions");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:21: ( wACTIONS aspectActions END -> ^( ASPECTACTIONSECTION[$wACTIONS.start] ( aspectActions )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:23: wACTIONS aspectActions END
			{
			pushFollow(FOLLOW_wACTIONS_in_aspectActionSection6462);
			wACTIONS476=wACTIONS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wACTIONS.add(wACTIONS476.getTree());
			pushFollow(FOLLOW_aspectActions_in_aspectActionSection6464);
			aspectActions477=aspectActions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectActions.add(aspectActions477.getTree());
			END478=(Token)match(input,END,FOLLOW_END_in_aspectActionSection6466); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END478);

			// AST REWRITE
			// elements: aspectActions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 651:50: -> ^( ASPECTACTIONSECTION[$wACTIONS.start] ( aspectActions )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:53: ^( ASPECTACTIONSECTION[$wACTIONS.start] ( aspectActions )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTACTIONSECTION, (wACTIONS476!=null?(wACTIONS476.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:92: ( aspectActions )?
				if ( stream_aspectActions.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectActions.nextTree());
				}
				stream_aspectActions.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActionSection"


	public static class aspectActions_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActions"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:1: aspectActions : ( aspectAction | xEOS )* -> ( aspectAction )* ;
	public final MatlabParser.aspectActions_return aspectActions() throws RecognitionException {
		MatlabParser.aspectActions_return retval = new MatlabParser.aspectActions_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectAction479 =null;
		ParserRuleReturnScope xEOS480 =null;

		RewriteRuleSubtreeStream stream_aspectAction=new RewriteRuleSubtreeStream(adaptor,"rule aspectAction");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:15: ( ( aspectAction | xEOS )* -> ( aspectAction )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:17: ( aspectAction | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:17: ( aspectAction | xEOS )*
			loop121:
			while (true) {
				int alt121=3;
				int LA121_0 = input.LA(1);
				if ( (LA121_0==ID) ) {
					alt121=1;
				}
				else if ( (LA121_0==COMMA||LA121_0==EOL||LA121_0==SEMICOLON) ) {
					alt121=2;
				}

				switch (alt121) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:18: aspectAction
					{
					pushFollow(FOLLOW_aspectAction_in_aspectActions6488);
					aspectAction479=aspectAction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectAction.add(aspectAction479.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:33: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_aspectActions6492);
					xEOS480=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS480.getTree());
					}
					break;

				default :
					break loop121;
				}
			}

			// AST REWRITE
			// elements: aspectAction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 653:40: -> ( aspectAction )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:43: ( aspectAction )*
				while ( stream_aspectAction.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectAction.nextTree());
				}
				stream_aspectAction.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActions"


	public static class aspectAction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectAction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:1: aspectAction : aspectActionSignature aspectActionBody END -> ^( ASPECTACTION aspectActionSignature ( aspectActionBody )? ) ;
	public final MatlabParser.aspectAction_return aspectAction() throws RecognitionException {
		MatlabParser.aspectAction_return retval = new MatlabParser.aspectAction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END483=null;
		ParserRuleReturnScope aspectActionSignature481 =null;
		ParserRuleReturnScope aspectActionBody482 =null;

		Object END483_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_aspectActionSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectActionSignature");
		RewriteRuleSubtreeStream stream_aspectActionBody=new RewriteRuleSubtreeStream(adaptor,"rule aspectActionBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:14: ( aspectActionSignature aspectActionBody END -> ^( ASPECTACTION aspectActionSignature ( aspectActionBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:16: aspectActionSignature aspectActionBody END
			{
			pushFollow(FOLLOW_aspectActionSignature_in_aspectAction6510);
			aspectActionSignature481=aspectActionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectActionSignature.add(aspectActionSignature481.getTree());
			pushFollow(FOLLOW_aspectActionBody_in_aspectAction6512);
			aspectActionBody482=aspectActionBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectActionBody.add(aspectActionBody482.getTree());
			END483=(Token)match(input,END,FOLLOW_END_in_aspectAction6514); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END483);

			// AST REWRITE
			// elements: aspectActionBody, aspectActionSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 655:59: -> ^( ASPECTACTION aspectActionSignature ( aspectActionBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:62: ^( ASPECTACTION aspectActionSignature ( aspectActionBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTACTION, "ASPECTACTION"), root_1);
				adaptor.addChild(root_1, stream_aspectActionSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:99: ( aspectActionBody )?
				if ( stream_aspectActionBody.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectActionBody.nextTree());
				}
				stream_aspectActionBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectAction"


	public static class aspectActionSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActionSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:1: aspectActionSignature : name COLON aspectActionType ( COLON )? aspectExpression ( COLON inputPortion )? -> name aspectActionType aspectExpression ( inputPortion )? ;
	public final MatlabParser.aspectActionSignature_return aspectActionSignature() throws RecognitionException {
		MatlabParser.aspectActionSignature_return retval = new MatlabParser.aspectActionSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COLON485=null;
		Token COLON487=null;
		Token COLON489=null;
		ParserRuleReturnScope name484 =null;
		ParserRuleReturnScope aspectActionType486 =null;
		ParserRuleReturnScope aspectExpression488 =null;
		ParserRuleReturnScope inputPortion490 =null;

		Object COLON485_tree=null;
		Object COLON487_tree=null;
		Object COLON489_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_aspectExpression=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_aspectActionType=new RewriteRuleSubtreeStream(adaptor,"rule aspectActionType");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:23: ( name COLON aspectActionType ( COLON )? aspectExpression ( COLON inputPortion )? -> name aspectActionType aspectExpression ( inputPortion )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:25: name COLON aspectActionType ( COLON )? aspectExpression ( COLON inputPortion )?
			{
			pushFollow(FOLLOW_name_in_aspectActionSignature6535);
			name484=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name484.getTree());
			COLON485=(Token)match(input,COLON,FOLLOW_COLON_in_aspectActionSignature6537); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON485);

			pushFollow(FOLLOW_aspectActionType_in_aspectActionSignature6539);
			aspectActionType486=aspectActionType();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectActionType.add(aspectActionType486.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:53: ( COLON )?
			int alt122=2;
			int LA122_0 = input.LA(1);
			if ( (LA122_0==COLON) ) {
				alt122=1;
			}
			switch (alt122) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:54: COLON
					{
					COLON487=(Token)match(input,COLON,FOLLOW_COLON_in_aspectActionSignature6542); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON487);

					}
					break;

			}

			pushFollow(FOLLOW_aspectExpression_in_aspectActionSignature6546);
			aspectExpression488=aspectExpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression.add(aspectExpression488.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:79: ( COLON inputPortion )?
			int alt123=2;
			int LA123_0 = input.LA(1);
			if ( (LA123_0==COLON) ) {
				alt123=1;
			}
			switch (alt123) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:80: COLON inputPortion
					{
					COLON489=(Token)match(input,COLON,FOLLOW_COLON_in_aspectActionSignature6549); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON489);

					pushFollow(FOLLOW_inputPortion_in_aspectActionSignature6551);
					inputPortion490=inputPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion490.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: inputPortion, aspectExpression, name, aspectActionType
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 657:101: -> name aspectActionType aspectExpression ( inputPortion )?
			{
				adaptor.addChild(root_0, stream_name.nextTree());
				adaptor.addChild(root_0, stream_aspectActionType.nextTree());
				adaptor.addChild(root_0, stream_aspectExpression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:143: ( inputPortion )?
				if ( stream_inputPortion.hasNext() ) {
					adaptor.addChild(root_0, stream_inputPortion.nextTree());
				}
				stream_inputPortion.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActionSignature"


	public static class aspectActionType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActionType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:659:1: aspectActionType : ( wBEFORE -> wBEFORE | wAFTER -> wAFTER | wAROUND -> wAROUND );
	public final MatlabParser.aspectActionType_return aspectActionType() throws RecognitionException {
		MatlabParser.aspectActionType_return retval = new MatlabParser.aspectActionType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wBEFORE491 =null;
		ParserRuleReturnScope wAFTER492 =null;
		ParserRuleReturnScope wAROUND493 =null;

		RewriteRuleSubtreeStream stream_wAFTER=new RewriteRuleSubtreeStream(adaptor,"rule wAFTER");
		RewriteRuleSubtreeStream stream_wBEFORE=new RewriteRuleSubtreeStream(adaptor,"rule wBEFORE");
		RewriteRuleSubtreeStream stream_wAROUND=new RewriteRuleSubtreeStream(adaptor,"rule wAROUND");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:659:18: ( wBEFORE -> wBEFORE | wAFTER -> wAFTER | wAROUND -> wAROUND )
			int alt124=3;
			int LA124_0 = input.LA(1);
			if ( (LA124_0==ID) && (((Keyword_IdFollows("after"))||(Keyword_IdFollows("before"))||(Keyword_IdFollows("around"))))) {
				int LA124_1 = input.LA(2);
				if ( ((Keyword_IdFollows("before"))) ) {
					alt124=1;
				}
				else if ( ((Keyword_IdFollows("after"))) ) {
					alt124=2;
				}
				else if ( ((Keyword_IdFollows("around"))) ) {
					alt124=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 124, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt124) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:659:20: wBEFORE
					{
					pushFollow(FOLLOW_wBEFORE_in_aspectActionType6575);
					wBEFORE491=wBEFORE();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wBEFORE.add(wBEFORE491.getTree());
					// AST REWRITE
					// elements: wBEFORE
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 659:28: -> wBEFORE
					{
						adaptor.addChild(root_0, stream_wBEFORE.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:660:20: wAFTER
					{
					pushFollow(FOLLOW_wAFTER_in_aspectActionType6600);
					wAFTER492=wAFTER();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wAFTER.add(wAFTER492.getTree());
					// AST REWRITE
					// elements: wAFTER
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 660:27: -> wAFTER
					{
						adaptor.addChild(root_0, stream_wAFTER.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:661:8: wAROUND
					{
					pushFollow(FOLLOW_wAROUND_in_aspectActionType6613);
					wAROUND493=wAROUND();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wAROUND.add(wAROUND493.getTree());
					// AST REWRITE
					// elements: wAROUND
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 661:16: -> wAROUND
					{
						adaptor.addChild(root_0, stream_wAROUND.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActionType"


	public static class aspectActionBody_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActionBody"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:664:1: aspectActionBody : closeBody -> ( closeBody )? ;
	public final MatlabParser.aspectActionBody_return aspectActionBody() throws RecognitionException {
		MatlabParser.aspectActionBody_return retval = new MatlabParser.aspectActionBody_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope closeBody494 =null;

		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:664:18: ( closeBody -> ( closeBody )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:664:20: closeBody
			{
			pushFollow(FOLLOW_closeBody_in_aspectActionBody6631);
			closeBody494=closeBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeBody.add(closeBody494.getTree());
			// AST REWRITE
			// elements: closeBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 664:30: -> ( closeBody )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:664:33: ( closeBody )?
				if ( stream_closeBody.hasNext() ) {
					adaptor.addChild(root_0, stream_closeBody.nextTree());
				}
				stream_closeBody.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActionBody"


	public static class aspectPatternSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPatternSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:1: aspectPatternSection : wPATTERNS aspectPatterns END -> ^( ASPECTPATTERNSECTION[$wPATTERNS.start] ( aspectPatterns )? ) ;
	public final MatlabParser.aspectPatternSection_return aspectPatternSection() throws RecognitionException {
		MatlabParser.aspectPatternSection_return retval = new MatlabParser.aspectPatternSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END497=null;
		ParserRuleReturnScope wPATTERNS495 =null;
		ParserRuleReturnScope aspectPatterns496 =null;

		Object END497_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_wPATTERNS=new RewriteRuleSubtreeStream(adaptor,"rule wPATTERNS");
		RewriteRuleSubtreeStream stream_aspectPatterns=new RewriteRuleSubtreeStream(adaptor,"rule aspectPatterns");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:22: ( wPATTERNS aspectPatterns END -> ^( ASPECTPATTERNSECTION[$wPATTERNS.start] ( aspectPatterns )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:24: wPATTERNS aspectPatterns END
			{
			pushFollow(FOLLOW_wPATTERNS_in_aspectPatternSection6649);
			wPATTERNS495=wPATTERNS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wPATTERNS.add(wPATTERNS495.getTree());
			pushFollow(FOLLOW_aspectPatterns_in_aspectPatternSection6651);
			aspectPatterns496=aspectPatterns();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectPatterns.add(aspectPatterns496.getTree());
			END497=(Token)match(input,END,FOLLOW_END_in_aspectPatternSection6653); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END497);

			// AST REWRITE
			// elements: aspectPatterns
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 668:53: -> ^( ASPECTPATTERNSECTION[$wPATTERNS.start] ( aspectPatterns )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:56: ^( ASPECTPATTERNSECTION[$wPATTERNS.start] ( aspectPatterns )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTPATTERNSECTION, (wPATTERNS495!=null?(wPATTERNS495.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:97: ( aspectPatterns )?
				if ( stream_aspectPatterns.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectPatterns.nextTree());
				}
				stream_aspectPatterns.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPatternSection"


	public static class aspectPatterns_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPatterns"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:1: aspectPatterns : ( aspectPattern | xEOS )* -> ( aspectPattern )* ;
	public final MatlabParser.aspectPatterns_return aspectPatterns() throws RecognitionException {
		MatlabParser.aspectPatterns_return retval = new MatlabParser.aspectPatterns_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectPattern498 =null;
		ParserRuleReturnScope xEOS499 =null;

		RewriteRuleSubtreeStream stream_aspectPattern=new RewriteRuleSubtreeStream(adaptor,"rule aspectPattern");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:16: ( ( aspectPattern | xEOS )* -> ( aspectPattern )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:18: ( aspectPattern | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:18: ( aspectPattern | xEOS )*
			loop125:
			while (true) {
				int alt125=3;
				int LA125_0 = input.LA(1);
				if ( (LA125_0==ID) ) {
					alt125=1;
				}
				else if ( (LA125_0==COMMA||LA125_0==EOL||LA125_0==SEMICOLON) ) {
					alt125=2;
				}

				switch (alt125) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:19: aspectPattern
					{
					pushFollow(FOLLOW_aspectPattern_in_aspectPatterns6675);
					aspectPattern498=aspectPattern();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectPattern.add(aspectPattern498.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:35: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_aspectPatterns6679);
					xEOS499=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS499.getTree());
					}
					break;

				default :
					break loop125;
				}
			}

			// AST REWRITE
			// elements: aspectPattern
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 670:42: -> ( aspectPattern )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:45: ( aspectPattern )*
				while ( stream_aspectPattern.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectPattern.nextTree());
				}
				stream_aspectPattern.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPatterns"


	public static class aspectPattern_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPattern"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:672:1: aspectPattern : name COLON aspectExpression xEOS -> ^( ASPECTPATTERN name aspectExpression ) ;
	public final MatlabParser.aspectPattern_return aspectPattern() throws RecognitionException {
		MatlabParser.aspectPattern_return retval = new MatlabParser.aspectPattern_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COLON501=null;
		ParserRuleReturnScope name500 =null;
		ParserRuleReturnScope aspectExpression502 =null;
		ParserRuleReturnScope xEOS503 =null;

		Object COLON501_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_aspectExpression=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:672:15: ( name COLON aspectExpression xEOS -> ^( ASPECTPATTERN name aspectExpression ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:672:17: name COLON aspectExpression xEOS
			{
			pushFollow(FOLLOW_name_in_aspectPattern6697);
			name500=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name500.getTree());
			COLON501=(Token)match(input,COLON,FOLLOW_COLON_in_aspectPattern6699); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON501);

			pushFollow(FOLLOW_aspectExpression_in_aspectPattern6701);
			aspectExpression502=aspectExpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression.add(aspectExpression502.getTree());
			pushFollow(FOLLOW_xEOS_in_aspectPattern6703);
			xEOS503=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS503.getTree());
			// AST REWRITE
			// elements: name, aspectExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 672:50: -> ^( ASPECTPATTERN name aspectExpression )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:672:53: ^( ASPECTPATTERN name aspectExpression )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTPATTERN, "ASPECTPATTERN"), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_1, stream_aspectExpression.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPattern"


	public static class aspectExpression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:674:1: aspectExpression : aspectExpression04 -> aspectExpression04 ;
	public final MatlabParser.aspectExpression_return aspectExpression() throws RecognitionException {
		MatlabParser.aspectExpression_return retval = new MatlabParser.aspectExpression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectExpression04504 =null;

		RewriteRuleSubtreeStream stream_aspectExpression04=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression04");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:674:18: ( aspectExpression04 -> aspectExpression04 )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:674:20: aspectExpression04
			{
			pushFollow(FOLLOW_aspectExpression04_in_aspectExpression6722);
			aspectExpression04504=aspectExpression04();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression04.add(aspectExpression04504.getTree());
			// AST REWRITE
			// elements: aspectExpression04
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 674:39: -> aspectExpression04
			{
				adaptor.addChild(root_0, stream_aspectExpression04.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression"


	public static class aspectExpression04_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression04"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:1: aspectExpression04 : (x1= aspectExpression03 -> $x1) ( options {greedy=true; } : OR x2= aspectExpression03 -> ^( OR $aspectExpression04 $x2) )* ;
	public final MatlabParser.aspectExpression04_return aspectExpression04() throws RecognitionException {
		MatlabParser.aspectExpression04_return retval = new MatlabParser.aspectExpression04_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token OR505=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object OR505_tree=null;
		RewriteRuleTokenStream stream_OR=new RewriteRuleTokenStream(adaptor,"token OR");
		RewriteRuleSubtreeStream stream_aspectExpression03=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression03");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:20: ( (x1= aspectExpression03 -> $x1) ( options {greedy=true; } : OR x2= aspectExpression03 -> ^( OR $aspectExpression04 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:22: (x1= aspectExpression03 -> $x1) ( options {greedy=true; } : OR x2= aspectExpression03 -> ^( OR $aspectExpression04 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:22: (x1= aspectExpression03 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:23: x1= aspectExpression03
			{
			pushFollow(FOLLOW_aspectExpression03_in_aspectExpression046738);
			x1=aspectExpression03();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression03.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 676:45: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:53: ( options {greedy=true; } : OR x2= aspectExpression03 -> ^( OR $aspectExpression04 $x2) )*
			loop126:
			while (true) {
				int alt126=2;
				int LA126_0 = input.LA(1);
				if ( (LA126_0==OR) ) {
					alt126=1;
				}

				switch (alt126) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:78: OR x2= aspectExpression03
					{
					OR505=(Token)match(input,OR,FOLLOW_OR_in_aspectExpression046755); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OR.add(OR505);

					pushFollow(FOLLOW_aspectExpression03_in_aspectExpression046759);
					x2=aspectExpression03();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExpression03.add(x2.getTree());
					// AST REWRITE
					// elements: aspectExpression04, x2, OR
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 676:103: -> ^( OR $aspectExpression04 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:106: ^( OR $aspectExpression04 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_OR.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop126;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression04"


	public static class aspectExpression03_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression03"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:1: aspectExpression03 : (x1= aspectExpression02 -> $x1) ( options {greedy=true; } : AND x2= aspectExpression02 -> ^( AND $aspectExpression03 $x2) )* ;
	public final MatlabParser.aspectExpression03_return aspectExpression03() throws RecognitionException {
		MatlabParser.aspectExpression03_return retval = new MatlabParser.aspectExpression03_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AND506=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object AND506_tree=null;
		RewriteRuleTokenStream stream_AND=new RewriteRuleTokenStream(adaptor,"token AND");
		RewriteRuleSubtreeStream stream_aspectExpression02=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression02");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:20: ( (x1= aspectExpression02 -> $x1) ( options {greedy=true; } : AND x2= aspectExpression02 -> ^( AND $aspectExpression03 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:22: (x1= aspectExpression02 -> $x1) ( options {greedy=true; } : AND x2= aspectExpression02 -> ^( AND $aspectExpression03 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:22: (x1= aspectExpression02 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:23: x1= aspectExpression02
			{
			pushFollow(FOLLOW_aspectExpression02_in_aspectExpression036785);
			x1=aspectExpression02();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression02.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 678:45: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:53: ( options {greedy=true; } : AND x2= aspectExpression02 -> ^( AND $aspectExpression03 $x2) )*
			loop127:
			while (true) {
				int alt127=2;
				int LA127_0 = input.LA(1);
				if ( (LA127_0==AND) ) {
					alt127=1;
				}

				switch (alt127) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:78: AND x2= aspectExpression02
					{
					AND506=(Token)match(input,AND,FOLLOW_AND_in_aspectExpression036802); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AND.add(AND506);

					pushFollow(FOLLOW_aspectExpression02_in_aspectExpression036806);
					x2=aspectExpression02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExpression02.add(x2.getTree());
					// AST REWRITE
					// elements: x2, aspectExpression03, AND
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 678:104: -> ^( AND $aspectExpression03 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:107: ^( AND $aspectExpression03 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_AND.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop127;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression03"


	public static class aspectExpression02_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression02"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:680:1: aspectExpression02 : ( NOT x1= aspectExpression02 -> ^( NOT $x1) |x2= aspectExpression01 -> $x2);
	public final MatlabParser.aspectExpression02_return aspectExpression02() throws RecognitionException {
		MatlabParser.aspectExpression02_return retval = new MatlabParser.aspectExpression02_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token NOT507=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object NOT507_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_aspectExpression02=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression02");
		RewriteRuleSubtreeStream stream_aspectExpression01=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression01");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:680:20: ( NOT x1= aspectExpression02 -> ^( NOT $x1) |x2= aspectExpression01 -> $x2)
			int alt128=2;
			int LA128_0 = input.LA(1);
			if ( (LA128_0==NOT) ) {
				alt128=1;
			}
			else if ( (LA128_0==ID||LA128_0==LPAREN) ) {
				alt128=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 128, 0, input);
				throw nvae;
			}

			switch (alt128) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:680:22: NOT x1= aspectExpression02
					{
					NOT507=(Token)match(input,NOT,FOLLOW_NOT_in_aspectExpression026829); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT507);

					pushFollow(FOLLOW_aspectExpression02_in_aspectExpression026833);
					x1=aspectExpression02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExpression02.add(x1.getTree());
					// AST REWRITE
					// elements: NOT, x1
					// token labels: 
					// rule labels: x1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 680:48: -> ^( NOT $x1)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:680:51: ^( NOT $x1)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_NOT.nextNode(), root_1);
						adaptor.addChild(root_1, stream_x1.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:681:13: x2= aspectExpression01
					{
					pushFollow(FOLLOW_aspectExpression01_in_aspectExpression026858);
					x2=aspectExpression01();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExpression01.add(x2.getTree());
					// AST REWRITE
					// elements: x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 681:35: -> $x2
					{
						adaptor.addChild(root_0, stream_x2.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression02"


	public static class aspectExpression01_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression01"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:684:1: aspectExpression01 : aspectAtom -> aspectAtom ;
	public final MatlabParser.aspectExpression01_return aspectExpression01() throws RecognitionException {
		MatlabParser.aspectExpression01_return retval = new MatlabParser.aspectExpression01_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectAtom508 =null;

		RewriteRuleSubtreeStream stream_aspectAtom=new RewriteRuleSubtreeStream(adaptor,"rule aspectAtom");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:684:20: ( aspectAtom -> aspectAtom )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:684:22: aspectAtom
			{
			pushFollow(FOLLOW_aspectAtom_in_aspectExpression016882);
			aspectAtom508=aspectAtom();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectAtom.add(aspectAtom508.getTree());
			// AST REWRITE
			// elements: aspectAtom
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 684:33: -> aspectAtom
			{
				adaptor.addChild(root_0, stream_aspectAtom.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression01"


	public static class aspectAtom_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectAtom"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:686:1: aspectAtom : ( aspectParenthesis -> aspectParenthesis | aspectName -> aspectName | aspectGet -> aspectGet | aspectSet -> aspectSet | aspectCall -> aspectCall | aspectExecution -> aspectExecution | aspectMainExecution -> aspectMainExecution | aspectLoop -> aspectLoop | aspectLoopHead -> aspectLoopHead | aspectLoopBody -> aspectLoopBody | aspectAnnotate -> aspectAnnotate | aspectOperator -> aspectOperator | aspectWithin -> aspectWithin | aspectDimension -> aspectDimension | aspectIsType -> aspectIsType );
	public final MatlabParser.aspectAtom_return aspectAtom() throws RecognitionException {
		MatlabParser.aspectAtom_return retval = new MatlabParser.aspectAtom_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectParenthesis509 =null;
		ParserRuleReturnScope aspectName510 =null;
		ParserRuleReturnScope aspectGet511 =null;
		ParserRuleReturnScope aspectSet512 =null;
		ParserRuleReturnScope aspectCall513 =null;
		ParserRuleReturnScope aspectExecution514 =null;
		ParserRuleReturnScope aspectMainExecution515 =null;
		ParserRuleReturnScope aspectLoop516 =null;
		ParserRuleReturnScope aspectLoopHead517 =null;
		ParserRuleReturnScope aspectLoopBody518 =null;
		ParserRuleReturnScope aspectAnnotate519 =null;
		ParserRuleReturnScope aspectOperator520 =null;
		ParserRuleReturnScope aspectWithin521 =null;
		ParserRuleReturnScope aspectDimension522 =null;
		ParserRuleReturnScope aspectIsType523 =null;

		RewriteRuleSubtreeStream stream_aspectName=new RewriteRuleSubtreeStream(adaptor,"rule aspectName");
		RewriteRuleSubtreeStream stream_aspectAnnotate=new RewriteRuleSubtreeStream(adaptor,"rule aspectAnnotate");
		RewriteRuleSubtreeStream stream_aspectMainExecution=new RewriteRuleSubtreeStream(adaptor,"rule aspectMainExecution");
		RewriteRuleSubtreeStream stream_aspectCall=new RewriteRuleSubtreeStream(adaptor,"rule aspectCall");
		RewriteRuleSubtreeStream stream_aspectWithin=new RewriteRuleSubtreeStream(adaptor,"rule aspectWithin");
		RewriteRuleSubtreeStream stream_aspectParenthesis=new RewriteRuleSubtreeStream(adaptor,"rule aspectParenthesis");
		RewriteRuleSubtreeStream stream_aspectGet=new RewriteRuleSubtreeStream(adaptor,"rule aspectGet");
		RewriteRuleSubtreeStream stream_aspectExecution=new RewriteRuleSubtreeStream(adaptor,"rule aspectExecution");
		RewriteRuleSubtreeStream stream_aspectLoopHead=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopHead");
		RewriteRuleSubtreeStream stream_aspectOperator=new RewriteRuleSubtreeStream(adaptor,"rule aspectOperator");
		RewriteRuleSubtreeStream stream_aspectSet=new RewriteRuleSubtreeStream(adaptor,"rule aspectSet");
		RewriteRuleSubtreeStream stream_aspectLoopBody=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopBody");
		RewriteRuleSubtreeStream stream_aspectLoop=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoop");
		RewriteRuleSubtreeStream stream_aspectDimension=new RewriteRuleSubtreeStream(adaptor,"rule aspectDimension");
		RewriteRuleSubtreeStream stream_aspectIsType=new RewriteRuleSubtreeStream(adaptor,"rule aspectIsType");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:686:12: ( aspectParenthesis -> aspectParenthesis | aspectName -> aspectName | aspectGet -> aspectGet | aspectSet -> aspectSet | aspectCall -> aspectCall | aspectExecution -> aspectExecution | aspectMainExecution -> aspectMainExecution | aspectLoop -> aspectLoop | aspectLoopHead -> aspectLoopHead | aspectLoopBody -> aspectLoopBody | aspectAnnotate -> aspectAnnotate | aspectOperator -> aspectOperator | aspectWithin -> aspectWithin | aspectDimension -> aspectDimension | aspectIsType -> aspectIsType )
			int alt129=15;
			alt129 = dfa129.predict(input);
			switch (alt129) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:686:14: aspectParenthesis
					{
					pushFollow(FOLLOW_aspectParenthesis_in_aspectAtom6895);
					aspectParenthesis509=aspectParenthesis();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectParenthesis.add(aspectParenthesis509.getTree());
					// AST REWRITE
					// elements: aspectParenthesis
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 686:32: -> aspectParenthesis
					{
						adaptor.addChild(root_0, stream_aspectParenthesis.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:687:14: aspectName
					{
					pushFollow(FOLLOW_aspectName_in_aspectAtom6914);
					aspectName510=aspectName();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectName.add(aspectName510.getTree());
					// AST REWRITE
					// elements: aspectName
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 687:25: -> aspectName
					{
						adaptor.addChild(root_0, stream_aspectName.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:688:14: aspectGet
					{
					pushFollow(FOLLOW_aspectGet_in_aspectAtom6933);
					aspectGet511=aspectGet();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectGet.add(aspectGet511.getTree());
					// AST REWRITE
					// elements: aspectGet
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 688:24: -> aspectGet
					{
						adaptor.addChild(root_0, stream_aspectGet.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:689:14: aspectSet
					{
					pushFollow(FOLLOW_aspectSet_in_aspectAtom6952);
					aspectSet512=aspectSet();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectSet.add(aspectSet512.getTree());
					// AST REWRITE
					// elements: aspectSet
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 689:24: -> aspectSet
					{
						adaptor.addChild(root_0, stream_aspectSet.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:690:14: aspectCall
					{
					pushFollow(FOLLOW_aspectCall_in_aspectAtom6971);
					aspectCall513=aspectCall();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectCall.add(aspectCall513.getTree());
					// AST REWRITE
					// elements: aspectCall
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 690:25: -> aspectCall
					{
						adaptor.addChild(root_0, stream_aspectCall.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:691:14: aspectExecution
					{
					pushFollow(FOLLOW_aspectExecution_in_aspectAtom6990);
					aspectExecution514=aspectExecution();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExecution.add(aspectExecution514.getTree());
					// AST REWRITE
					// elements: aspectExecution
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 691:30: -> aspectExecution
					{
						adaptor.addChild(root_0, stream_aspectExecution.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:692:14: aspectMainExecution
					{
					pushFollow(FOLLOW_aspectMainExecution_in_aspectAtom7009);
					aspectMainExecution515=aspectMainExecution();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectMainExecution.add(aspectMainExecution515.getTree());
					// AST REWRITE
					// elements: aspectMainExecution
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 692:34: -> aspectMainExecution
					{
						adaptor.addChild(root_0, stream_aspectMainExecution.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:693:14: aspectLoop
					{
					pushFollow(FOLLOW_aspectLoop_in_aspectAtom7028);
					aspectLoop516=aspectLoop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoop.add(aspectLoop516.getTree());
					// AST REWRITE
					// elements: aspectLoop
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 693:25: -> aspectLoop
					{
						adaptor.addChild(root_0, stream_aspectLoop.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:694:14: aspectLoopHead
					{
					pushFollow(FOLLOW_aspectLoopHead_in_aspectAtom7047);
					aspectLoopHead517=aspectLoopHead();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopHead.add(aspectLoopHead517.getTree());
					// AST REWRITE
					// elements: aspectLoopHead
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 694:29: -> aspectLoopHead
					{
						adaptor.addChild(root_0, stream_aspectLoopHead.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:695:14: aspectLoopBody
					{
					pushFollow(FOLLOW_aspectLoopBody_in_aspectAtom7066);
					aspectLoopBody518=aspectLoopBody();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopBody.add(aspectLoopBody518.getTree());
					// AST REWRITE
					// elements: aspectLoopBody
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 695:29: -> aspectLoopBody
					{
						adaptor.addChild(root_0, stream_aspectLoopBody.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:696:14: aspectAnnotate
					{
					pushFollow(FOLLOW_aspectAnnotate_in_aspectAtom7085);
					aspectAnnotate519=aspectAnnotate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectAnnotate.add(aspectAnnotate519.getTree());
					// AST REWRITE
					// elements: aspectAnnotate
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 696:29: -> aspectAnnotate
					{
						adaptor.addChild(root_0, stream_aspectAnnotate.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 12 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:697:14: aspectOperator
					{
					pushFollow(FOLLOW_aspectOperator_in_aspectAtom7104);
					aspectOperator520=aspectOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectOperator.add(aspectOperator520.getTree());
					// AST REWRITE
					// elements: aspectOperator
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 697:29: -> aspectOperator
					{
						adaptor.addChild(root_0, stream_aspectOperator.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 13 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:698:14: aspectWithin
					{
					pushFollow(FOLLOW_aspectWithin_in_aspectAtom7123);
					aspectWithin521=aspectWithin();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectWithin.add(aspectWithin521.getTree());
					// AST REWRITE
					// elements: aspectWithin
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 698:27: -> aspectWithin
					{
						adaptor.addChild(root_0, stream_aspectWithin.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 14 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:699:14: aspectDimension
					{
					pushFollow(FOLLOW_aspectDimension_in_aspectAtom7142);
					aspectDimension522=aspectDimension();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectDimension.add(aspectDimension522.getTree());
					// AST REWRITE
					// elements: aspectDimension
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 699:30: -> aspectDimension
					{
						adaptor.addChild(root_0, stream_aspectDimension.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 15 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:700:14: aspectIsType
					{
					pushFollow(FOLLOW_aspectIsType_in_aspectAtom7161);
					aspectIsType523=aspectIsType();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectIsType.add(aspectIsType523.getTree());
					// AST REWRITE
					// elements: aspectIsType
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 700:27: -> aspectIsType
					{
						adaptor.addChild(root_0, stream_aspectIsType.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectAtom"


	public static class aspectParenthesis_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectParenthesis"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:703:1: aspectParenthesis : LPAREN aspectExpression RPAREN -> aspectExpression ;
	public final MatlabParser.aspectParenthesis_return aspectParenthesis() throws RecognitionException {
		MatlabParser.aspectParenthesis_return retval = new MatlabParser.aspectParenthesis_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN524=null;
		Token RPAREN526=null;
		ParserRuleReturnScope aspectExpression525 =null;

		Object LPAREN524_tree=null;
		Object RPAREN526_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectExpression=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:703:19: ( LPAREN aspectExpression RPAREN -> aspectExpression )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:703:21: LPAREN aspectExpression RPAREN
			{
			LPAREN524=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectParenthesis7185); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN524);

			pushFollow(FOLLOW_aspectExpression_in_aspectParenthesis7187);
			aspectExpression525=aspectExpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression.add(aspectExpression525.getTree());
			RPAREN526=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectParenthesis7189); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN526);

			// AST REWRITE
			// elements: aspectExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 703:52: -> aspectExpression
			{
				adaptor.addChild(root_0, stream_aspectExpression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectParenthesis"


	public static class aspectName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:705:1: aspectName : name -> ^( ASPECTNAME[\"\"] name ) ;
	public final MatlabParser.aspectName_return aspectName() throws RecognitionException {
		MatlabParser.aspectName_return retval = new MatlabParser.aspectName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name527 =null;

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:705:12: ( name -> ^( ASPECTNAME[\"\"] name ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:705:14: name
			{
			pushFollow(FOLLOW_name_in_aspectName7202);
			name527=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name527.getTree());
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 705:19: -> ^( ASPECTNAME[\"\"] name )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:705:22: ^( ASPECTNAME[\"\"] name )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTNAME, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectName"


	public static class aspectIdentifier_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectIdentifier"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:707:1: aspectIdentifier : ( wID -> wID | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectIdentifier_return aspectIdentifier() throws RecognitionException {
		MatlabParser.aspectIdentifier_return retval = new MatlabParser.aspectIdentifier_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wID528 =null;
		ParserRuleReturnScope wSTAR529 =null;
		ParserRuleReturnScope wDOTDOT530 =null;

		RewriteRuleSubtreeStream stream_wID=new RewriteRuleSubtreeStream(adaptor,"rule wID");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:707:18: ( wID -> wID | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt130=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt130=1;
				}
				break;
			case MTIMES:
				{
				alt130=2;
				}
				break;
			case DOTDOT:
				{
				alt130=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 130, 0, input);
				throw nvae;
			}
			switch (alt130) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:707:20: wID
					{
					pushFollow(FOLLOW_wID_in_aspectIdentifier7220);
					wID528=wID();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wID.add(wID528.getTree());
					// AST REWRITE
					// elements: wID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 707:24: -> wID
					{
						adaptor.addChild(root_0, stream_wID.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:708:20: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectIdentifier7245);
					wSTAR529=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR529.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 708:26: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:709:20: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectIdentifier7270);
					wDOTDOT530=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT530.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 709:28: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectIdentifier"


	public static class aspectTypeSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectTypeSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:712:1: aspectTypeSignature : ( wID -> ^( ASPECTTYPESIGNATURE wID ) | wSTAR -> ^( ASPECTTYPESIGNATURE wSTAR ) | wDOTDOT -> ^( ASPECTTYPESIGNATURE wDOTDOT ) );
	public final MatlabParser.aspectTypeSignature_return aspectTypeSignature() throws RecognitionException {
		MatlabParser.aspectTypeSignature_return retval = new MatlabParser.aspectTypeSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wID531 =null;
		ParserRuleReturnScope wSTAR532 =null;
		ParserRuleReturnScope wDOTDOT533 =null;

		RewriteRuleSubtreeStream stream_wID=new RewriteRuleSubtreeStream(adaptor,"rule wID");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:712:21: ( wID -> ^( ASPECTTYPESIGNATURE wID ) | wSTAR -> ^( ASPECTTYPESIGNATURE wSTAR ) | wDOTDOT -> ^( ASPECTTYPESIGNATURE wDOTDOT ) )
			int alt131=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt131=1;
				}
				break;
			case MTIMES:
				{
				alt131=2;
				}
				break;
			case DOTDOT:
				{
				alt131=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 131, 0, input);
				throw nvae;
			}
			switch (alt131) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:712:23: wID
					{
					pushFollow(FOLLOW_wID_in_aspectTypeSignature7300);
					wID531=wID();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wID.add(wID531.getTree());
					// AST REWRITE
					// elements: wID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 712:27: -> ^( ASPECTTYPESIGNATURE wID )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:712:30: ^( ASPECTTYPESIGNATURE wID )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTTYPESIGNATURE, "ASPECTTYPESIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_wID.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:713:23: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectTypeSignature7332);
					wSTAR532=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR532.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 713:29: -> ^( ASPECTTYPESIGNATURE wSTAR )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:713:32: ^( ASPECTTYPESIGNATURE wSTAR )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTTYPESIGNATURE, "ASPECTTYPESIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_wSTAR.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:714:23: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectTypeSignature7364);
					wDOTDOT533=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT533.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 714:31: -> ^( ASPECTTYPESIGNATURE wDOTDOT )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:714:34: ^( ASPECTTYPESIGNATURE wDOTDOT )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTTYPESIGNATURE, "ASPECTTYPESIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_wDOTDOT.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectTypeSignature"


	public static class aspectPartSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPartSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:717:1: aspectPartSignature : ( wREAL -> wREAL | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectPartSignature_return aspectPartSignature() throws RecognitionException {
		MatlabParser.aspectPartSignature_return retval = new MatlabParser.aspectPartSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wREAL534 =null;
		ParserRuleReturnScope wSTAR535 =null;
		ParserRuleReturnScope wDOTDOT536 =null;

		RewriteRuleSubtreeStream stream_wREAL=new RewriteRuleSubtreeStream(adaptor,"rule wREAL");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:717:21: ( wREAL -> wREAL | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt132=3;
			switch ( input.LA(1) ) {
			case REAL:
				{
				alt132=1;
				}
				break;
			case MTIMES:
				{
				alt132=2;
				}
				break;
			case DOTDOT:
				{
				alt132=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 132, 0, input);
				throw nvae;
			}
			switch (alt132) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:717:23: wREAL
					{
					pushFollow(FOLLOW_wREAL_in_aspectPartSignature7401);
					wREAL534=wREAL();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wREAL.add(wREAL534.getTree());
					// AST REWRITE
					// elements: wREAL
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 717:29: -> wREAL
					{
						adaptor.addChild(root_0, stream_wREAL.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:718:23: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectPartSignature7429);
					wSTAR535=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR535.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 718:29: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:719:23: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectPartSignature7457);
					wDOTDOT536=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT536.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 719:31: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPartSignature"


	public static class aspectDimensionSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectDimensionSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:1: aspectDimensionSignature : LSQUARE ( aspectPartSignature ( COMMA aspectPartSignature )* )? RSQUARE -> ^( ASPECTDIMENSIONSIGNATURE ( aspectPartSignature )* ) ;
	public final MatlabParser.aspectDimensionSignature_return aspectDimensionSignature() throws RecognitionException {
		MatlabParser.aspectDimensionSignature_return retval = new MatlabParser.aspectDimensionSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE537=null;
		Token COMMA539=null;
		Token RSQUARE541=null;
		ParserRuleReturnScope aspectPartSignature538 =null;
		ParserRuleReturnScope aspectPartSignature540 =null;

		Object LSQUARE537_tree=null;
		Object COMMA539_tree=null;
		Object RSQUARE541_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_aspectPartSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectPartSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:26: ( LSQUARE ( aspectPartSignature ( COMMA aspectPartSignature )* )? RSQUARE -> ^( ASPECTDIMENSIONSIGNATURE ( aspectPartSignature )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:28: LSQUARE ( aspectPartSignature ( COMMA aspectPartSignature )* )? RSQUARE
			{
			LSQUARE537=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_aspectDimensionSignature7490); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE537);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:36: ( aspectPartSignature ( COMMA aspectPartSignature )* )?
			int alt134=2;
			int LA134_0 = input.LA(1);
			if ( (LA134_0==DOTDOT||LA134_0==MTIMES||LA134_0==REAL) ) {
				alt134=1;
			}
			switch (alt134) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:37: aspectPartSignature ( COMMA aspectPartSignature )*
					{
					pushFollow(FOLLOW_aspectPartSignature_in_aspectDimensionSignature7493);
					aspectPartSignature538=aspectPartSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectPartSignature.add(aspectPartSignature538.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:57: ( COMMA aspectPartSignature )*
					loop133:
					while (true) {
						int alt133=2;
						int LA133_0 = input.LA(1);
						if ( (LA133_0==COMMA) ) {
							alt133=1;
						}

						switch (alt133) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:58: COMMA aspectPartSignature
							{
							COMMA539=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectDimensionSignature7496); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA539);

							pushFollow(FOLLOW_aspectPartSignature_in_aspectDimensionSignature7498);
							aspectPartSignature540=aspectPartSignature();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectPartSignature.add(aspectPartSignature540.getTree());
							}
							break;

						default :
							break loop133;
						}
					}

					}
					break;

			}

			RSQUARE541=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_aspectDimensionSignature7504); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE541);

			// AST REWRITE
			// elements: aspectPartSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 722:96: -> ^( ASPECTDIMENSIONSIGNATURE ( aspectPartSignature )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:99: ^( ASPECTDIMENSIONSIGNATURE ( aspectPartSignature )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTDIMENSIONSIGNATURE, "ASPECTDIMENSIONSIGNATURE"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:126: ( aspectPartSignature )*
				while ( stream_aspectPartSignature.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectPartSignature.nextTree());
				}
				stream_aspectPartSignature.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectDimensionSignature"


	public static class aspectFullSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectFullSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:724:1: aspectFullSignature : ( aspectTypeSignature -> ^( ASPECTFULLSIGNATURE aspectTypeSignature ) | aspectTypeSignature aspectDimensionSignature -> ^( ASPECTFULLSIGNATURE aspectTypeSignature aspectDimensionSignature ) | aspectDimensionSignature -> ^( ASPECTFULLSIGNATURE aspectDimensionSignature ) );
	public final MatlabParser.aspectFullSignature_return aspectFullSignature() throws RecognitionException {
		MatlabParser.aspectFullSignature_return retval = new MatlabParser.aspectFullSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectTypeSignature542 =null;
		ParserRuleReturnScope aspectTypeSignature543 =null;
		ParserRuleReturnScope aspectDimensionSignature544 =null;
		ParserRuleReturnScope aspectDimensionSignature545 =null;

		RewriteRuleSubtreeStream stream_aspectDimensionSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectDimensionSignature");
		RewriteRuleSubtreeStream stream_aspectTypeSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectTypeSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:724:21: ( aspectTypeSignature -> ^( ASPECTFULLSIGNATURE aspectTypeSignature ) | aspectTypeSignature aspectDimensionSignature -> ^( ASPECTFULLSIGNATURE aspectTypeSignature aspectDimensionSignature ) | aspectDimensionSignature -> ^( ASPECTFULLSIGNATURE aspectDimensionSignature ) )
			int alt135=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				int LA135_1 = input.LA(2);
				if ( (LA135_1==COMMA||LA135_1==RPAREN) ) {
					alt135=1;
				}
				else if ( (LA135_1==LSQUARE) ) {
					alt135=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 135, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case MTIMES:
				{
				int LA135_2 = input.LA(2);
				if ( (LA135_2==COMMA||LA135_2==RPAREN) ) {
					alt135=1;
				}
				else if ( (LA135_2==LSQUARE) ) {
					alt135=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 135, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case DOTDOT:
				{
				int LA135_3 = input.LA(2);
				if ( (LA135_3==COMMA||LA135_3==RPAREN) ) {
					alt135=1;
				}
				else if ( (LA135_3==LSQUARE) ) {
					alt135=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 135, 3, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LSQUARE:
				{
				alt135=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 135, 0, input);
				throw nvae;
			}
			switch (alt135) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:724:23: aspectTypeSignature
					{
					pushFollow(FOLLOW_aspectTypeSignature_in_aspectFullSignature7524);
					aspectTypeSignature542=aspectTypeSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectTypeSignature.add(aspectTypeSignature542.getTree());
					// AST REWRITE
					// elements: aspectTypeSignature
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 724:43: -> ^( ASPECTFULLSIGNATURE aspectTypeSignature )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:724:46: ^( ASPECTFULLSIGNATURE aspectTypeSignature )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTFULLSIGNATURE, "ASPECTFULLSIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_aspectTypeSignature.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:725:23: aspectTypeSignature aspectDimensionSignature
					{
					pushFollow(FOLLOW_aspectTypeSignature_in_aspectFullSignature7556);
					aspectTypeSignature543=aspectTypeSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectTypeSignature.add(aspectTypeSignature543.getTree());
					pushFollow(FOLLOW_aspectDimensionSignature_in_aspectFullSignature7558);
					aspectDimensionSignature544=aspectDimensionSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectDimensionSignature.add(aspectDimensionSignature544.getTree());
					// AST REWRITE
					// elements: aspectDimensionSignature, aspectTypeSignature
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 725:69: -> ^( ASPECTFULLSIGNATURE aspectTypeSignature aspectDimensionSignature )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:725:72: ^( ASPECTFULLSIGNATURE aspectTypeSignature aspectDimensionSignature )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTFULLSIGNATURE, "ASPECTFULLSIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_aspectTypeSignature.nextTree());
						adaptor.addChild(root_1, stream_aspectDimensionSignature.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:726:23: aspectDimensionSignature
					{
					pushFollow(FOLLOW_aspectDimensionSignature_in_aspectFullSignature7593);
					aspectDimensionSignature545=aspectDimensionSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectDimensionSignature.add(aspectDimensionSignature545.getTree());
					// AST REWRITE
					// elements: aspectDimensionSignature
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 726:49: -> ^( ASPECTFULLSIGNATURE aspectDimensionSignature )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:726:52: ^( ASPECTFULLSIGNATURE aspectDimensionSignature )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTFULLSIGNATURE, "ASPECTFULLSIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_aspectDimensionSignature.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectFullSignature"


	public static class aspectGet_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectGet"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:1: aspectGet : wGET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN -> ^( ASPECTGET aspectIdentifier ( aspectFullSignature )? ) ;
	public final MatlabParser.aspectGet_return aspectGet() throws RecognitionException {
		MatlabParser.aspectGet_return retval = new MatlabParser.aspectGet_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN547=null;
		Token COLON549=null;
		Token RPAREN551=null;
		ParserRuleReturnScope wGET546 =null;
		ParserRuleReturnScope aspectIdentifier548 =null;
		ParserRuleReturnScope aspectFullSignature550 =null;

		Object LPAREN547_tree=null;
		Object COLON549_tree=null;
		Object RPAREN551_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wGET=new RewriteRuleSubtreeStream(adaptor,"rule wGET");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:11: ( wGET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN -> ^( ASPECTGET aspectIdentifier ( aspectFullSignature )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:13: wGET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN
			{
			pushFollow(FOLLOW_wGET_in_aspectGet7631);
			wGET546=wGET();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wGET.add(wGET546.getTree());
			LPAREN547=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectGet7633); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN547);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectGet7635);
			aspectIdentifier548=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier548.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:42: ( COLON aspectFullSignature )?
			int alt136=2;
			int LA136_0 = input.LA(1);
			if ( (LA136_0==COLON) ) {
				alt136=1;
			}
			switch (alt136) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:43: COLON aspectFullSignature
					{
					COLON549=(Token)match(input,COLON,FOLLOW_COLON_in_aspectGet7638); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON549);

					pushFollow(FOLLOW_aspectFullSignature_in_aspectGet7640);
					aspectFullSignature550=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature550.getTree());
					}
					break;

			}

			RPAREN551=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectGet7644); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN551);

			// AST REWRITE
			// elements: aspectFullSignature, aspectIdentifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 729:78: -> ^( ASPECTGET aspectIdentifier ( aspectFullSignature )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:81: ^( ASPECTGET aspectIdentifier ( aspectFullSignature )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTGET, "ASPECTGET"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:110: ( aspectFullSignature )?
				if ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectGet"


	public static class aspectSet_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSet"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:1: aspectSet : wSET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN -> ^( ASPECTSET aspectIdentifier ( aspectFullSignature )? ) ;
	public final MatlabParser.aspectSet_return aspectSet() throws RecognitionException {
		MatlabParser.aspectSet_return retval = new MatlabParser.aspectSet_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN553=null;
		Token COLON555=null;
		Token RPAREN557=null;
		ParserRuleReturnScope wSET552 =null;
		ParserRuleReturnScope aspectIdentifier554 =null;
		ParserRuleReturnScope aspectFullSignature556 =null;

		Object LPAREN553_tree=null;
		Object COLON555_tree=null;
		Object RPAREN557_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");
		RewriteRuleSubtreeStream stream_wSET=new RewriteRuleSubtreeStream(adaptor,"rule wSET");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:11: ( wSET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN -> ^( ASPECTSET aspectIdentifier ( aspectFullSignature )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:13: wSET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN
			{
			pushFollow(FOLLOW_wSET_in_aspectSet7666);
			wSET552=wSET();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wSET.add(wSET552.getTree());
			LPAREN553=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectSet7668); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN553);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectSet7670);
			aspectIdentifier554=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier554.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:42: ( COLON aspectFullSignature )?
			int alt137=2;
			int LA137_0 = input.LA(1);
			if ( (LA137_0==COLON) ) {
				alt137=1;
			}
			switch (alt137) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:43: COLON aspectFullSignature
					{
					COLON555=(Token)match(input,COLON,FOLLOW_COLON_in_aspectSet7673); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON555);

					pushFollow(FOLLOW_aspectFullSignature_in_aspectSet7675);
					aspectFullSignature556=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature556.getTree());
					}
					break;

			}

			RPAREN557=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectSet7679); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN557);

			// AST REWRITE
			// elements: aspectIdentifier, aspectFullSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 731:78: -> ^( ASPECTSET aspectIdentifier ( aspectFullSignature )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:81: ^( ASPECTSET aspectIdentifier ( aspectFullSignature )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTSET, "ASPECTSET"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:110: ( aspectFullSignature )?
				if ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSet"


	public static class aspectInput_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectInput"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:1: aspectInput : ( aspectFullSignature ( COMMA aspectFullSignature )* )? -> ( aspectFullSignature )* ;
	public final MatlabParser.aspectInput_return aspectInput() throws RecognitionException {
		MatlabParser.aspectInput_return retval = new MatlabParser.aspectInput_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA559=null;
		ParserRuleReturnScope aspectFullSignature558 =null;
		ParserRuleReturnScope aspectFullSignature560 =null;

		Object COMMA559_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:13: ( ( aspectFullSignature ( COMMA aspectFullSignature )* )? -> ( aspectFullSignature )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:15: ( aspectFullSignature ( COMMA aspectFullSignature )* )?
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:15: ( aspectFullSignature ( COMMA aspectFullSignature )* )?
			int alt139=2;
			int LA139_0 = input.LA(1);
			if ( (LA139_0==DOTDOT||LA139_0==ID||LA139_0==LSQUARE||LA139_0==MTIMES) ) {
				alt139=1;
			}
			switch (alt139) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:16: aspectFullSignature ( COMMA aspectFullSignature )*
					{
					pushFollow(FOLLOW_aspectFullSignature_in_aspectInput7702);
					aspectFullSignature558=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature558.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:36: ( COMMA aspectFullSignature )*
					loop138:
					while (true) {
						int alt138=2;
						int LA138_0 = input.LA(1);
						if ( (LA138_0==COMMA) ) {
							alt138=1;
						}

						switch (alt138) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:37: COMMA aspectFullSignature
							{
							COMMA559=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectInput7705); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA559);

							pushFollow(FOLLOW_aspectFullSignature_in_aspectInput7707);
							aspectFullSignature560=aspectFullSignature();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature560.getTree());
							}
							break;

						default :
							break loop138;
						}
					}

					}
					break;

			}

			// AST REWRITE
			// elements: aspectFullSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 733:67: -> ( aspectFullSignature )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:70: ( aspectFullSignature )*
				while ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectInput"


	public static class aspectOutput_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectOutput"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:1: aspectOutput : ( aspectFullSignature ( COMMA aspectFullSignature )* )? -> ( aspectFullSignature )* ;
	public final MatlabParser.aspectOutput_return aspectOutput() throws RecognitionException {
		MatlabParser.aspectOutput_return retval = new MatlabParser.aspectOutput_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA562=null;
		ParserRuleReturnScope aspectFullSignature561 =null;
		ParserRuleReturnScope aspectFullSignature563 =null;

		Object COMMA562_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:14: ( ( aspectFullSignature ( COMMA aspectFullSignature )* )? -> ( aspectFullSignature )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:16: ( aspectFullSignature ( COMMA aspectFullSignature )* )?
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:16: ( aspectFullSignature ( COMMA aspectFullSignature )* )?
			int alt141=2;
			int LA141_0 = input.LA(1);
			if ( (LA141_0==DOTDOT||LA141_0==ID||LA141_0==LSQUARE||LA141_0==MTIMES) ) {
				alt141=1;
			}
			switch (alt141) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:17: aspectFullSignature ( COMMA aspectFullSignature )*
					{
					pushFollow(FOLLOW_aspectFullSignature_in_aspectOutput7728);
					aspectFullSignature561=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature561.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:37: ( COMMA aspectFullSignature )*
					loop140:
					while (true) {
						int alt140=2;
						int LA140_0 = input.LA(1);
						if ( (LA140_0==COMMA) ) {
							alt140=1;
						}

						switch (alt140) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:38: COMMA aspectFullSignature
							{
							COMMA562=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectOutput7731); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA562);

							pushFollow(FOLLOW_aspectFullSignature_in_aspectOutput7733);
							aspectFullSignature563=aspectFullSignature();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature563.getTree());
							}
							break;

						default :
							break loop140;
						}
					}

					}
					break;

			}

			// AST REWRITE
			// elements: aspectFullSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 735:68: -> ( aspectFullSignature )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:72: ( aspectFullSignature )*
				while ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectOutput"


	public static class aspectCall_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectCall"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:1: aspectCall : wCALL LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN -> ^( ASPECTCALL aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) ) ;
	public final MatlabParser.aspectCall_return aspectCall() throws RecognitionException {
		MatlabParser.aspectCall_return retval = new MatlabParser.aspectCall_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN565=null;
		Token LPAREN567=null;
		Token RPAREN569=null;
		Token COLON570=null;
		Token RPAREN572=null;
		ParserRuleReturnScope wCALL564 =null;
		ParserRuleReturnScope aspectIdentifier566 =null;
		ParserRuleReturnScope aspectInput568 =null;
		ParserRuleReturnScope aspectOutput571 =null;

		Object LPAREN565_tree=null;
		Object LPAREN567_tree=null;
		Object RPAREN569_tree=null;
		Object COLON570_tree=null;
		Object RPAREN572_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectInput=new RewriteRuleSubtreeStream(adaptor,"rule aspectInput");
		RewriteRuleSubtreeStream stream_aspectOutput=new RewriteRuleSubtreeStream(adaptor,"rule aspectOutput");
		RewriteRuleSubtreeStream stream_wCALL=new RewriteRuleSubtreeStream(adaptor,"rule wCALL");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:12: ( wCALL LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN -> ^( ASPECTCALL aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:14: wCALL LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN
			{
			pushFollow(FOLLOW_wCALL_in_aspectCall7754);
			wCALL564=wCALL();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wCALL.add(wCALL564.getTree());
			LPAREN565=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectCall7756); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN565);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectCall7758);
			aspectIdentifier566=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier566.getTree());
			LPAREN567=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectCall7760); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN567);

			pushFollow(FOLLOW_aspectInput_in_aspectCall7762);
			aspectInput568=aspectInput();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectInput.add(aspectInput568.getTree());
			RPAREN569=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectCall7764); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN569);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:70: ( COLON aspectOutput )?
			int alt142=2;
			int LA142_0 = input.LA(1);
			if ( (LA142_0==COLON) ) {
				alt142=1;
			}
			switch (alt142) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:71: COLON aspectOutput
					{
					COLON570=(Token)match(input,COLON,FOLLOW_COLON_in_aspectCall7767); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON570);

					pushFollow(FOLLOW_aspectOutput_in_aspectCall7769);
					aspectOutput571=aspectOutput();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectOutput.add(aspectOutput571.getTree());
					}
					break;

			}

			RPAREN572=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectCall7773); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN572);

			// AST REWRITE
			// elements: aspectIdentifier, aspectInput, aspectOutput
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 737:99: -> ^( ASPECTCALL aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:102: ^( ASPECTCALL aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTCALL, "ASPECTCALL"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:132: ^( ASPECTINPUT ( aspectInput )? )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTINPUT, "ASPECTINPUT"), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:146: ( aspectInput )?
				if ( stream_aspectInput.hasNext() ) {
					adaptor.addChild(root_2, stream_aspectInput.nextTree());
				}
				stream_aspectInput.reset();

				adaptor.addChild(root_1, root_2);
				}

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:162: ^( ASPECTOUTPUT ( aspectOutput )? )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTOUTPUT, "ASPECTOUTPUT"), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:177: ( aspectOutput )?
				if ( stream_aspectOutput.hasNext() ) {
					adaptor.addChild(root_2, stream_aspectOutput.nextTree());
				}
				stream_aspectOutput.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectCall"


	public static class aspectExecution_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExecution"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:1: aspectExecution : wEXECUTION LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN -> ^( ASPECTEXECUTION aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) ) ;
	public final MatlabParser.aspectExecution_return aspectExecution() throws RecognitionException {
		MatlabParser.aspectExecution_return retval = new MatlabParser.aspectExecution_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN574=null;
		Token LPAREN576=null;
		Token RPAREN578=null;
		Token COLON579=null;
		Token RPAREN581=null;
		ParserRuleReturnScope wEXECUTION573 =null;
		ParserRuleReturnScope aspectIdentifier575 =null;
		ParserRuleReturnScope aspectInput577 =null;
		ParserRuleReturnScope aspectOutput580 =null;

		Object LPAREN574_tree=null;
		Object LPAREN576_tree=null;
		Object RPAREN578_tree=null;
		Object COLON579_tree=null;
		Object RPAREN581_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectInput=new RewriteRuleSubtreeStream(adaptor,"rule aspectInput");
		RewriteRuleSubtreeStream stream_aspectOutput=new RewriteRuleSubtreeStream(adaptor,"rule aspectOutput");
		RewriteRuleSubtreeStream stream_wEXECUTION=new RewriteRuleSubtreeStream(adaptor,"rule wEXECUTION");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:17: ( wEXECUTION LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN -> ^( ASPECTEXECUTION aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:19: wEXECUTION LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN
			{
			pushFollow(FOLLOW_wEXECUTION_in_aspectExecution7808);
			wEXECUTION573=wEXECUTION();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wEXECUTION.add(wEXECUTION573.getTree());
			LPAREN574=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectExecution7810); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN574);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectExecution7812);
			aspectIdentifier575=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier575.getTree());
			LPAREN576=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectExecution7814); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN576);

			pushFollow(FOLLOW_aspectInput_in_aspectExecution7816);
			aspectInput577=aspectInput();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectInput.add(aspectInput577.getTree());
			RPAREN578=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectExecution7818); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN578);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:80: ( COLON aspectOutput )?
			int alt143=2;
			int LA143_0 = input.LA(1);
			if ( (LA143_0==COLON) ) {
				alt143=1;
			}
			switch (alt143) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:81: COLON aspectOutput
					{
					COLON579=(Token)match(input,COLON,FOLLOW_COLON_in_aspectExecution7821); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON579);

					pushFollow(FOLLOW_aspectOutput_in_aspectExecution7823);
					aspectOutput580=aspectOutput();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectOutput.add(aspectOutput580.getTree());
					}
					break;

			}

			RPAREN581=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectExecution7827); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN581);

			// AST REWRITE
			// elements: aspectInput, aspectOutput, aspectIdentifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 739:109: -> ^( ASPECTEXECUTION aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:112: ^( ASPECTEXECUTION aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTEXECUTION, "ASPECTEXECUTION"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:147: ^( ASPECTINPUT ( aspectInput )? )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTINPUT, "ASPECTINPUT"), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:161: ( aspectInput )?
				if ( stream_aspectInput.hasNext() ) {
					adaptor.addChild(root_2, stream_aspectInput.nextTree());
				}
				stream_aspectInput.reset();

				adaptor.addChild(root_1, root_2);
				}

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:177: ^( ASPECTOUTPUT ( aspectOutput )? )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTOUTPUT, "ASPECTOUTPUT"), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:192: ( aspectOutput )?
				if ( stream_aspectOutput.hasNext() ) {
					adaptor.addChild(root_2, stream_aspectOutput.nextTree());
				}
				stream_aspectOutput.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExecution"


	public static class aspectMainExecution_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectMainExecution"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:741:1: aspectMainExecution : wMAINEXECUTION LPAREN RPAREN -> ASPECTMAINEXECUTION ;
	public final MatlabParser.aspectMainExecution_return aspectMainExecution() throws RecognitionException {
		MatlabParser.aspectMainExecution_return retval = new MatlabParser.aspectMainExecution_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN583=null;
		Token RPAREN584=null;
		ParserRuleReturnScope wMAINEXECUTION582 =null;

		Object LPAREN583_tree=null;
		Object RPAREN584_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wMAINEXECUTION=new RewriteRuleSubtreeStream(adaptor,"rule wMAINEXECUTION");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:741:21: ( wMAINEXECUTION LPAREN RPAREN -> ASPECTMAINEXECUTION )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:741:23: wMAINEXECUTION LPAREN RPAREN
			{
			pushFollow(FOLLOW_wMAINEXECUTION_in_aspectMainExecution7862);
			wMAINEXECUTION582=wMAINEXECUTION();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wMAINEXECUTION.add(wMAINEXECUTION582.getTree());
			LPAREN583=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectMainExecution7864); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN583);

			RPAREN584=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectMainExecution7866); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN584);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 741:52: -> ASPECTMAINEXECUTION
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ASPECTMAINEXECUTION, "ASPECTMAINEXECUTION"));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectMainExecution"


	public static class aspectLoopType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectLoopType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:743:1: aspectLoopType : ( wFOR -> wFOR | wWHILE -> wWHILE | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectLoopType_return aspectLoopType() throws RecognitionException {
		MatlabParser.aspectLoopType_return retval = new MatlabParser.aspectLoopType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wFOR585 =null;
		ParserRuleReturnScope wWHILE586 =null;
		ParserRuleReturnScope wSTAR587 =null;
		ParserRuleReturnScope wDOTDOT588 =null;

		RewriteRuleSubtreeStream stream_wFOR=new RewriteRuleSubtreeStream(adaptor,"rule wFOR");
		RewriteRuleSubtreeStream stream_wWHILE=new RewriteRuleSubtreeStream(adaptor,"rule wWHILE");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:743:16: ( wFOR -> wFOR | wWHILE -> wWHILE | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt144=4;
			switch ( input.LA(1) ) {
			case FOR:
				{
				alt144=1;
				}
				break;
			case WHILE:
				{
				alt144=2;
				}
				break;
			case MTIMES:
				{
				alt144=3;
				}
				break;
			case DOTDOT:
				{
				alt144=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 144, 0, input);
				throw nvae;
			}
			switch (alt144) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:743:18: wFOR
					{
					pushFollow(FOLLOW_wFOR_in_aspectLoopType7879);
					wFOR585=wFOR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wFOR.add(wFOR585.getTree());
					// AST REWRITE
					// elements: wFOR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 743:23: -> wFOR
					{
						adaptor.addChild(root_0, stream_wFOR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:744:18: wWHILE
					{
					pushFollow(FOLLOW_wWHILE_in_aspectLoopType7902);
					wWHILE586=wWHILE();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wWHILE.add(wWHILE586.getTree());
					// AST REWRITE
					// elements: wWHILE
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 744:25: -> wWHILE
					{
						adaptor.addChild(root_0, stream_wWHILE.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:745:18: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectLoopType7925);
					wSTAR587=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR587.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 745:24: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:746:18: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectLoopType7948);
					wDOTDOT588=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT588.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 746:26: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectLoopType"


	public static class aspectLoop_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectLoop"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:1: aspectLoop : wLOOP LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOP ( aspectLoopType )? aspectIdentifier ) ;
	public final MatlabParser.aspectLoop_return aspectLoop() throws RecognitionException {
		MatlabParser.aspectLoop_return retval = new MatlabParser.aspectLoop_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN590=null;
		Token COLON592=null;
		Token RPAREN594=null;
		ParserRuleReturnScope wLOOP589 =null;
		ParserRuleReturnScope aspectLoopType591 =null;
		ParserRuleReturnScope aspectIdentifier593 =null;

		Object LPAREN590_tree=null;
		Object COLON592_tree=null;
		Object RPAREN594_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wLOOP=new RewriteRuleSubtreeStream(adaptor,"rule wLOOP");
		RewriteRuleSubtreeStream stream_aspectLoopType=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopType");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:12: ( wLOOP LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOP ( aspectLoopType )? aspectIdentifier ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:14: wLOOP LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN
			{
			pushFollow(FOLLOW_wLOOP_in_aspectLoop7976);
			wLOOP589=wLOOP();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wLOOP.add(wLOOP589.getTree());
			LPAREN590=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectLoop7978); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN590);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:27: ( aspectLoopType COLON )?
			int alt145=2;
			switch ( input.LA(1) ) {
				case FOR:
				case WHILE:
					{
					alt145=1;
					}
					break;
				case MTIMES:
					{
					int LA145_2 = input.LA(2);
					if ( (LA145_2==COLON) ) {
						alt145=1;
					}
					}
					break;
				case DOTDOT:
					{
					int LA145_3 = input.LA(2);
					if ( (LA145_3==COLON) ) {
						alt145=1;
					}
					}
					break;
			}
			switch (alt145) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:28: aspectLoopType COLON
					{
					pushFollow(FOLLOW_aspectLoopType_in_aspectLoop7981);
					aspectLoopType591=aspectLoopType();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopType.add(aspectLoopType591.getTree());
					COLON592=(Token)match(input,COLON,FOLLOW_COLON_in_aspectLoop7983); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON592);

					}
					break;

			}

			pushFollow(FOLLOW_aspectIdentifier_in_aspectLoop7987);
			aspectIdentifier593=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier593.getTree());
			RPAREN594=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectLoop7989); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN594);

			// AST REWRITE
			// elements: aspectIdentifier, aspectLoopType
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 749:75: -> ^( ASPECTLOOP ( aspectLoopType )? aspectIdentifier )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:78: ^( ASPECTLOOP ( aspectLoopType )? aspectIdentifier )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTLOOP, "ASPECTLOOP"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:91: ( aspectLoopType )?
				if ( stream_aspectLoopType.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectLoopType.nextTree());
				}
				stream_aspectLoopType.reset();

				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectLoop"


	public static class aspectLoopBody_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectLoopBody"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:1: aspectLoopBody : wLOOPBODY LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOPBODY ( aspectLoopType )? aspectIdentifier ) ;
	public final MatlabParser.aspectLoopBody_return aspectLoopBody() throws RecognitionException {
		MatlabParser.aspectLoopBody_return retval = new MatlabParser.aspectLoopBody_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN596=null;
		Token COLON598=null;
		Token RPAREN600=null;
		ParserRuleReturnScope wLOOPBODY595 =null;
		ParserRuleReturnScope aspectLoopType597 =null;
		ParserRuleReturnScope aspectIdentifier599 =null;

		Object LPAREN596_tree=null;
		Object COLON598_tree=null;
		Object RPAREN600_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wLOOPBODY=new RewriteRuleSubtreeStream(adaptor,"rule wLOOPBODY");
		RewriteRuleSubtreeStream stream_aspectLoopType=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopType");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:16: ( wLOOPBODY LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOPBODY ( aspectLoopType )? aspectIdentifier ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:18: wLOOPBODY LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN
			{
			pushFollow(FOLLOW_wLOOPBODY_in_aspectLoopBody8010);
			wLOOPBODY595=wLOOPBODY();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wLOOPBODY.add(wLOOPBODY595.getTree());
			LPAREN596=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectLoopBody8012); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN596);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:35: ( aspectLoopType COLON )?
			int alt146=2;
			switch ( input.LA(1) ) {
				case FOR:
				case WHILE:
					{
					alt146=1;
					}
					break;
				case MTIMES:
					{
					int LA146_2 = input.LA(2);
					if ( (LA146_2==COLON) ) {
						alt146=1;
					}
					}
					break;
				case DOTDOT:
					{
					int LA146_3 = input.LA(2);
					if ( (LA146_3==COLON) ) {
						alt146=1;
					}
					}
					break;
			}
			switch (alt146) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:36: aspectLoopType COLON
					{
					pushFollow(FOLLOW_aspectLoopType_in_aspectLoopBody8015);
					aspectLoopType597=aspectLoopType();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopType.add(aspectLoopType597.getTree());
					COLON598=(Token)match(input,COLON,FOLLOW_COLON_in_aspectLoopBody8017); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON598);

					}
					break;

			}

			pushFollow(FOLLOW_aspectIdentifier_in_aspectLoopBody8021);
			aspectIdentifier599=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier599.getTree());
			RPAREN600=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectLoopBody8023); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN600);

			// AST REWRITE
			// elements: aspectIdentifier, aspectLoopType
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 751:83: -> ^( ASPECTLOOPBODY ( aspectLoopType )? aspectIdentifier )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:86: ^( ASPECTLOOPBODY ( aspectLoopType )? aspectIdentifier )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTLOOPBODY, "ASPECTLOOPBODY"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:103: ( aspectLoopType )?
				if ( stream_aspectLoopType.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectLoopType.nextTree());
				}
				stream_aspectLoopType.reset();

				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectLoopBody"


	public static class aspectLoopHead_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectLoopHead"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:1: aspectLoopHead : wLOOPHEAD LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOPHEAD ( aspectLoopType )? aspectIdentifier ) ;
	public final MatlabParser.aspectLoopHead_return aspectLoopHead() throws RecognitionException {
		MatlabParser.aspectLoopHead_return retval = new MatlabParser.aspectLoopHead_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN602=null;
		Token COLON604=null;
		Token RPAREN606=null;
		ParserRuleReturnScope wLOOPHEAD601 =null;
		ParserRuleReturnScope aspectLoopType603 =null;
		ParserRuleReturnScope aspectIdentifier605 =null;

		Object LPAREN602_tree=null;
		Object COLON604_tree=null;
		Object RPAREN606_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wLOOPHEAD=new RewriteRuleSubtreeStream(adaptor,"rule wLOOPHEAD");
		RewriteRuleSubtreeStream stream_aspectLoopType=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopType");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:16: ( wLOOPHEAD LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOPHEAD ( aspectLoopType )? aspectIdentifier ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:18: wLOOPHEAD LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN
			{
			pushFollow(FOLLOW_wLOOPHEAD_in_aspectLoopHead8044);
			wLOOPHEAD601=wLOOPHEAD();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wLOOPHEAD.add(wLOOPHEAD601.getTree());
			LPAREN602=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectLoopHead8046); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN602);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:35: ( aspectLoopType COLON )?
			int alt147=2;
			switch ( input.LA(1) ) {
				case FOR:
				case WHILE:
					{
					alt147=1;
					}
					break;
				case MTIMES:
					{
					int LA147_2 = input.LA(2);
					if ( (LA147_2==COLON) ) {
						alt147=1;
					}
					}
					break;
				case DOTDOT:
					{
					int LA147_3 = input.LA(2);
					if ( (LA147_3==COLON) ) {
						alt147=1;
					}
					}
					break;
			}
			switch (alt147) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:36: aspectLoopType COLON
					{
					pushFollow(FOLLOW_aspectLoopType_in_aspectLoopHead8049);
					aspectLoopType603=aspectLoopType();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopType.add(aspectLoopType603.getTree());
					COLON604=(Token)match(input,COLON,FOLLOW_COLON_in_aspectLoopHead8051); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON604);

					}
					break;

			}

			pushFollow(FOLLOW_aspectIdentifier_in_aspectLoopHead8055);
			aspectIdentifier605=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier605.getTree());
			RPAREN606=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectLoopHead8057); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN606);

			// AST REWRITE
			// elements: aspectLoopType, aspectIdentifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 753:83: -> ^( ASPECTLOOPHEAD ( aspectLoopType )? aspectIdentifier )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:86: ^( ASPECTLOOPHEAD ( aspectLoopType )? aspectIdentifier )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTLOOPHEAD, "ASPECTLOOPHEAD"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:103: ( aspectLoopType )?
				if ( stream_aspectLoopType.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectLoopType.nextTree());
				}
				stream_aspectLoopType.reset();

				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectLoopHead"


	public static class aspectPartSelector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPartSelector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:755:1: aspectPartSelector : ( wVAR -> wVAR | wSTR -> wSTR | wNUM -> wNUM | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectPartSelector_return aspectPartSelector() throws RecognitionException {
		MatlabParser.aspectPartSelector_return retval = new MatlabParser.aspectPartSelector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wVAR607 =null;
		ParserRuleReturnScope wSTR608 =null;
		ParserRuleReturnScope wNUM609 =null;
		ParserRuleReturnScope wSTAR610 =null;
		ParserRuleReturnScope wDOTDOT611 =null;

		RewriteRuleSubtreeStream stream_wVAR=new RewriteRuleSubtreeStream(adaptor,"rule wVAR");
		RewriteRuleSubtreeStream stream_wNUM=new RewriteRuleSubtreeStream(adaptor,"rule wNUM");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");
		RewriteRuleSubtreeStream stream_wSTR=new RewriteRuleSubtreeStream(adaptor,"rule wSTR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:755:20: ( wVAR -> wVAR | wSTR -> wSTR | wNUM -> wNUM | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt148=5;
			int LA148_0 = input.LA(1);
			if ( (LA148_0==ID) && (((Keyword_IdFollows("var"))||(Keyword_IdFollows("str"))||(Keyword_IdFollows("num"))))) {
				int LA148_1 = input.LA(2);
				if ( ((Keyword_IdFollows("var"))) ) {
					alt148=1;
				}
				else if ( ((Keyword_IdFollows("str"))) ) {
					alt148=2;
				}
				else if ( ((Keyword_IdFollows("num"))) ) {
					alt148=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 148, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA148_0==MTIMES) ) {
				alt148=4;
			}
			else if ( (LA148_0==DOTDOT) ) {
				alt148=5;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 148, 0, input);
				throw nvae;
			}

			switch (alt148) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:755:22: wVAR
					{
					pushFollow(FOLLOW_wVAR_in_aspectPartSelector8078);
					wVAR607=wVAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wVAR.add(wVAR607.getTree());
					// AST REWRITE
					// elements: wVAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 755:27: -> wVAR
					{
						adaptor.addChild(root_0, stream_wVAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:756:22: wSTR
					{
					pushFollow(FOLLOW_wSTR_in_aspectPartSelector8105);
					wSTR608=wSTR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTR.add(wSTR608.getTree());
					// AST REWRITE
					// elements: wSTR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 756:27: -> wSTR
					{
						adaptor.addChild(root_0, stream_wSTR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:757:22: wNUM
					{
					pushFollow(FOLLOW_wNUM_in_aspectPartSelector8132);
					wNUM609=wNUM();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wNUM.add(wNUM609.getTree());
					// AST REWRITE
					// elements: wNUM
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 757:27: -> wNUM
					{
						adaptor.addChild(root_0, stream_wNUM.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:758:22: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectPartSelector8159);
					wSTAR610=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR610.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 758:28: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:759:22: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectPartSelector8186);
					wDOTDOT611=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT611.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 759:30: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPartSelector"


	public static class aspectSimpleSelector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSimpleSelector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:762:1: aspectSimpleSelector : aspectPartSelector -> ^( ASPECTSELECTORSIMPLE aspectPartSelector ) ;
	public final MatlabParser.aspectSimpleSelector_return aspectSimpleSelector() throws RecognitionException {
		MatlabParser.aspectSimpleSelector_return retval = new MatlabParser.aspectSimpleSelector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectPartSelector612 =null;

		RewriteRuleSubtreeStream stream_aspectPartSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectPartSelector");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:762:22: ( aspectPartSelector -> ^( ASPECTSELECTORSIMPLE aspectPartSelector ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:762:24: aspectPartSelector
			{
			pushFollow(FOLLOW_aspectPartSelector_in_aspectSimpleSelector8218);
			aspectPartSelector612=aspectPartSelector();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectPartSelector.add(aspectPartSelector612.getTree());
			// AST REWRITE
			// elements: aspectPartSelector
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 762:43: -> ^( ASPECTSELECTORSIMPLE aspectPartSelector )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:762:46: ^( ASPECTSELECTORSIMPLE aspectPartSelector )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTSELECTORSIMPLE, "ASPECTSELECTORSIMPLE"), root_1);
				adaptor.addChild(root_1, stream_aspectPartSelector.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSimpleSelector"


	public static class aspectCompoundSelector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectCompoundSelector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:1: aspectCompoundSelector : LSQUARE ( aspectPartSelector ( COMMA aspectPartSelector )* )? RSQUARE -> ^( ASPECTSELECTORCOMPOUND ( aspectPartSelector )* ) ;
	public final MatlabParser.aspectCompoundSelector_return aspectCompoundSelector() throws RecognitionException {
		MatlabParser.aspectCompoundSelector_return retval = new MatlabParser.aspectCompoundSelector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE613=null;
		Token COMMA615=null;
		Token RSQUARE617=null;
		ParserRuleReturnScope aspectPartSelector614 =null;
		ParserRuleReturnScope aspectPartSelector616 =null;

		Object LSQUARE613_tree=null;
		Object COMMA615_tree=null;
		Object RSQUARE617_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_aspectPartSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectPartSelector");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:24: ( LSQUARE ( aspectPartSelector ( COMMA aspectPartSelector )* )? RSQUARE -> ^( ASPECTSELECTORCOMPOUND ( aspectPartSelector )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:26: LSQUARE ( aspectPartSelector ( COMMA aspectPartSelector )* )? RSQUARE
			{
			LSQUARE613=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_aspectCompoundSelector8235); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE613);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:34: ( aspectPartSelector ( COMMA aspectPartSelector )* )?
			int alt150=2;
			int LA150_0 = input.LA(1);
			if ( (LA150_0==ID) && (((Keyword_IdFollows("var"))||(Keyword_IdFollows("str"))||(Keyword_IdFollows("num"))))) {
				alt150=1;
			}
			else if ( (LA150_0==DOTDOT||LA150_0==MTIMES) ) {
				alt150=1;
			}
			switch (alt150) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:35: aspectPartSelector ( COMMA aspectPartSelector )*
					{
					pushFollow(FOLLOW_aspectPartSelector_in_aspectCompoundSelector8238);
					aspectPartSelector614=aspectPartSelector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectPartSelector.add(aspectPartSelector614.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:54: ( COMMA aspectPartSelector )*
					loop149:
					while (true) {
						int alt149=2;
						int LA149_0 = input.LA(1);
						if ( (LA149_0==COMMA) ) {
							alt149=1;
						}

						switch (alt149) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:55: COMMA aspectPartSelector
							{
							COMMA615=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectCompoundSelector8241); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA615);

							pushFollow(FOLLOW_aspectPartSelector_in_aspectCompoundSelector8243);
							aspectPartSelector616=aspectPartSelector();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectPartSelector.add(aspectPartSelector616.getTree());
							}
							break;

						default :
							break loop149;
						}
					}

					}
					break;

			}

			RSQUARE617=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_aspectCompoundSelector8249); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE617);

			// AST REWRITE
			// elements: aspectPartSelector
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 764:92: -> ^( ASPECTSELECTORCOMPOUND ( aspectPartSelector )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:95: ^( ASPECTSELECTORCOMPOUND ( aspectPartSelector )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTSELECTORCOMPOUND, "ASPECTSELECTORCOMPOUND"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:120: ( aspectPartSelector )*
				while ( stream_aspectPartSelector.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectPartSelector.nextTree());
				}
				stream_aspectPartSelector.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectCompoundSelector"


	public static class aspectSelector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSelector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:766:1: aspectSelector : ( aspectSimpleSelector -> aspectSimpleSelector | aspectCompoundSelector -> aspectCompoundSelector );
	public final MatlabParser.aspectSelector_return aspectSelector() throws RecognitionException {
		MatlabParser.aspectSelector_return retval = new MatlabParser.aspectSelector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectSimpleSelector618 =null;
		ParserRuleReturnScope aspectCompoundSelector619 =null;

		RewriteRuleSubtreeStream stream_aspectCompoundSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectCompoundSelector");
		RewriteRuleSubtreeStream stream_aspectSimpleSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectSimpleSelector");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:766:16: ( aspectSimpleSelector -> aspectSimpleSelector | aspectCompoundSelector -> aspectCompoundSelector )
			int alt151=2;
			int LA151_0 = input.LA(1);
			if ( (LA151_0==ID) && (((Keyword_IdFollows("var"))||(Keyword_IdFollows("str"))||(Keyword_IdFollows("num"))))) {
				alt151=1;
			}
			else if ( (LA151_0==DOTDOT||LA151_0==MTIMES) ) {
				alt151=1;
			}
			else if ( (LA151_0==LSQUARE) ) {
				alt151=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 151, 0, input);
				throw nvae;
			}

			switch (alt151) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:766:18: aspectSimpleSelector
					{
					pushFollow(FOLLOW_aspectSimpleSelector_in_aspectSelector8268);
					aspectSimpleSelector618=aspectSimpleSelector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectSimpleSelector.add(aspectSimpleSelector618.getTree());
					// AST REWRITE
					// elements: aspectSimpleSelector
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 766:39: -> aspectSimpleSelector
					{
						adaptor.addChild(root_0, stream_aspectSimpleSelector.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:767:18: aspectCompoundSelector
					{
					pushFollow(FOLLOW_aspectCompoundSelector_in_aspectSelector8291);
					aspectCompoundSelector619=aspectCompoundSelector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectCompoundSelector.add(aspectCompoundSelector619.getTree());
					// AST REWRITE
					// elements: aspectCompoundSelector
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 767:41: -> aspectCompoundSelector
					{
						adaptor.addChild(root_0, stream_aspectCompoundSelector.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSelector"


	public static class aspectAnnotate_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectAnnotate"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:1: aspectAnnotate : wANNOTATE LPAREN aspectIdentifier LPAREN ( aspectSelector ( COMMA aspectSelector )* )? RPAREN RPAREN -> ^( ASPECTANNOTATE aspectIdentifier ( aspectSelector )* ) ;
	public final MatlabParser.aspectAnnotate_return aspectAnnotate() throws RecognitionException {
		MatlabParser.aspectAnnotate_return retval = new MatlabParser.aspectAnnotate_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN621=null;
		Token LPAREN623=null;
		Token COMMA625=null;
		Token RPAREN627=null;
		Token RPAREN628=null;
		ParserRuleReturnScope wANNOTATE620 =null;
		ParserRuleReturnScope aspectIdentifier622 =null;
		ParserRuleReturnScope aspectSelector624 =null;
		ParserRuleReturnScope aspectSelector626 =null;

		Object LPAREN621_tree=null;
		Object LPAREN623_tree=null;
		Object COMMA625_tree=null;
		Object RPAREN627_tree=null;
		Object RPAREN628_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectSelector");
		RewriteRuleSubtreeStream stream_wANNOTATE=new RewriteRuleSubtreeStream(adaptor,"rule wANNOTATE");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:16: ( wANNOTATE LPAREN aspectIdentifier LPAREN ( aspectSelector ( COMMA aspectSelector )* )? RPAREN RPAREN -> ^( ASPECTANNOTATE aspectIdentifier ( aspectSelector )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:18: wANNOTATE LPAREN aspectIdentifier LPAREN ( aspectSelector ( COMMA aspectSelector )* )? RPAREN RPAREN
			{
			pushFollow(FOLLOW_wANNOTATE_in_aspectAnnotate8319);
			wANNOTATE620=wANNOTATE();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wANNOTATE.add(wANNOTATE620.getTree());
			LPAREN621=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectAnnotate8321); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN621);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectAnnotate8323);
			aspectIdentifier622=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier622.getTree());
			LPAREN623=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectAnnotate8325); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN623);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:59: ( aspectSelector ( COMMA aspectSelector )* )?
			int alt153=2;
			int LA153_0 = input.LA(1);
			if ( (LA153_0==ID) && (((Keyword_IdFollows("var"))||(Keyword_IdFollows("str"))||(Keyword_IdFollows("num"))))) {
				alt153=1;
			}
			else if ( (LA153_0==DOTDOT||LA153_0==LSQUARE||LA153_0==MTIMES) ) {
				alt153=1;
			}
			switch (alt153) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:60: aspectSelector ( COMMA aspectSelector )*
					{
					pushFollow(FOLLOW_aspectSelector_in_aspectAnnotate8328);
					aspectSelector624=aspectSelector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectSelector.add(aspectSelector624.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:75: ( COMMA aspectSelector )*
					loop152:
					while (true) {
						int alt152=2;
						int LA152_0 = input.LA(1);
						if ( (LA152_0==COMMA) ) {
							alt152=1;
						}

						switch (alt152) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:76: COMMA aspectSelector
							{
							COMMA625=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectAnnotate8331); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA625);

							pushFollow(FOLLOW_aspectSelector_in_aspectAnnotate8333);
							aspectSelector626=aspectSelector();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectSelector.add(aspectSelector626.getTree());
							}
							break;

						default :
							break loop152;
						}
					}

					}
					break;

			}

			RPAREN627=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectAnnotate8339); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN627);

			RPAREN628=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectAnnotate8341); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN628);

			// AST REWRITE
			// elements: aspectSelector, aspectIdentifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 770:115: -> ^( ASPECTANNOTATE aspectIdentifier ( aspectSelector )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:118: ^( ASPECTANNOTATE aspectIdentifier ( aspectSelector )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTANNOTATE, "ASPECTANNOTATE"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:152: ( aspectSelector )*
				while ( stream_aspectSelector.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectSelector.nextTree());
				}
				stream_aspectSelector.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectAnnotate"


	public static class aspectOperatorType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectOperatorType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:772:1: aspectOperatorType : ( wPLUS -> wPLUS | wMINUS -> wMINUS | wMTIMES -> wMTIMES | wTIMES -> wTIMES | wMRDIV -> wMRDIV | wRDIV -> wRDIV | wMLDIV -> wMLDIV | wLDIV -> wLDIV | wMPOW -> wMPOW | wPOW -> wPOW | wCTRANS -> CTRANS | wTRANS -> wTRANS );
	public final MatlabParser.aspectOperatorType_return aspectOperatorType() throws RecognitionException {
		MatlabParser.aspectOperatorType_return retval = new MatlabParser.aspectOperatorType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wPLUS629 =null;
		ParserRuleReturnScope wMINUS630 =null;
		ParserRuleReturnScope wMTIMES631 =null;
		ParserRuleReturnScope wTIMES632 =null;
		ParserRuleReturnScope wMRDIV633 =null;
		ParserRuleReturnScope wRDIV634 =null;
		ParserRuleReturnScope wMLDIV635 =null;
		ParserRuleReturnScope wLDIV636 =null;
		ParserRuleReturnScope wMPOW637 =null;
		ParserRuleReturnScope wPOW638 =null;
		ParserRuleReturnScope wCTRANS639 =null;
		ParserRuleReturnScope wTRANS640 =null;

		RewriteRuleSubtreeStream stream_wMRDIV=new RewriteRuleSubtreeStream(adaptor,"rule wMRDIV");
		RewriteRuleSubtreeStream stream_wPLUS=new RewriteRuleSubtreeStream(adaptor,"rule wPLUS");
		RewriteRuleSubtreeStream stream_wMPOW=new RewriteRuleSubtreeStream(adaptor,"rule wMPOW");
		RewriteRuleSubtreeStream stream_wRDIV=new RewriteRuleSubtreeStream(adaptor,"rule wRDIV");
		RewriteRuleSubtreeStream stream_wPOW=new RewriteRuleSubtreeStream(adaptor,"rule wPOW");
		RewriteRuleSubtreeStream stream_wTRANS=new RewriteRuleSubtreeStream(adaptor,"rule wTRANS");
		RewriteRuleSubtreeStream stream_wMINUS=new RewriteRuleSubtreeStream(adaptor,"rule wMINUS");
		RewriteRuleSubtreeStream stream_wMLDIV=new RewriteRuleSubtreeStream(adaptor,"rule wMLDIV");
		RewriteRuleSubtreeStream stream_wMTIMES=new RewriteRuleSubtreeStream(adaptor,"rule wMTIMES");
		RewriteRuleSubtreeStream stream_wLDIV=new RewriteRuleSubtreeStream(adaptor,"rule wLDIV");
		RewriteRuleSubtreeStream stream_wCTRANS=new RewriteRuleSubtreeStream(adaptor,"rule wCTRANS");
		RewriteRuleSubtreeStream stream_wTIMES=new RewriteRuleSubtreeStream(adaptor,"rule wTIMES");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:772:20: ( wPLUS -> wPLUS | wMINUS -> wMINUS | wMTIMES -> wMTIMES | wTIMES -> wTIMES | wMRDIV -> wMRDIV | wRDIV -> wRDIV | wMLDIV -> wMLDIV | wLDIV -> wLDIV | wMPOW -> wMPOW | wPOW -> wPOW | wCTRANS -> CTRANS | wTRANS -> wTRANS )
			int alt154=12;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt154=1;
				}
				break;
			case MINUS:
				{
				alt154=2;
				}
				break;
			case MTIMES:
				{
				alt154=3;
				}
				break;
			case TIMES:
				{
				alt154=4;
				}
				break;
			case MRDIV:
				{
				alt154=5;
				}
				break;
			case RDIV:
				{
				alt154=6;
				}
				break;
			case MLDIV:
				{
				alt154=7;
				}
				break;
			case LDIV:
				{
				alt154=8;
				}
				break;
			case MPOW:
				{
				alt154=9;
				}
				break;
			case POW:
				{
				alt154=10;
				}
				break;
			case CTRANS:
				{
				alt154=11;
				}
				break;
			case TRANS:
				{
				alt154=12;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 154, 0, input);
				throw nvae;
			}
			switch (alt154) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:772:22: wPLUS
					{
					pushFollow(FOLLOW_wPLUS_in_aspectOperatorType8363);
					wPLUS629=wPLUS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wPLUS.add(wPLUS629.getTree());
					// AST REWRITE
					// elements: wPLUS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 772:28: -> wPLUS
					{
						adaptor.addChild(root_0, stream_wPLUS.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:773:22: wMINUS
					{
					pushFollow(FOLLOW_wMINUS_in_aspectOperatorType8390);
					wMINUS630=wMINUS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMINUS.add(wMINUS630.getTree());
					// AST REWRITE
					// elements: wMINUS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 773:29: -> wMINUS
					{
						adaptor.addChild(root_0, stream_wMINUS.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:774:22: wMTIMES
					{
					pushFollow(FOLLOW_wMTIMES_in_aspectOperatorType8417);
					wMTIMES631=wMTIMES();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMTIMES.add(wMTIMES631.getTree());
					// AST REWRITE
					// elements: wMTIMES
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 774:30: -> wMTIMES
					{
						adaptor.addChild(root_0, stream_wMTIMES.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:775:22: wTIMES
					{
					pushFollow(FOLLOW_wTIMES_in_aspectOperatorType8444);
					wTIMES632=wTIMES();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wTIMES.add(wTIMES632.getTree());
					// AST REWRITE
					// elements: wTIMES
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 775:29: -> wTIMES
					{
						adaptor.addChild(root_0, stream_wTIMES.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:776:22: wMRDIV
					{
					pushFollow(FOLLOW_wMRDIV_in_aspectOperatorType8471);
					wMRDIV633=wMRDIV();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMRDIV.add(wMRDIV633.getTree());
					// AST REWRITE
					// elements: wMRDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 776:29: -> wMRDIV
					{
						adaptor.addChild(root_0, stream_wMRDIV.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:777:22: wRDIV
					{
					pushFollow(FOLLOW_wRDIV_in_aspectOperatorType8498);
					wRDIV634=wRDIV();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wRDIV.add(wRDIV634.getTree());
					// AST REWRITE
					// elements: wRDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 777:28: -> wRDIV
					{
						adaptor.addChild(root_0, stream_wRDIV.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:778:22: wMLDIV
					{
					pushFollow(FOLLOW_wMLDIV_in_aspectOperatorType8525);
					wMLDIV635=wMLDIV();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMLDIV.add(wMLDIV635.getTree());
					// AST REWRITE
					// elements: wMLDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 778:29: -> wMLDIV
					{
						adaptor.addChild(root_0, stream_wMLDIV.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:779:22: wLDIV
					{
					pushFollow(FOLLOW_wLDIV_in_aspectOperatorType8552);
					wLDIV636=wLDIV();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wLDIV.add(wLDIV636.getTree());
					// AST REWRITE
					// elements: wLDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 779:28: -> wLDIV
					{
						adaptor.addChild(root_0, stream_wLDIV.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:780:22: wMPOW
					{
					pushFollow(FOLLOW_wMPOW_in_aspectOperatorType8579);
					wMPOW637=wMPOW();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMPOW.add(wMPOW637.getTree());
					// AST REWRITE
					// elements: wMPOW
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 780:28: -> wMPOW
					{
						adaptor.addChild(root_0, stream_wMPOW.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:781:22: wPOW
					{
					pushFollow(FOLLOW_wPOW_in_aspectOperatorType8606);
					wPOW638=wPOW();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wPOW.add(wPOW638.getTree());
					// AST REWRITE
					// elements: wPOW
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 781:27: -> wPOW
					{
						adaptor.addChild(root_0, stream_wPOW.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:782:22: wCTRANS
					{
					pushFollow(FOLLOW_wCTRANS_in_aspectOperatorType8633);
					wCTRANS639=wCTRANS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wCTRANS.add(wCTRANS639.getTree());
					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 782:30: -> CTRANS
					{
						adaptor.addChild(root_0, (Object)adaptor.create(CTRANS, "CTRANS"));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 12 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:783:22: wTRANS
					{
					pushFollow(FOLLOW_wTRANS_in_aspectOperatorType8660);
					wTRANS640=wTRANS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wTRANS.add(wTRANS640.getTree());
					// AST REWRITE
					// elements: wTRANS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 783:29: -> wTRANS
					{
						adaptor.addChild(root_0, stream_wTRANS.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectOperatorType"


	public static class aspectOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:1: aspectOperator : wOPERATOR LPAREN aspectOperatorType ( COLON aspectFullSignature ( COMMA aspectFullSignature )* )? RPAREN -> ^( ASPECTOPERATOR aspectOperatorType ( aspectFullSignature )* ) ;
	public final MatlabParser.aspectOperator_return aspectOperator() throws RecognitionException {
		MatlabParser.aspectOperator_return retval = new MatlabParser.aspectOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN642=null;
		Token COLON644=null;
		Token COMMA646=null;
		Token RPAREN648=null;
		ParserRuleReturnScope wOPERATOR641 =null;
		ParserRuleReturnScope aspectOperatorType643 =null;
		ParserRuleReturnScope aspectFullSignature645 =null;
		ParserRuleReturnScope aspectFullSignature647 =null;

		Object LPAREN642_tree=null;
		Object COLON644_tree=null;
		Object COMMA646_tree=null;
		Object RPAREN648_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wOPERATOR=new RewriteRuleSubtreeStream(adaptor,"rule wOPERATOR");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");
		RewriteRuleSubtreeStream stream_aspectOperatorType=new RewriteRuleSubtreeStream(adaptor,"rule aspectOperatorType");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:16: ( wOPERATOR LPAREN aspectOperatorType ( COLON aspectFullSignature ( COMMA aspectFullSignature )* )? RPAREN -> ^( ASPECTOPERATOR aspectOperatorType ( aspectFullSignature )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:18: wOPERATOR LPAREN aspectOperatorType ( COLON aspectFullSignature ( COMMA aspectFullSignature )* )? RPAREN
			{
			pushFollow(FOLLOW_wOPERATOR_in_aspectOperator8692);
			wOPERATOR641=wOPERATOR();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wOPERATOR.add(wOPERATOR641.getTree());
			LPAREN642=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectOperator8694); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN642);

			pushFollow(FOLLOW_aspectOperatorType_in_aspectOperator8696);
			aspectOperatorType643=aspectOperatorType();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectOperatorType.add(aspectOperatorType643.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:54: ( COLON aspectFullSignature ( COMMA aspectFullSignature )* )?
			int alt156=2;
			int LA156_0 = input.LA(1);
			if ( (LA156_0==COLON) ) {
				alt156=1;
			}
			switch (alt156) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:55: COLON aspectFullSignature ( COMMA aspectFullSignature )*
					{
					COLON644=(Token)match(input,COLON,FOLLOW_COLON_in_aspectOperator8699); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON644);

					pushFollow(FOLLOW_aspectFullSignature_in_aspectOperator8701);
					aspectFullSignature645=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature645.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:81: ( COMMA aspectFullSignature )*
					loop155:
					while (true) {
						int alt155=2;
						int LA155_0 = input.LA(1);
						if ( (LA155_0==COMMA) ) {
							alt155=1;
						}

						switch (alt155) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:82: COMMA aspectFullSignature
							{
							COMMA646=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectOperator8704); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA646);

							pushFollow(FOLLOW_aspectFullSignature_in_aspectOperator8706);
							aspectFullSignature647=aspectFullSignature();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature647.getTree());
							}
							break;

						default :
							break loop155;
						}
					}

					}
					break;

			}

			RPAREN648=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectOperator8712); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN648);

			// AST REWRITE
			// elements: aspectOperatorType, aspectFullSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 786:119: -> ^( ASPECTOPERATOR aspectOperatorType ( aspectFullSignature )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:122: ^( ASPECTOPERATOR aspectOperatorType ( aspectFullSignature )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTOPERATOR, "ASPECTOPERATOR"), root_1);
				adaptor.addChild(root_1, stream_aspectOperatorType.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:158: ( aspectFullSignature )*
				while ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectOperator"


	public static class aspectWithin_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectWithin"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:788:1: aspectWithin : wWITHIN LPAREN aspectScopeType COLON aspectIdentifier RPAREN -> ^( ASPECTWITHIN aspectScopeType aspectIdentifier ) ;
	public final MatlabParser.aspectWithin_return aspectWithin() throws RecognitionException {
		MatlabParser.aspectWithin_return retval = new MatlabParser.aspectWithin_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN650=null;
		Token COLON652=null;
		Token RPAREN654=null;
		ParserRuleReturnScope wWITHIN649 =null;
		ParserRuleReturnScope aspectScopeType651 =null;
		ParserRuleReturnScope aspectIdentifier653 =null;

		Object LPAREN650_tree=null;
		Object COLON652_tree=null;
		Object RPAREN654_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectScopeType=new RewriteRuleSubtreeStream(adaptor,"rule aspectScopeType");
		RewriteRuleSubtreeStream stream_wWITHIN=new RewriteRuleSubtreeStream(adaptor,"rule wWITHIN");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:788:14: ( wWITHIN LPAREN aspectScopeType COLON aspectIdentifier RPAREN -> ^( ASPECTWITHIN aspectScopeType aspectIdentifier ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:788:16: wWITHIN LPAREN aspectScopeType COLON aspectIdentifier RPAREN
			{
			pushFollow(FOLLOW_wWITHIN_in_aspectWithin8734);
			wWITHIN649=wWITHIN();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wWITHIN.add(wWITHIN649.getTree());
			LPAREN650=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectWithin8736); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN650);

			pushFollow(FOLLOW_aspectScopeType_in_aspectWithin8738);
			aspectScopeType651=aspectScopeType();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectScopeType.add(aspectScopeType651.getTree());
			COLON652=(Token)match(input,COLON,FOLLOW_COLON_in_aspectWithin8740); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON652);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectWithin8742);
			aspectIdentifier653=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier653.getTree());
			RPAREN654=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectWithin8744); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN654);

			// AST REWRITE
			// elements: aspectScopeType, aspectIdentifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 788:77: -> ^( ASPECTWITHIN aspectScopeType aspectIdentifier )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:788:80: ^( ASPECTWITHIN aspectScopeType aspectIdentifier )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTWITHIN, "ASPECTWITHIN"), root_1);
				adaptor.addChild(root_1, stream_aspectScopeType.nextTree());
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectWithin"


	public static class aspectScopeType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectScopeType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:790:1: aspectScopeType : ( wFUNCTION -> wFUNCTION | wSCRIPT -> wSCRIPT | wCLASS -> wCLASS | wASPECT -> wASPECT | wLOOP -> wLOOP | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectScopeType_return aspectScopeType() throws RecognitionException {
		MatlabParser.aspectScopeType_return retval = new MatlabParser.aspectScopeType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wFUNCTION655 =null;
		ParserRuleReturnScope wSCRIPT656 =null;
		ParserRuleReturnScope wCLASS657 =null;
		ParserRuleReturnScope wASPECT658 =null;
		ParserRuleReturnScope wLOOP659 =null;
		ParserRuleReturnScope wSTAR660 =null;
		ParserRuleReturnScope wDOTDOT661 =null;

		RewriteRuleSubtreeStream stream_wCLASS=new RewriteRuleSubtreeStream(adaptor,"rule wCLASS");
		RewriteRuleSubtreeStream stream_wASPECT=new RewriteRuleSubtreeStream(adaptor,"rule wASPECT");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");
		RewriteRuleSubtreeStream stream_wFUNCTION=new RewriteRuleSubtreeStream(adaptor,"rule wFUNCTION");
		RewriteRuleSubtreeStream stream_wLOOP=new RewriteRuleSubtreeStream(adaptor,"rule wLOOP");
		RewriteRuleSubtreeStream stream_wSCRIPT=new RewriteRuleSubtreeStream(adaptor,"rule wSCRIPT");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:790:17: ( wFUNCTION -> wFUNCTION | wSCRIPT -> wSCRIPT | wCLASS -> wCLASS | wASPECT -> wASPECT | wLOOP -> wLOOP | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt157=7;
			int LA157_0 = input.LA(1);
			if ( (LA157_0==FUNCTION) ) {
				alt157=1;
			}
			else if ( (LA157_0==ID) && (((Keyword_IdFollows("aspect"))||(Keyword_IdFollows("class"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("script"))))) {
				int LA157_2 = input.LA(2);
				if ( ((Keyword_IdFollows("script"))) ) {
					alt157=2;
				}
				else if ( ((Keyword_IdFollows("class"))) ) {
					alt157=3;
				}
				else if ( ((Keyword_IdFollows("aspect"))) ) {
					alt157=4;
				}
				else if ( ((Keyword_IdFollows("loop"))) ) {
					alt157=5;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 157, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA157_0==MTIMES) ) {
				alt157=6;
			}
			else if ( (LA157_0==DOTDOT) ) {
				alt157=7;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 157, 0, input);
				throw nvae;
			}

			switch (alt157) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:790:19: wFUNCTION
					{
					pushFollow(FOLLOW_wFUNCTION_in_aspectScopeType8763);
					wFUNCTION655=wFUNCTION();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wFUNCTION.add(wFUNCTION655.getTree());
					// AST REWRITE
					// elements: wFUNCTION
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 790:29: -> wFUNCTION
					{
						adaptor.addChild(root_0, stream_wFUNCTION.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:791:19: wSCRIPT
					{
					pushFollow(FOLLOW_wSCRIPT_in_aspectScopeType8787);
					wSCRIPT656=wSCRIPT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSCRIPT.add(wSCRIPT656.getTree());
					// AST REWRITE
					// elements: wSCRIPT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 791:27: -> wSCRIPT
					{
						adaptor.addChild(root_0, stream_wSCRIPT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:792:19: wCLASS
					{
					pushFollow(FOLLOW_wCLASS_in_aspectScopeType8811);
					wCLASS657=wCLASS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wCLASS.add(wCLASS657.getTree());
					// AST REWRITE
					// elements: wCLASS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 792:26: -> wCLASS
					{
						adaptor.addChild(root_0, stream_wCLASS.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:793:19: wASPECT
					{
					pushFollow(FOLLOW_wASPECT_in_aspectScopeType8835);
					wASPECT658=wASPECT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wASPECT.add(wASPECT658.getTree());
					// AST REWRITE
					// elements: wASPECT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 793:27: -> wASPECT
					{
						adaptor.addChild(root_0, stream_wASPECT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:794:19: wLOOP
					{
					pushFollow(FOLLOW_wLOOP_in_aspectScopeType8859);
					wLOOP659=wLOOP();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wLOOP.add(wLOOP659.getTree());
					// AST REWRITE
					// elements: wLOOP
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 794:25: -> wLOOP
					{
						adaptor.addChild(root_0, stream_wLOOP.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:795:19: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectScopeType8883);
					wSTAR660=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR660.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 795:25: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:796:19: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectScopeType8907);
					wDOTDOT661=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT661.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 796:27: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectScopeType"


	public static class aspectDimension_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectDimension"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:799:1: aspectDimension : wDIMENSION LPAREN aspectDimensionSignature RPAREN -> ^( ASPECTDIMENSION aspectDimensionSignature ) ;
	public final MatlabParser.aspectDimension_return aspectDimension() throws RecognitionException {
		MatlabParser.aspectDimension_return retval = new MatlabParser.aspectDimension_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN663=null;
		Token RPAREN665=null;
		ParserRuleReturnScope wDIMENSION662 =null;
		ParserRuleReturnScope aspectDimensionSignature664 =null;

		Object LPAREN663_tree=null;
		Object RPAREN665_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectDimensionSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectDimensionSignature");
		RewriteRuleSubtreeStream stream_wDIMENSION=new RewriteRuleSubtreeStream(adaptor,"rule wDIMENSION");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:799:17: ( wDIMENSION LPAREN aspectDimensionSignature RPAREN -> ^( ASPECTDIMENSION aspectDimensionSignature ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:799:19: wDIMENSION LPAREN aspectDimensionSignature RPAREN
			{
			pushFollow(FOLLOW_wDIMENSION_in_aspectDimension8936);
			wDIMENSION662=wDIMENSION();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wDIMENSION.add(wDIMENSION662.getTree());
			LPAREN663=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectDimension8938); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN663);

			pushFollow(FOLLOW_aspectDimensionSignature_in_aspectDimension8940);
			aspectDimensionSignature664=aspectDimensionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectDimensionSignature.add(aspectDimensionSignature664.getTree());
			RPAREN665=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectDimension8942); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN665);

			// AST REWRITE
			// elements: aspectDimensionSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 799:69: -> ^( ASPECTDIMENSION aspectDimensionSignature )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:799:72: ^( ASPECTDIMENSION aspectDimensionSignature )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTDIMENSION, "ASPECTDIMENSION"), root_1);
				adaptor.addChild(root_1, stream_aspectDimensionSignature.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectDimension"


	public static class aspectIsType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectIsType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:801:1: aspectIsType : wISTYPE LPAREN aspectTypeSignature RPAREN -> ^( ASPECTISTYPE aspectTypeSignature ) ;
	public final MatlabParser.aspectIsType_return aspectIsType() throws RecognitionException {
		MatlabParser.aspectIsType_return retval = new MatlabParser.aspectIsType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN667=null;
		Token RPAREN669=null;
		ParserRuleReturnScope wISTYPE666 =null;
		ParserRuleReturnScope aspectTypeSignature668 =null;

		Object LPAREN667_tree=null;
		Object RPAREN669_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wISTYPE=new RewriteRuleSubtreeStream(adaptor,"rule wISTYPE");
		RewriteRuleSubtreeStream stream_aspectTypeSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectTypeSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:801:14: ( wISTYPE LPAREN aspectTypeSignature RPAREN -> ^( ASPECTISTYPE aspectTypeSignature ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:801:16: wISTYPE LPAREN aspectTypeSignature RPAREN
			{
			pushFollow(FOLLOW_wISTYPE_in_aspectIsType8958);
			wISTYPE666=wISTYPE();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wISTYPE.add(wISTYPE666.getTree());
			LPAREN667=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectIsType8960); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN667);

			pushFollow(FOLLOW_aspectTypeSignature_in_aspectIsType8962);
			aspectTypeSignature668=aspectTypeSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectTypeSignature.add(aspectTypeSignature668.getTree());
			RPAREN669=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectIsType8964); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN669);

			// AST REWRITE
			// elements: aspectTypeSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 801:58: -> ^( ASPECTISTYPE aspectTypeSignature )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:801:61: ^( ASPECTISTYPE aspectTypeSignature )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTISTYPE, "ASPECTISTYPE"), root_1);
				adaptor.addChild(root_1, stream_aspectTypeSignature.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectIsType"


	public static class wID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:805:1: wID : ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wID_return wID() throws RecognitionException {
		MatlabParser.wID_return retval = new MatlabParser.wID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID670=null;

		Object ID670_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:805:5: ( ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:805:7: ID
			{
			ID670=(Token)match(input,ID,FOLLOW_ID_in_wID8983); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID670);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 805:10: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:805:13: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wID"


	public static class wREAL_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wREAL"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:807:1: wREAL : REAL -> ^( NAME[\"\"] ID[$REAL] ) ;
	public final MatlabParser.wREAL_return wREAL() throws RecognitionException {
		MatlabParser.wREAL_return retval = new MatlabParser.wREAL_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REAL671=null;

		Object REAL671_tree=null;
		RewriteRuleTokenStream stream_REAL=new RewriteRuleTokenStream(adaptor,"token REAL");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:807:7: ( REAL -> ^( NAME[\"\"] ID[$REAL] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:807:9: REAL
			{
			REAL671=(Token)match(input,REAL,FOLLOW_REAL_in_wREAL9001); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL.add(REAL671);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 807:14: -> ^( NAME[\"\"] ID[$REAL] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:807:17: ^( NAME[\"\"] ID[$REAL] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, REAL671));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wREAL"


	public static class wASPECT_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wASPECT"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:809:1: wASPECT :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wASPECT_return wASPECT() throws RecognitionException {
		MatlabParser.wASPECT_return retval = new MatlabParser.wASPECT_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID672=null;

		Object ID672_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:809:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:809:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("aspect"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wASPECT", "Keyword_IdFollows(\"aspect\")");
			}
			ID672=(Token)match(input,ID,FOLLOW_ID_in_wASPECT9023); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID672);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 809:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:809:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wASPECT"


	public static class wACTIONS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wACTIONS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:811:1: wACTIONS :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wACTIONS_return wACTIONS() throws RecognitionException {
		MatlabParser.wACTIONS_return retval = new MatlabParser.wACTIONS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID673=null;

		Object ID673_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:811:10: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:811:12: {...}? => ID
			{
			if ( !((Keyword_IdFollows("actions"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wACTIONS", "Keyword_IdFollows(\"actions\")");
			}
			ID673=(Token)match(input,ID,FOLLOW_ID_in_wACTIONS9044); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID673);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 811:49: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:811:52: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wACTIONS"


	public static class wPATTERNS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wPATTERNS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:813:1: wPATTERNS :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wPATTERNS_return wPATTERNS() throws RecognitionException {
		MatlabParser.wPATTERNS_return retval = new MatlabParser.wPATTERNS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID674=null;

		Object ID674_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:813:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:813:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("patterns"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wPATTERNS", "Keyword_IdFollows(\"patterns\")");
			}
			ID674=(Token)match(input,ID,FOLLOW_ID_in_wPATTERNS9065); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID674);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 813:51: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:813:54: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wPATTERNS"


	public static class wBEFORE_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wBEFORE"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:815:1: wBEFORE :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wBEFORE_return wBEFORE() throws RecognitionException {
		MatlabParser.wBEFORE_return retval = new MatlabParser.wBEFORE_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID675=null;

		Object ID675_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:815:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:815:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("before"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wBEFORE", "Keyword_IdFollows(\"before\")");
			}
			ID675=(Token)match(input,ID,FOLLOW_ID_in_wBEFORE9086); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID675);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 815:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:815:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wBEFORE"


	public static class wAFTER_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wAFTER"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:817:1: wAFTER :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wAFTER_return wAFTER() throws RecognitionException {
		MatlabParser.wAFTER_return retval = new MatlabParser.wAFTER_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID676=null;

		Object ID676_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:817:8: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:817:10: {...}? => ID
			{
			if ( !((Keyword_IdFollows("after"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wAFTER", "Keyword_IdFollows(\"after\")");
			}
			ID676=(Token)match(input,ID,FOLLOW_ID_in_wAFTER9107); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID676);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 817:45: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:817:48: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wAFTER"


	public static class wAROUND_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wAROUND"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:819:1: wAROUND :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wAROUND_return wAROUND() throws RecognitionException {
		MatlabParser.wAROUND_return retval = new MatlabParser.wAROUND_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID677=null;

		Object ID677_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:819:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:819:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("around"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wAROUND", "Keyword_IdFollows(\"around\")");
			}
			ID677=(Token)match(input,ID,FOLLOW_ID_in_wAROUND9128); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID677);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 819:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:819:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wAROUND"


	public static class wGET_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wGET"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:821:1: wGET :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wGET_return wGET() throws RecognitionException {
		MatlabParser.wGET_return retval = new MatlabParser.wGET_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID678=null;

		Object ID678_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:821:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:821:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("get"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wGET", "Keyword_IdFollows(\"get\")");
			}
			ID678=(Token)match(input,ID,FOLLOW_ID_in_wGET9149); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID678);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 821:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:821:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wGET"


	public static class wSET_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wSET"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:823:1: wSET :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wSET_return wSET() throws RecognitionException {
		MatlabParser.wSET_return retval = new MatlabParser.wSET_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID679=null;

		Object ID679_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:823:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:823:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("set"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wSET", "Keyword_IdFollows(\"set\")");
			}
			ID679=(Token)match(input,ID,FOLLOW_ID_in_wSET9170); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID679);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 823:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:823:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wSET"


	public static class wCALL_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wCALL"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:825:1: wCALL :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wCALL_return wCALL() throws RecognitionException {
		MatlabParser.wCALL_return retval = new MatlabParser.wCALL_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID680=null;

		Object ID680_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:825:7: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:825:9: {...}? => ID
			{
			if ( !((Keyword_IdFollows("call"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wCALL", "Keyword_IdFollows(\"call\")");
			}
			ID680=(Token)match(input,ID,FOLLOW_ID_in_wCALL9191); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID680);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 825:43: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:825:46: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wCALL"


	public static class wEXECUTION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wEXECUTION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:827:1: wEXECUTION :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wEXECUTION_return wEXECUTION() throws RecognitionException {
		MatlabParser.wEXECUTION_return retval = new MatlabParser.wEXECUTION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID681=null;

		Object ID681_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:827:12: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:827:14: {...}? => ID
			{
			if ( !((Keyword_IdFollows("execution"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wEXECUTION", "Keyword_IdFollows(\"execution\")");
			}
			ID681=(Token)match(input,ID,FOLLOW_ID_in_wEXECUTION9212); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID681);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 827:53: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:827:56: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wEXECUTION"


	public static class wMAINEXECUTION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMAINEXECUTION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:829:1: wMAINEXECUTION :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wMAINEXECUTION_return wMAINEXECUTION() throws RecognitionException {
		MatlabParser.wMAINEXECUTION_return retval = new MatlabParser.wMAINEXECUTION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID682=null;

		Object ID682_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:829:16: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:829:18: {...}? => ID
			{
			if ( !((Keyword_IdFollows("mainexecution"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wMAINEXECUTION", "Keyword_IdFollows(\"mainexecution\")");
			}
			ID682=(Token)match(input,ID,FOLLOW_ID_in_wMAINEXECUTION9233); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID682);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 829:61: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:829:64: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMAINEXECUTION"


	public static class wLOOP_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLOOP"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:831:1: wLOOP :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wLOOP_return wLOOP() throws RecognitionException {
		MatlabParser.wLOOP_return retval = new MatlabParser.wLOOP_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID683=null;

		Object ID683_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:831:7: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:831:9: {...}? => ID
			{
			if ( !((Keyword_IdFollows("loop"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wLOOP", "Keyword_IdFollows(\"loop\")");
			}
			ID683=(Token)match(input,ID,FOLLOW_ID_in_wLOOP9254); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID683);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 831:43: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:831:46: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLOOP"


	public static class wLOOPBODY_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLOOPBODY"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:833:1: wLOOPBODY :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wLOOPBODY_return wLOOPBODY() throws RecognitionException {
		MatlabParser.wLOOPBODY_return retval = new MatlabParser.wLOOPBODY_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID684=null;

		Object ID684_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:833:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:833:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("loopbody"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wLOOPBODY", "Keyword_IdFollows(\"loopbody\")");
			}
			ID684=(Token)match(input,ID,FOLLOW_ID_in_wLOOPBODY9275); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID684);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 833:51: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:833:54: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLOOPBODY"


	public static class wLOOPHEAD_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLOOPHEAD"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:835:1: wLOOPHEAD :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wLOOPHEAD_return wLOOPHEAD() throws RecognitionException {
		MatlabParser.wLOOPHEAD_return retval = new MatlabParser.wLOOPHEAD_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID685=null;

		Object ID685_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:835:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:835:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("loophead"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wLOOPHEAD", "Keyword_IdFollows(\"loophead\")");
			}
			ID685=(Token)match(input,ID,FOLLOW_ID_in_wLOOPHEAD9296); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID685);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 835:51: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:835:54: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLOOPHEAD"


	public static class wANNOTATE_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wANNOTATE"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:837:1: wANNOTATE :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wANNOTATE_return wANNOTATE() throws RecognitionException {
		MatlabParser.wANNOTATE_return retval = new MatlabParser.wANNOTATE_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID686=null;

		Object ID686_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:837:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:837:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("annotate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wANNOTATE", "Keyword_IdFollows(\"annotate\")");
			}
			ID686=(Token)match(input,ID,FOLLOW_ID_in_wANNOTATE9317); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID686);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 837:51: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:837:54: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wANNOTATE"


	public static class wOPERATOR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wOPERATOR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:839:1: wOPERATOR :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wOPERATOR_return wOPERATOR() throws RecognitionException {
		MatlabParser.wOPERATOR_return retval = new MatlabParser.wOPERATOR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID687=null;

		Object ID687_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:839:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:839:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("op"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wOPERATOR", "Keyword_IdFollows(\"op\")");
			}
			ID687=(Token)match(input,ID,FOLLOW_ID_in_wOPERATOR9338); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID687);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 839:45: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:839:48: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wOPERATOR"


	public static class wWITHIN_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wWITHIN"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:841:1: wWITHIN :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wWITHIN_return wWITHIN() throws RecognitionException {
		MatlabParser.wWITHIN_return retval = new MatlabParser.wWITHIN_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID688=null;

		Object ID688_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:841:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:841:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("within"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wWITHIN", "Keyword_IdFollows(\"within\")");
			}
			ID688=(Token)match(input,ID,FOLLOW_ID_in_wWITHIN9359); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID688);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 841:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:841:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wWITHIN"


	public static class wDIMENSION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wDIMENSION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:843:1: wDIMENSION :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wDIMENSION_return wDIMENSION() throws RecognitionException {
		MatlabParser.wDIMENSION_return retval = new MatlabParser.wDIMENSION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID689=null;

		Object ID689_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:843:12: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:843:14: {...}? => ID
			{
			if ( !((Keyword_IdFollows("dimension"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wDIMENSION", "Keyword_IdFollows(\"dimension\")");
			}
			ID689=(Token)match(input,ID,FOLLOW_ID_in_wDIMENSION9380); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID689);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 843:53: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:843:56: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wDIMENSION"


	public static class wISTYPE_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wISTYPE"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:845:1: wISTYPE :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wISTYPE_return wISTYPE() throws RecognitionException {
		MatlabParser.wISTYPE_return retval = new MatlabParser.wISTYPE_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID690=null;

		Object ID690_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:845:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:845:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("istype"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wISTYPE", "Keyword_IdFollows(\"istype\")");
			}
			ID690=(Token)match(input,ID,FOLLOW_ID_in_wISTYPE9401); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID690);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 845:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:845:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wISTYPE"


	public static class wSTAR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wSTAR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:847:1: wSTAR : MTIMES -> ^( NAME[\"\"] ID[$MTIMES] ) ;
	public final MatlabParser.wSTAR_return wSTAR() throws RecognitionException {
		MatlabParser.wSTAR_return retval = new MatlabParser.wSTAR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MTIMES691=null;

		Object MTIMES691_tree=null;
		RewriteRuleTokenStream stream_MTIMES=new RewriteRuleTokenStream(adaptor,"token MTIMES");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:847:7: ( MTIMES -> ^( NAME[\"\"] ID[$MTIMES] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:847:9: MTIMES
			{
			MTIMES691=(Token)match(input,MTIMES,FOLLOW_MTIMES_in_wSTAR9419); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MTIMES.add(MTIMES691);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 847:16: -> ^( NAME[\"\"] ID[$MTIMES] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:847:19: ^( NAME[\"\"] ID[$MTIMES] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MTIMES691));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wSTAR"


	public static class wFUNCTION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wFUNCTION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:849:1: wFUNCTION : FUNCTION -> ^( NAME[\"\"] ID[$FUNCTION] ) ;
	public final MatlabParser.wFUNCTION_return wFUNCTION() throws RecognitionException {
		MatlabParser.wFUNCTION_return retval = new MatlabParser.wFUNCTION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION692=null;

		Object FUNCTION692_tree=null;
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:849:11: ( FUNCTION -> ^( NAME[\"\"] ID[$FUNCTION] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:849:13: FUNCTION
			{
			FUNCTION692=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_wFUNCTION9438); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION692);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 849:22: -> ^( NAME[\"\"] ID[$FUNCTION] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:849:25: ^( NAME[\"\"] ID[$FUNCTION] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, FUNCTION692));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wFUNCTION"


	public static class wSCRIPT_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wSCRIPT"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:851:1: wSCRIPT :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wSCRIPT_return wSCRIPT() throws RecognitionException {
		MatlabParser.wSCRIPT_return retval = new MatlabParser.wSCRIPT_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID693=null;

		Object ID693_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:851:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:851:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("script"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wSCRIPT", "Keyword_IdFollows(\"script\")");
			}
			ID693=(Token)match(input,ID,FOLLOW_ID_in_wSCRIPT9460); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID693);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 851:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:851:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wSCRIPT"


	public static class wLOOPS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLOOPS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:853:1: wLOOPS :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wLOOPS_return wLOOPS() throws RecognitionException {
		MatlabParser.wLOOPS_return retval = new MatlabParser.wLOOPS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID694=null;

		Object ID694_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:853:8: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:853:10: {...}? => ID
			{
			if ( !((Keyword_IdFollows("loops"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wLOOPS", "Keyword_IdFollows(\"loops\")");
			}
			ID694=(Token)match(input,ID,FOLLOW_ID_in_wLOOPS9481); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID694);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 853:45: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:853:48: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLOOPS"


	public static class wCLASS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wCLASS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:855:1: wCLASS :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wCLASS_return wCLASS() throws RecognitionException {
		MatlabParser.wCLASS_return retval = new MatlabParser.wCLASS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID695=null;

		Object ID695_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:855:8: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:855:10: {...}? => ID
			{
			if ( !((Keyword_IdFollows("class"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wCLASS", "Keyword_IdFollows(\"class\")");
			}
			ID695=(Token)match(input,ID,FOLLOW_ID_in_wCLASS9502); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID695);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 855:45: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:855:48: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wCLASS"


	public static class wDOTDOT_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wDOTDOT"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:857:1: wDOTDOT : DOTDOT -> ^( NAME[\"\"] ID[$DOTDOT] ) ;
	public final MatlabParser.wDOTDOT_return wDOTDOT() throws RecognitionException {
		MatlabParser.wDOTDOT_return retval = new MatlabParser.wDOTDOT_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOTDOT696=null;

		Object DOTDOT696_tree=null;
		RewriteRuleTokenStream stream_DOTDOT=new RewriteRuleTokenStream(adaptor,"token DOTDOT");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:857:9: ( DOTDOT -> ^( NAME[\"\"] ID[$DOTDOT] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:857:11: DOTDOT
			{
			DOTDOT696=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_wDOTDOT9520); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOTDOT.add(DOTDOT696);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 857:18: -> ^( NAME[\"\"] ID[$DOTDOT] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:857:21: ^( NAME[\"\"] ID[$DOTDOT] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, DOTDOT696));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wDOTDOT"


	public static class wFOR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wFOR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:859:1: wFOR : FOR -> ^( NAME[\"\"] ID[$FOR] ) ;
	public final MatlabParser.wFOR_return wFOR() throws RecognitionException {
		MatlabParser.wFOR_return retval = new MatlabParser.wFOR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FOR697=null;

		Object FOR697_tree=null;
		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,"token FOR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:859:6: ( FOR -> ^( NAME[\"\"] ID[$FOR] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:859:8: FOR
			{
			FOR697=(Token)match(input,FOR,FOLLOW_FOR_in_wFOR9539); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FOR.add(FOR697);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 859:13: -> ^( NAME[\"\"] ID[$FOR] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:859:16: ^( NAME[\"\"] ID[$FOR] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, FOR697));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wFOR"


	public static class wWHILE_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wWHILE"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:861:1: wWHILE : WHILE -> ^( NAME[\"\"] ID[$WHILE] ) ;
	public final MatlabParser.wWHILE_return wWHILE() throws RecognitionException {
		MatlabParser.wWHILE_return retval = new MatlabParser.wWHILE_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token WHILE698=null;

		Object WHILE698_tree=null;
		RewriteRuleTokenStream stream_WHILE=new RewriteRuleTokenStream(adaptor,"token WHILE");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:861:8: ( WHILE -> ^( NAME[\"\"] ID[$WHILE] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:861:10: WHILE
			{
			WHILE698=(Token)match(input,WHILE,FOLLOW_WHILE_in_wWHILE9559); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_WHILE.add(WHILE698);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 861:17: -> ^( NAME[\"\"] ID[$WHILE] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:861:20: ^( NAME[\"\"] ID[$WHILE] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, WHILE698));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wWHILE"


	public static class wPLUS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wPLUS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:863:1: wPLUS : PLUS -> ^( NAME[\"\"] ID[$PLUS] ) ;
	public final MatlabParser.wPLUS_return wPLUS() throws RecognitionException {
		MatlabParser.wPLUS_return retval = new MatlabParser.wPLUS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLUS699=null;

		Object PLUS699_tree=null;
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:863:7: ( PLUS -> ^( NAME[\"\"] ID[$PLUS] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:863:9: PLUS
			{
			PLUS699=(Token)match(input,PLUS,FOLLOW_PLUS_in_wPLUS9579); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PLUS.add(PLUS699);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 863:14: -> ^( NAME[\"\"] ID[$PLUS] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:863:17: ^( NAME[\"\"] ID[$PLUS] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, PLUS699));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wPLUS"


	public static class wMINUS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMINUS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:865:1: wMINUS : MINUS -> ^( NAME[\"\"] ID[$MINUS] ) ;
	public final MatlabParser.wMINUS_return wMINUS() throws RecognitionException {
		MatlabParser.wMINUS_return retval = new MatlabParser.wMINUS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MINUS700=null;

		Object MINUS700_tree=null;
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:865:8: ( MINUS -> ^( NAME[\"\"] ID[$MINUS] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:865:10: MINUS
			{
			MINUS700=(Token)match(input,MINUS,FOLLOW_MINUS_in_wMINUS9598); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MINUS.add(MINUS700);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 865:16: -> ^( NAME[\"\"] ID[$MINUS] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:865:19: ^( NAME[\"\"] ID[$MINUS] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MINUS700));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMINUS"


	public static class wMTIMES_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMTIMES"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:867:1: wMTIMES : MTIMES -> ^( NAME[\"\"] ID[$MTIMES] ) ;
	public final MatlabParser.wMTIMES_return wMTIMES() throws RecognitionException {
		MatlabParser.wMTIMES_return retval = new MatlabParser.wMTIMES_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MTIMES701=null;

		Object MTIMES701_tree=null;
		RewriteRuleTokenStream stream_MTIMES=new RewriteRuleTokenStream(adaptor,"token MTIMES");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:867:9: ( MTIMES -> ^( NAME[\"\"] ID[$MTIMES] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:867:11: MTIMES
			{
			MTIMES701=(Token)match(input,MTIMES,FOLLOW_MTIMES_in_wMTIMES9617); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MTIMES.add(MTIMES701);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 867:18: -> ^( NAME[\"\"] ID[$MTIMES] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:867:21: ^( NAME[\"\"] ID[$MTIMES] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MTIMES701));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMTIMES"


	public static class wTIMES_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wTIMES"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:869:1: wTIMES : TIMES -> ^( NAME[\"\"] ID[$TIMES] ) ;
	public final MatlabParser.wTIMES_return wTIMES() throws RecognitionException {
		MatlabParser.wTIMES_return retval = new MatlabParser.wTIMES_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TIMES702=null;

		Object TIMES702_tree=null;
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:869:8: ( TIMES -> ^( NAME[\"\"] ID[$TIMES] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:869:10: TIMES
			{
			TIMES702=(Token)match(input,TIMES,FOLLOW_TIMES_in_wTIMES9636); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TIMES.add(TIMES702);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 869:16: -> ^( NAME[\"\"] ID[$TIMES] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:869:19: ^( NAME[\"\"] ID[$TIMES] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, TIMES702));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wTIMES"


	public static class wMRDIV_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMRDIV"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:871:1: wMRDIV : MRDIV -> ^( NAME[\"\"] ID[$MRDIV] ) ;
	public final MatlabParser.wMRDIV_return wMRDIV() throws RecognitionException {
		MatlabParser.wMRDIV_return retval = new MatlabParser.wMRDIV_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MRDIV703=null;

		Object MRDIV703_tree=null;
		RewriteRuleTokenStream stream_MRDIV=new RewriteRuleTokenStream(adaptor,"token MRDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:871:8: ( MRDIV -> ^( NAME[\"\"] ID[$MRDIV] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:871:10: MRDIV
			{
			MRDIV703=(Token)match(input,MRDIV,FOLLOW_MRDIV_in_wMRDIV9655); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MRDIV.add(MRDIV703);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 871:16: -> ^( NAME[\"\"] ID[$MRDIV] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:871:19: ^( NAME[\"\"] ID[$MRDIV] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MRDIV703));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMRDIV"


	public static class wRDIV_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wRDIV"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:873:1: wRDIV : RDIV -> ^( NAME[\"\"] ID[$RDIV] ) ;
	public final MatlabParser.wRDIV_return wRDIV() throws RecognitionException {
		MatlabParser.wRDIV_return retval = new MatlabParser.wRDIV_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token RDIV704=null;

		Object RDIV704_tree=null;
		RewriteRuleTokenStream stream_RDIV=new RewriteRuleTokenStream(adaptor,"token RDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:873:7: ( RDIV -> ^( NAME[\"\"] ID[$RDIV] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:873:9: RDIV
			{
			RDIV704=(Token)match(input,RDIV,FOLLOW_RDIV_in_wRDIV9674); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RDIV.add(RDIV704);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 873:14: -> ^( NAME[\"\"] ID[$RDIV] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:873:17: ^( NAME[\"\"] ID[$RDIV] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, RDIV704));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wRDIV"


	public static class wMLDIV_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMLDIV"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:875:1: wMLDIV : MLDIV -> ^( NAME[\"\"] ID[$MLDIV] ) ;
	public final MatlabParser.wMLDIV_return wMLDIV() throws RecognitionException {
		MatlabParser.wMLDIV_return retval = new MatlabParser.wMLDIV_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MLDIV705=null;

		Object MLDIV705_tree=null;
		RewriteRuleTokenStream stream_MLDIV=new RewriteRuleTokenStream(adaptor,"token MLDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:875:8: ( MLDIV -> ^( NAME[\"\"] ID[$MLDIV] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:875:10: MLDIV
			{
			MLDIV705=(Token)match(input,MLDIV,FOLLOW_MLDIV_in_wMLDIV9693); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MLDIV.add(MLDIV705);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 875:16: -> ^( NAME[\"\"] ID[$MLDIV] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:875:19: ^( NAME[\"\"] ID[$MLDIV] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MLDIV705));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMLDIV"


	public static class wLDIV_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLDIV"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:877:1: wLDIV : LDIV -> ^( NAME[\"\"] ID[$LDIV] ) ;
	public final MatlabParser.wLDIV_return wLDIV() throws RecognitionException {
		MatlabParser.wLDIV_return retval = new MatlabParser.wLDIV_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LDIV706=null;

		Object LDIV706_tree=null;
		RewriteRuleTokenStream stream_LDIV=new RewriteRuleTokenStream(adaptor,"token LDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:877:7: ( LDIV -> ^( NAME[\"\"] ID[$LDIV] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:877:9: LDIV
			{
			LDIV706=(Token)match(input,LDIV,FOLLOW_LDIV_in_wLDIV9712); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LDIV.add(LDIV706);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 877:14: -> ^( NAME[\"\"] ID[$LDIV] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:877:17: ^( NAME[\"\"] ID[$LDIV] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, LDIV706));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLDIV"


	public static class wMPOW_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMPOW"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:879:1: wMPOW : MPOW -> ^( NAME[\"\"] ID[$MPOW] ) ;
	public final MatlabParser.wMPOW_return wMPOW() throws RecognitionException {
		MatlabParser.wMPOW_return retval = new MatlabParser.wMPOW_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MPOW707=null;

		Object MPOW707_tree=null;
		RewriteRuleTokenStream stream_MPOW=new RewriteRuleTokenStream(adaptor,"token MPOW");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:879:7: ( MPOW -> ^( NAME[\"\"] ID[$MPOW] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:879:9: MPOW
			{
			MPOW707=(Token)match(input,MPOW,FOLLOW_MPOW_in_wMPOW9731); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MPOW.add(MPOW707);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 879:14: -> ^( NAME[\"\"] ID[$MPOW] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:879:17: ^( NAME[\"\"] ID[$MPOW] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MPOW707));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMPOW"


	public static class wPOW_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wPOW"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:881:1: wPOW : POW -> ^( NAME[\"\"] ID[$POW] ) ;
	public final MatlabParser.wPOW_return wPOW() throws RecognitionException {
		MatlabParser.wPOW_return retval = new MatlabParser.wPOW_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token POW708=null;

		Object POW708_tree=null;
		RewriteRuleTokenStream stream_POW=new RewriteRuleTokenStream(adaptor,"token POW");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:881:6: ( POW -> ^( NAME[\"\"] ID[$POW] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:881:8: POW
			{
			POW708=(Token)match(input,POW,FOLLOW_POW_in_wPOW9750); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_POW.add(POW708);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 881:12: -> ^( NAME[\"\"] ID[$POW] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:881:15: ^( NAME[\"\"] ID[$POW] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, POW708));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wPOW"


	public static class wTRANS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wTRANS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:883:1: wTRANS : TRANS -> ^( NAME[\"\"] ID[$TRANS] ) ;
	public final MatlabParser.wTRANS_return wTRANS() throws RecognitionException {
		MatlabParser.wTRANS_return retval = new MatlabParser.wTRANS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TRANS709=null;

		Object TRANS709_tree=null;
		RewriteRuleTokenStream stream_TRANS=new RewriteRuleTokenStream(adaptor,"token TRANS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:883:8: ( TRANS -> ^( NAME[\"\"] ID[$TRANS] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:883:10: TRANS
			{
			TRANS709=(Token)match(input,TRANS,FOLLOW_TRANS_in_wTRANS9769); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TRANS.add(TRANS709);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 883:16: -> ^( NAME[\"\"] ID[$TRANS] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:883:19: ^( NAME[\"\"] ID[$TRANS] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, TRANS709));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wTRANS"


	public static class wCTRANS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wCTRANS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:885:1: wCTRANS : CTRANS -> ^( NAME[\"\"] ID[$CTRANS] ) ;
	public final MatlabParser.wCTRANS_return wCTRANS() throws RecognitionException {
		MatlabParser.wCTRANS_return retval = new MatlabParser.wCTRANS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CTRANS710=null;

		Object CTRANS710_tree=null;
		RewriteRuleTokenStream stream_CTRANS=new RewriteRuleTokenStream(adaptor,"token CTRANS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:885:9: ( CTRANS -> ^( NAME[\"\"] ID[$CTRANS] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:885:11: CTRANS
			{
			CTRANS710=(Token)match(input,CTRANS,FOLLOW_CTRANS_in_wCTRANS9788); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CTRANS.add(CTRANS710);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 885:18: -> ^( NAME[\"\"] ID[$CTRANS] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:885:21: ^( NAME[\"\"] ID[$CTRANS] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, CTRANS710));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wCTRANS"


	public static class wVAR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wVAR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:887:1: wVAR :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wVAR_return wVAR() throws RecognitionException {
		MatlabParser.wVAR_return retval = new MatlabParser.wVAR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID711=null;

		Object ID711_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:887:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:887:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("var"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wVAR", "Keyword_IdFollows(\"var\")");
			}
			ID711=(Token)match(input,ID,FOLLOW_ID_in_wVAR9810); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID711);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 887:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:887:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wVAR"


	public static class wSTR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wSTR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:889:1: wSTR :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wSTR_return wSTR() throws RecognitionException {
		MatlabParser.wSTR_return retval = new MatlabParser.wSTR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID712=null;

		Object ID712_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:889:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:889:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("str"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wSTR", "Keyword_IdFollows(\"str\")");
			}
			ID712=(Token)match(input,ID,FOLLOW_ID_in_wSTR9831); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID712);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 889:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:889:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wSTR"


	public static class wNUM_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wNUM"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:891:1: wNUM :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wNUM_return wNUM() throws RecognitionException {
		MatlabParser.wNUM_return retval = new MatlabParser.wNUM_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID713=null;

		Object ID713_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:891:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:891:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("num"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wNUM", "Keyword_IdFollows(\"num\")");
			}
			ID713=(Token)match(input,ID,FOLLOW_ID_in_wNUM9852); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID713);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 891:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:891:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wNUM"

	// $ANTLR start synpred1_MatlabParser
	public final void synpred1_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:16: ( openFunctionFile )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:17: openFunctionFile
		{
		pushFollow(FOLLOW_openFunctionFile_in_synpred1_MatlabParser491);
		openFunctionFile();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred1_MatlabParser

	// $ANTLR start synpred2_MatlabParser
	public final void synpred2_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:13: ( assignment )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:14: assignment
		{
		pushFollow(FOLLOW_assignment_in_synpred2_MatlabParser2197);
		assignment();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred2_MatlabParser

	// $ANTLR start synpred3_MatlabParser
	public final void synpred3_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:230:13: ( action )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:230:14: action
		{
		pushFollow(FOLLOW_action_in_synpred3_MatlabParser2220);
		action();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred3_MatlabParser

	// $ANTLR start synpred4_MatlabParser
	public final void synpred4_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:231:7: ( simpleCommand )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:231:8: simpleCommand
		{
		pushFollow(FOLLOW_simpleCommand_in_synpred4_MatlabParser2237);
		simpleCommand();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred4_MatlabParser

	// $ANTLR start synpred5_MatlabParser
	public final void synpred5_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:232:7: ( abortCommand )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:232:8: abortCommand
		{
		pushFollow(FOLLOW_abortCommand_in_synpred5_MatlabParser2254);
		abortCommand();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred5_MatlabParser

	// $ANTLR start synpred6_MatlabParser
	public final void synpred6_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:14: ( LPAREN var ASSIGN expression COMMA )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:15: LPAREN var ASSIGN expression COMMA
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred6_MatlabParser3426); if (state.failed) return;

		pushFollow(FOLLOW_var_in_synpred6_MatlabParser3428);
		var();
		state._fsp--;
		if (state.failed) return;

		match(input,ASSIGN,FOLLOW_ASSIGN_in_synpred6_MatlabParser3430); if (state.failed) return;

		pushFollow(FOLLOW_expression_in_synpred6_MatlabParser3432);
		expression();
		state._fsp--;
		if (state.failed) return;

		match(input,COMMA,FOLLOW_COMMA_in_synpred6_MatlabParser3434); if (state.failed) return;

		}

	}
	// $ANTLR end synpred6_MatlabParser

	// $ANTLR start synpred7_MatlabParser
	public final void synpred7_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:67: ( COLON expression05 COLON expression05 )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:68: COLON expression05 COLON expression05
		{
		match(input,COLON,FOLLOW_COLON_in_synpred7_MatlabParser4270); if (state.failed) return;

		pushFollow(FOLLOW_expression05_in_synpred7_MatlabParser4272);
		expression05();
		state._fsp--;
		if (state.failed) return;

		match(input,COLON,FOLLOW_COLON_in_synpred7_MatlabParser4274); if (state.failed) return;

		pushFollow(FOLLOW_expression05_in_synpred7_MatlabParser4276);
		expression05();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred7_MatlabParser

	// $ANTLR start synpred8_MatlabParser
	public final void synpred8_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:191: ( COLON expression05 )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:192: COLON expression05
		{
		match(input,COLON,FOLLOW_COLON_in_synpred8_MatlabParser4312); if (state.failed) return;

		pushFollow(FOLLOW_expression05_in_synpred8_MatlabParser4314);
		expression05();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred8_MatlabParser

	// $ANTLR start synpred9_MatlabParser
	public final void synpred9_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:5: ( DOT LPAREN )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:6: DOT LPAREN
		{
		match(input,DOT,FOLLOW_DOT_in_synpred9_MatlabParser5000); if (state.failed) return;

		match(input,LPAREN,FOLLOW_LPAREN_in_synpred9_MatlabParser5002); if (state.failed) return;

		}

	}
	// $ANTLR end synpred9_MatlabParser

	// $ANTLR start synpred10_MatlabParser
	public final void synpred10_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:10: ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:11: NOT ( COMMA | SEMICOLON | EOL | RSQUARE )
		{
		match(input,NOT,FOLLOW_NOT_in_synpred10_MatlabParser5553); if (state.failed) return;

		if ( input.LA(1)==COMMA||input.LA(1)==EOL||(input.LA(1) >= RSQUARE && input.LA(1) <= SEMICOLON) ) {
			input.consume();
			state.errorRecovery=false;
			state.failed=false;
		}
		else {
			if (state.backtracking>0) {state.failed=true; return;}
			MismatchedSetException mse = new MismatchedSetException(null,input);
			throw mse;
		}
		}

	}
	// $ANTLR end synpred10_MatlabParser

	// Delegated rules

	public final boolean synpred5_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred5_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred4_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred4_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred6_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred6_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred2_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred2_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred3_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred3_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred8_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred8_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred7_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred7_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred1_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred1_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred9_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred9_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred10_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred10_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}


	protected DFA1 dfa1 = new DFA1(this);
	protected DFA22 dfa22 = new DFA22(this);
	protected DFA51 dfa51 = new DFA51(this);
	protected DFA100 dfa100 = new DFA100(this);
	protected DFA129 dfa129 = new DFA129(this);
	static final String DFA1_eotS =
		"\12\uffff";
	static final String DFA1_eofS =
		"\1\5\5\uffff\1\5\3\uffff";
	static final String DFA1_minS =
		"\1\5\5\uffff\1\5\3\uffff";
	static final String DFA1_maxS =
		"\1\137\5\uffff\1\137\3\uffff";
	static final String DFA1_acceptS =
		"\1\uffff\5\1\1\uffff\1\2\1\3\1\4";
	static final String DFA1_specialS =
		"\1\0\11\uffff}>";
	static final String[] DFA1_transitionS = {
			"\1\11\1\uffff\1\4\2\uffff\1\5\2\uffff\1\10\1\uffff\2\5\1\uffff\1\5\15"+
			"\uffff\1\3\1\6\1\uffff\1\5\1\uffff\1\5\1\7\1\5\2\uffff\1\1\1\5\1\2\1"+
			"\uffff\1\2\7\uffff\2\2\2\uffff\1\2\4\uffff\1\2\4\uffff\2\5\1\2\2\uffff"+
			"\1\4\3\uffff\1\2\1\5\2\uffff\1\5\4\uffff\1\5\1\uffff\1\2\1\uffff\1\5"+
			"\2\uffff\1\5\1\uffff\1\5",
			"",
			"",
			"",
			"",
			"",
			"\1\11\1\uffff\1\5\2\uffff\1\5\2\uffff\1\10\1\uffff\2\5\1\uffff\1\5\15"+
			"\uffff\1\5\1\6\1\uffff\1\5\1\uffff\1\5\1\7\1\5\2\uffff\3\5\1\uffff\1"+
			"\5\7\uffff\2\5\2\uffff\1\5\4\uffff\1\5\4\uffff\3\5\2\uffff\1\5\3\uffff"+
			"\2\5\2\uffff\1\5\4\uffff\1\5\1\uffff\1\5\1\uffff\1\5\2\uffff\1\5\1\uffff"+
			"\1\5",
			"",
			"",
			""
	};

	static final short[] DFA1_eot = DFA.unpackEncodedString(DFA1_eotS);
	static final short[] DFA1_eof = DFA.unpackEncodedString(DFA1_eofS);
	static final char[] DFA1_min = DFA.unpackEncodedStringToUnsignedChars(DFA1_minS);
	static final char[] DFA1_max = DFA.unpackEncodedStringToUnsignedChars(DFA1_maxS);
	static final short[] DFA1_accept = DFA.unpackEncodedString(DFA1_acceptS);
	static final short[] DFA1_special = DFA.unpackEncodedString(DFA1_specialS);
	static final short[][] DFA1_transition;

	static {
		int numStates = DFA1_transitionS.length;
		DFA1_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA1_transition[i] = DFA.unpackEncodedString(DFA1_transitionS[i]);
		}
	}

	protected class DFA1 extends DFA {

		public DFA1(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 1;
			this.eot = DFA1_eot;
			this.eof = DFA1_eof;
			this.min = DFA1_min;
			this.max = DFA1_max;
			this.accept = DFA1_accept;
			this.special = DFA1_special;
			this.transition = DFA1_transition;
		}
		@Override
		public String getDescription() {
			return "57:8: public file : ( scriptFile -> scriptFile | functionFile -> functionFile | classFile -> classFile | aspectFile -> aspectFile );";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA1_0 = input.LA(1);
						 
						int index1_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA1_0==ID) && (((Command_IsEnabled())||(True())))) {s = 1;}
						else if ( (LA1_0==IMAGINARY||LA1_0==LCURLY||(LA1_0 >= LPAREN && LA1_0 <= LSQUARE)||LA1_0==MINUS||LA1_0==NOT||LA1_0==PLUS||LA1_0==REAL||LA1_0==STRING) && ((True()))) {s = 2;}
						else if ( (LA1_0==END) && (((Index_IsActive())&&(True())))) {s = 3;}
						else if ( (LA1_0==AT||LA1_0==QUESTION) && ((True()))) {s = 4;}
						else if ( (LA1_0==EOF||LA1_0==BREAK||(LA1_0 >= COMMA && LA1_0 <= COMMAND)||LA1_0==CONTINUE||LA1_0==EXCLAMATION||LA1_0==FOR||LA1_0==GLOBAL||LA1_0==IF||(LA1_0 >= PARFOR && LA1_0 <= PERSISTENT)||LA1_0==RETURN||LA1_0==SEMICOLON||LA1_0==SPMD||LA1_0==SWITCH||LA1_0==TRY||LA1_0==WHILE) ) {s = 5;}
						else if ( (LA1_0==EOL) ) {s = 6;}
						else if ( (LA1_0==FUNCTION) ) {s = 7;}
						else if ( (LA1_0==CLASSDEF) ) {s = 8;}
						else if ( (LA1_0==ASPECT) ) {s = 9;}
						 
						input.seek(index1_0);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 1, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA22_eotS =
		"\4\uffff";
	static final String DFA22_eofS =
		"\2\2\2\uffff";
	static final String DFA22_minS =
		"\2\41\2\uffff";
	static final String DFA22_maxS =
		"\2\46\2\uffff";
	static final String DFA22_acceptS =
		"\2\uffff\1\2\1\1";
	static final String DFA22_specialS =
		"\4\uffff}>";
	static final String[] DFA22_transitionS = {
			"\1\1\4\uffff\1\3",
			"\1\1\4\uffff\1\3",
			"",
			""
	};

	static final short[] DFA22_eot = DFA.unpackEncodedString(DFA22_eotS);
	static final short[] DFA22_eof = DFA.unpackEncodedString(DFA22_eofS);
	static final char[] DFA22_min = DFA.unpackEncodedStringToUnsignedChars(DFA22_minS);
	static final char[] DFA22_max = DFA.unpackEncodedStringToUnsignedChars(DFA22_maxS);
	static final short[] DFA22_accept = DFA.unpackEncodedString(DFA22_acceptS);
	static final short[] DFA22_special = DFA.unpackEncodedString(DFA22_specialS);
	static final short[][] DFA22_transition;

	static {
		int numStates = DFA22_transitionS.length;
		DFA22_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA22_transition[i] = DFA.unpackEncodedString(DFA22_transitionS[i]);
		}
	}

	protected class DFA22 extends DFA {

		public DFA22(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 22;
			this.eot = DFA22_eot;
			this.eof = DFA22_eof;
			this.min = DFA22_min;
			this.max = DFA22_max;
			this.accept = DFA22_accept;
			this.special = DFA22_special;
			this.transition = DFA22_transition;
		}
		@Override
		public String getDescription() {
			return "()* loopback of 123:32: ( ( EOL )* closeFunction )*";
		}
	}

	static final String DFA51_eotS =
		"\75\uffff";
	static final String DFA51_eofS =
		"\75\uffff";
	static final String DFA51_minS =
		"\1\52\1\6\1\52\1\40\2\uffff\1\7\1\6\1\17\1\uffff\2\52\1\7\1\40\1\17\1"+
		"\52\1\12\26\17\1\12\25\17";
	static final String DFA51_maxS =
		"\1\67\1\121\1\120\1\52\2\uffff\1\120\1\6\1\121\1\uffff\2\52\1\120\1\52"+
		"\1\120\1\52\1\137\26\120\1\137\25\120";
	static final String DFA51_acceptS =
		"\4\uffff\1\1\1\3\3\uffff\1\2\63\uffff";
	static final String DFA51_specialS =
		"\75\uffff}>";
	static final String[] DFA51_transitionS = {
			"\1\1\14\uffff\1\2",
			"\1\3\10\uffff\1\5\13\uffff\1\4\4\uffff\2\5\24\uffff\1\5\32\uffff\1\5",
			"\1\6\45\uffff\1\7",
			"\1\11\11\uffff\1\10",
			"",
			"",
			"\1\12\7\uffff\1\13\32\uffff\1\14\45\uffff\1\7",
			"\1\15",
			"\1\11\13\uffff\1\4\4\uffff\2\11\24\uffff\1\11\32\uffff\1\11",
			"",
			"\1\16",
			"\1\14",
			"\1\17\7\uffff\1\13\32\uffff\1\14\45\uffff\1\7",
			"\1\11\11\uffff\1\10",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\21",
			"\1\23\1\24\1\25\1\26\4\uffff\1\27\13\uffff\1\30\1\31\1\32\4\uffff\1"+
			"\33\1\34\1\35\2\uffff\1\22\1\36\27\uffff\1\37\1\40\1\41\10\uffff\1\42"+
			"\7\uffff\1\43\3\uffff\1\44\2\uffff\1\45\1\uffff\1\46",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\51\1\52\1\53\1\54\4\uffff\1\55\13\uffff\1\56\1\57\1\60\4\uffff\1"+
			"\61\1\62\1\63\2\uffff\1\50\1\64\27\uffff\1\65\1\66\1\67\10\uffff\1\70"+
			"\7\uffff\1\71\3\uffff\1\72\2\uffff\1\73\1\uffff\1\74",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7"
	};

	static final short[] DFA51_eot = DFA.unpackEncodedString(DFA51_eotS);
	static final short[] DFA51_eof = DFA.unpackEncodedString(DFA51_eofS);
	static final char[] DFA51_min = DFA.unpackEncodedStringToUnsignedChars(DFA51_minS);
	static final char[] DFA51_max = DFA.unpackEncodedStringToUnsignedChars(DFA51_maxS);
	static final short[] DFA51_accept = DFA.unpackEncodedString(DFA51_acceptS);
	static final short[] DFA51_special = DFA.unpackEncodedString(DFA51_specialS);
	static final short[][] DFA51_transition;

	static {
		int numStates = DFA51_transitionS.length;
		DFA51_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA51_transition[i] = DFA.unpackEncodedString(DFA51_transitionS[i]);
		}
	}

	protected class DFA51 extends DFA {

		public DFA51(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 51;
			this.eot = DFA51_eot;
			this.eof = DFA51_eof;
			this.min = DFA51_min;
			this.max = DFA51_max;
			this.accept = DFA51_accept;
			this.special = DFA51_special;
			this.transition = DFA51_transition;
		}
		@Override
		public String getDescription() {
			return "196:1: methodSignature : ( ( outputPortion )? methodName1 ( inputPortion )? -> ( outputPortion )? methodName1 ( inputPortion )? | outputPortion methodName2 ( inputPortion )? -> ( outputPortion )? methodName2 ( inputPortion )? | methodName3 ( inputPortion )? -> methodName3 ( inputPortion )? );";
		}
	}

	static final String DFA100_eotS =
		"\103\uffff";
	static final String DFA100_eofS =
		"\1\51\102\uffff";
	static final String DFA100_minS =
		"\1\4\45\uffff\3\0\24\uffff\1\0\5\uffff";
	static final String DFA100_maxS =
		"\1\137\45\uffff\3\0\24\uffff\1\0\5\uffff";
	static final String DFA100_acceptS =
		"\1\uffff\1\6\2\uffff\1\6\1\uffff\1\6\12\uffff\1\6\1\uffff\1\6\16\uffff"+
		"\1\6\6\uffff\1\6\24\uffff\1\4\1\3\1\5\1\1\1\2";
	static final String DFA100_specialS =
		"\1\0\45\uffff\1\1\1\2\1\3\24\uffff\1\4\5\uffff}>";
	static final String[] DFA100_transitionS = {
			"\1\23\1\uffff\1\1\1\50\2\uffff\2\51\2\uffff\1\23\1\1\1\51\1\uffff\1\51"+
			"\1\6\7\uffff\1\75\2\uffff\2\51\3\23\1\51\1\uffff\1\51\1\uffff\1\51\2"+
			"\23\1\1\1\51\1\42\1\uffff\1\46\1\6\6\uffff\1\47\1\42\2\23\1\21\4\6\1"+
			"\4\1\23\1\uffff\1\23\3\51\1\21\1\uffff\1\6\1\4\1\uffff\1\51\1\6\1\42"+
			"\1\51\1\23\1\6\3\23\2\uffff\1\51\1\uffff\1\42\1\uffff\1\51\2\6\1\51\1"+
			"\uffff\1\51",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\uffff",
			"\1\uffff",
			"\1\uffff",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\uffff",
			"",
			"",
			"",
			"",
			""
	};

	static final short[] DFA100_eot = DFA.unpackEncodedString(DFA100_eotS);
	static final short[] DFA100_eof = DFA.unpackEncodedString(DFA100_eofS);
	static final char[] DFA100_min = DFA.unpackEncodedStringToUnsignedChars(DFA100_minS);
	static final char[] DFA100_max = DFA.unpackEncodedStringToUnsignedChars(DFA100_maxS);
	static final short[] DFA100_accept = DFA.unpackEncodedString(DFA100_acceptS);
	static final short[] DFA100_special = DFA.unpackEncodedString(DFA100_specialS);
	static final short[][] DFA100_transition;

	static {
		int numStates = DFA100_transitionS.length;
		DFA100_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA100_transition[i] = DFA.unpackEncodedString(DFA100_transitionS[i]);
		}
	}

	protected class DFA100 extends DFA {

		public DFA100(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 100;
			this.eot = DFA100_eot;
			this.eof = DFA100_eof;
			this.min = DFA100_min;
			this.max = DFA100_max;
			this.accept = DFA100_accept;
			this.special = DFA100_special;
			this.transition = DFA100_transition;
		}
		@Override
		public String getDescription() {
			return "()* loopback of 476:5: ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )*";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA100_0 = input.LA(1);
						 
						int index100_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA100_0==ASSIGN||LA100_0==COMMA||LA100_0==ID) ) {s = 1;}
						else if ( (LA100_0==NOT||LA100_0==QUESTION) && (((Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 4;}
						else if ( (LA100_0==CTRANS||LA100_0==LDIV||(LA100_0 >= MLDIV && LA100_0 <= MTIMES)||LA100_0==POW||LA100_0==RDIV||LA100_0==RSQUARE||(LA100_0 >= TIMES && LA100_0 <= TRANS)) ) {s = 6;}
						else if ( (LA100_0==MINUS||LA100_0==PLUS) && (((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 17;}
						else if ( (LA100_0==AND||LA100_0==COLON||(LA100_0 >= END && LA100_0 <= EQ)||(LA100_0 >= GT && LA100_0 <= GTEQ)||(LA100_0 >= LT && LA100_0 <= LTEQ)||LA100_0==NOTEQ||LA100_0==OR||LA100_0==RPAREN||(LA100_0 >= SEMICOLON && LA100_0 <= SHORTOR)) ) {s = 19;}
						else if ( (LA100_0==IMAGINARY||LA100_0==LSQUARE||LA100_0==REAL||LA100_0==STRING) && (((Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 34;}
						else if ( (LA100_0==LCURLY) && ((((Chain_MayAddCurlyBrace())&&(!Balance_InCreationOrStore_SpacesOnLeft()))||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 38;}
						else if ( (LA100_0==LPAREN) && ((((!Balance_InCreationOrStore_SpacesOnLeft())&&(Chain_MayAddParenthesis()))||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 39;}
						else if ( (LA100_0==AT) && ((((!Balance_InCreationOrStore_SpacesOnLeft())&&(Chain_MayAddAtBase()))||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 40;}
						else if ( (LA100_0==EOF||(LA100_0 >= BREAK && LA100_0 <= CASE)||LA100_0==COMMAND||LA100_0==CONTINUE||(LA100_0 >= ELSE && LA100_0 <= ELSEIF)||LA100_0==EXCLAMATION||LA100_0==FOR||LA100_0==GLOBAL||LA100_0==IF||(LA100_0 >= OTHERWISE && LA100_0 <= PERSISTENT)||LA100_0==RCURLY||LA100_0==RETURN||LA100_0==SPMD||LA100_0==SWITCH||LA100_0==TRY||LA100_0==WHILE) ) {s = 41;}
						else if ( (LA100_0==DOT) && ((Chain_MayAddDotName()))) {s = 61;}
						 
						input.seek(index100_0);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA100_38 = input.LA(1);
						 
						int index100_38 = input.index();
						input.rewind();
						s = -1;
						if ( (((Chain_MayAddCurlyBrace())&&(!Balance_InCreationOrStore_SpacesOnLeft()))) ) {s = 62;}
						else if ( (((Separator_CommaFollowsOrSpacesPrecede())||(True()))) ) {s = 41;}
						 
						input.seek(index100_38);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA100_39 = input.LA(1);
						 
						int index100_39 = input.index();
						input.rewind();
						s = -1;
						if ( (((!Balance_InCreationOrStore_SpacesOnLeft())&&(Chain_MayAddParenthesis()))) ) {s = 63;}
						else if ( (((Separator_CommaFollowsOrSpacesPrecede())||(True()))) ) {s = 41;}
						 
						input.seek(index100_39);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA100_40 = input.LA(1);
						 
						int index100_40 = input.index();
						input.rewind();
						s = -1;
						if ( (((!Balance_InCreationOrStore_SpacesOnLeft())&&(Chain_MayAddAtBase()))) ) {s = 64;}
						else if ( (((Separator_CommaFollowsOrSpacesPrecede())||(True()))) ) {s = 41;}
						 
						input.seek(index100_40);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA100_61 = input.LA(1);
						 
						int index100_61 = input.index();
						input.rewind();
						s = -1;
						if ( (((Chain_MayAddDotExpression())&&synpred9_MatlabParser())) ) {s = 65;}
						else if ( ((Chain_MayAddDotName())) ) {s = 66;}
						 
						input.seek(index100_61);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 100, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA129_eotS =
		"\u00be\uffff";
	static final String DFA129_eofS =
		"\u00be\uffff";
	static final String DFA129_minS =
		"\1\52\1\uffff\1\4\1\uffff\1\23\1\uffff\5\16\3\uffff\1\34\1\0\2\34\1\0"+
		"\2\34\3\67\1\34\6\uffff\3\17\1\34\1\16\3\17\1\34\3\67\3\117\1\0\1\34\3"+
		"\17\1\117\2\34\4\17\1\uffff\1\0\1\34\1\0\1\34\4\17\2\0\3\17\1\117\1\34"+
		"\1\0\3\17\1\34\4\17\1\34\1\17\1\34\2\uffff\3\17\1\34\1\0\4\17\1\34\1\0"+
		"\1\34\3\17\1\34\4\17\2\34\1\16\5\17\2\34\4\17\1\34\12\17\1\34\1\17\1\34"+
		"\6\17\1\34\3\17\1\34\4\17\1\34\3\17\1\34\7\17\1\34\4\17\1\34\12\17\1\34"+
		"\3\17\1\34\6\17";
	static final String DFA129_maxS =
		"\1\66\1\uffff\1\121\1\uffff\1\137\1\uffff\3\117\2\16\3\uffff\1\76\1\0"+
		"\1\117\1\76\1\0\2\76\3\117\1\120\6\uffff\3\117\1\120\4\117\1\120\6\117"+
		"\1\0\4\120\1\117\1\76\4\120\1\117\1\uffff\1\0\1\117\1\0\4\120\1\117\2"+
		"\0\3\120\1\117\1\115\1\0\3\117\4\120\1\117\1\115\1\117\1\115\2\uffff\3"+
		"\117\1\120\1\0\3\120\1\117\1\115\1\0\1\115\7\120\1\117\1\115\1\76\1\117"+
		"\5\120\1\76\4\120\1\117\1\115\11\120\1\117\1\115\1\117\1\115\3\120\3\117"+
		"\1\120\3\117\4\120\1\117\1\115\3\120\1\115\13\120\1\117\1\115\11\120\1"+
		"\117\1\115\3\120\1\115\6\120";
	static final String DFA129_acceptS =
		"\1\uffff\1\1\1\uffff\1\2\1\uffff\1\7\5\uffff\1\14\1\15\1\16\13\uffff\1"+
		"\3\1\4\1\10\1\11\1\12\1\17\33\uffff\1\13\33\uffff\1\5\1\6\146\uffff";
	static final String DFA129_specialS =
		"\2\uffff\1\177\1\uffff\1\63\1\uffff\1\u008b\1\161\1\162\1\120\1\143\3"+
		"\uffff\1\147\1\11\1\126\1\u00a6\1\14\1\121\1\u0092\1\62\1\15\1\176\1\156"+
		"\6\uffff\1\60\1\104\1\12\1\u0090\1\107\1\166\1\114\1\167\1\55\1\u00aa"+
		"\1\123\1\142\1\165\1\115\1\u008c\1\u009f\1\157\1\1\1\16\1\105\1\174\1"+
		"\160\1\2\1\44\1\102\1\172\1\u008e\1\uffff\1\175\1\125\1\43\1\56\1\u00a1"+
		"\1\130\1\u00a8\1\122\1\76\1\111\1\3\1\17\1\106\1\164\1\u0094\1\127\1\112"+
		"\1\124\1\54\1\u0091\1\45\1\66\1\132\1\u008d\1\21\1\u008f\1\153\2\uffff"+
		"\1\75\1\145\1\20\1\4\1\77\1\u00a2\1\131\1\u00a9\1\117\1\u009d\1\141\1"+
		"\u0095\1\151\1\170\1\u00ac\1\5\1\46\1\103\1\173\1\u00ab\1\22\1\146\1\155"+
		"\1\u0083\1\u0096\1\23\1\u0081\1\41\1\163\1\6\1\47\1\67\1\133\1\u00a7\1"+
		"\u009e\1\64\1\u00a4\1\100\1\152\1\171\1\u00ad\1\50\1\70\1\134\1\110\1"+
		"\24\1\113\1\154\1\u0084\1\u0097\1\25\1\u0080\1\13\1\144\1\0\1\150\1\u00a0"+
		"\1\116\1\7\1\51\1\71\1\135\1\u00a3\1\32\1\65\1\u00a5\1\101\1\33\1\u0085"+
		"\1\u0093\1\34\1\u0082\1\42\1\72\1\136\1\10\1\52\1\73\1\137\1\61\1\36\1"+
		"\u0086\1\u0098\1\30\1\u0087\1\u0099\1\26\1\53\1\74\1\140\1\57\1\40\1\u0088"+
		"\1\u009a\1\35\1\37\1\u0089\1\u009b\1\27\1\u008a\1\u009c\1\31}>";
	static final String[] DFA129_transitionS = {
			"\1\2\13\uffff\1\1",
			"",
			"\1\3\11\uffff\2\3\20\uffff\2\3\24\uffff\1\4\13\uffff\1\3\14\uffff\1"+
			"\3\1\uffff\1\3",
			"",
			"\1\13\10\uffff\1\10\10\uffff\1\11\1\14\3\uffff\1\6\4\uffff\1\13\7\uffff"+
			"\1\15\2\uffff\4\13\1\7\7\uffff\1\13\1\uffff\1\13\3\uffff\1\13\2\uffff"+
			"\1\5\13\uffff\2\13\2\uffff\1\12",
			"",
			"\1\16\47\uffff\1\20\30\uffff\1\17",
			"\1\21\47\uffff\1\20\30\uffff\1\22",
			"\1\23\47\uffff\1\20\30\uffff\1\17",
			"\1\24",
			"\1\24",
			"",
			"",
			"",
			"\1\27\15\uffff\1\25\14\uffff\1\30\6\uffff\1\26",
			"\1\uffff",
			"\1\41\15\uffff\1\37\14\uffff\1\42\6\uffff\1\40\20\uffff\1\43",
			"\1\46\15\uffff\1\44\14\uffff\1\47\6\uffff\1\45",
			"\1\uffff",
			"\1\52\15\uffff\1\50\14\uffff\1\30\6\uffff\1\51",
			"\1\55\15\uffff\1\53\23\uffff\1\54",
			"\1\57\27\uffff\1\56",
			"\1\57\27\uffff\1\56",
			"\1\57\27\uffff\1\56",
			"\1\62\41\uffff\1\61\16\uffff\1\60\2\uffff\1\63",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\64\47\uffff\1\65\27\uffff\1\43",
			"\1\64\47\uffff\1\65\27\uffff\1\43",
			"\1\64\47\uffff\1\65\27\uffff\1\43",
			"\1\70\15\uffff\1\72\23\uffff\1\67\16\uffff\1\66\2\uffff\1\71",
			"\1\74\100\uffff\1\73",
			"\1\13\47\uffff\1\76\27\uffff\1\75",
			"\1\13\47\uffff\1\76\27\uffff\1\75",
			"\1\13\47\uffff\1\76\27\uffff\1\75",
			"\1\101\41\uffff\1\100\16\uffff\1\77\2\uffff\1\102",
			"\1\57\27\uffff\1\103",
			"\1\57\27\uffff\1\103",
			"\1\57\27\uffff\1\103",
			"\1\104",
			"\1\104",
			"\1\104",
			"\1\uffff",
			"\1\107\41\uffff\1\106\16\uffff\1\105\2\uffff\1\110",
			"\1\111\100\uffff\1\63",
			"\1\111\100\uffff\1\63",
			"\1\111\100\uffff\1\63",
			"\1\112",
			"\1\115\15\uffff\1\113\14\uffff\1\116\6\uffff\1\114",
			"\1\121\41\uffff\1\120\16\uffff\1\117\2\uffff\1\122",
			"\1\123\100\uffff\1\124",
			"\1\125\100\uffff\1\71",
			"\1\125\100\uffff\1\71",
			"\1\64\77\uffff\1\43",
			"",
			"\1\uffff",
			"\1\132\15\uffff\1\130\14\uffff\1\133\6\uffff\1\131\20\uffff\1\134",
			"\1\uffff",
			"\1\137\41\uffff\1\136\16\uffff\1\135\2\uffff\1\140",
			"\1\141\100\uffff\1\102",
			"\1\141\100\uffff\1\102",
			"\1\141\100\uffff\1\102",
			"\1\13\77\uffff\1\142",
			"\1\uffff",
			"\1\uffff",
			"\1\143\100\uffff\1\110",
			"\1\143\100\uffff\1\110",
			"\1\143\100\uffff\1\110",
			"\1\112",
			"\1\146\41\uffff\1\145\16\uffff\1\144",
			"\1\uffff",
			"\1\64\47\uffff\1\147\27\uffff\1\43",
			"\1\64\47\uffff\1\147\27\uffff\1\43",
			"\1\64\47\uffff\1\147\27\uffff\1\43",
			"\1\152\15\uffff\1\72\23\uffff\1\151\16\uffff\1\150\2\uffff\1\153",
			"\1\154\100\uffff\1\122",
			"\1\154\100\uffff\1\122",
			"\1\154\100\uffff\1\122",
			"\1\155\77\uffff\1\156",
			"\1\161\41\uffff\1\160\16\uffff\1\157",
			"\1\155\77\uffff\1\156",
			"\1\163\15\uffff\1\72\23\uffff\1\162\16\uffff\1\157",
			"",
			"",
			"\1\164\47\uffff\1\165\27\uffff\1\134",
			"\1\164\47\uffff\1\165\27\uffff\1\134",
			"\1\164\47\uffff\1\165\27\uffff\1\134",
			"\1\170\41\uffff\1\167\16\uffff\1\166\2\uffff\1\171",
			"\1\uffff",
			"\1\172\100\uffff\1\140",
			"\1\172\100\uffff\1\140",
			"\1\172\100\uffff\1\140",
			"\1\13\77\uffff\1\142",
			"\1\175\41\uffff\1\174\16\uffff\1\173",
			"\1\uffff",
			"\1\u0080\41\uffff\1\177\16\uffff\1\176",
			"\1\111\100\uffff\1\63",
			"\1\111\100\uffff\1\63",
			"\1\111\100\uffff\1\63",
			"\1\u0083\41\uffff\1\u0082\16\uffff\1\u0081\2\uffff\1\u0084",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0087\100\uffff\1\153",
			"\1\u0087\100\uffff\1\153",
			"\1\64\77\uffff\1\43",
			"\1\u008a\41\uffff\1\u0089\16\uffff\1\u0088",
			"\1\u008d\15\uffff\1\u008b\14\uffff\1\u008e\6\uffff\1\u008c",
			"\1\74\100\uffff\1\134",
			"\1\123\100\uffff\1\124",
			"\1\123\100\uffff\1\124",
			"\1\123\100\uffff\1\124",
			"\1\125\100\uffff\1\71",
			"\1\125\100\uffff\1\71",
			"\1\u0091\15\uffff\1\u008f\14\uffff\1\u0092\6\uffff\1\u0090",
			"\1\u0095\41\uffff\1\u0094\16\uffff\1\u0093\2\uffff\1\u0096",
			"\1\u0097\100\uffff\1\171",
			"\1\u0097\100\uffff\1\171",
			"\1\u0097\100\uffff\1\171",
			"\1\164\77\uffff\1\134",
			"\1\u009a\41\uffff\1\u0099\16\uffff\1\u0098",
			"\1\141\100\uffff\1\102",
			"\1\141\100\uffff\1\102",
			"\1\141\100\uffff\1\102",
			"\1\143\100\uffff\1\110",
			"\1\143\100\uffff\1\110",
			"\1\143\100\uffff\1\110",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u009b\100\uffff\1\u0084",
			"\1\155\77\uffff\1\156",
			"\1\u009e\41\uffff\1\u009d\16\uffff\1\u009c",
			"\1\155\77\uffff\1\156",
			"\1\u00a0\15\uffff\1\72\23\uffff\1\u009f\16\uffff\1\u009c",
			"\1\154\100\uffff\1\122",
			"\1\154\100\uffff\1\122",
			"\1\154\100\uffff\1\122",
			"\1\155\47\uffff\1\147\27\uffff\1\156",
			"\1\155\47\uffff\1\147\27\uffff\1\156",
			"\1\155\47\uffff\1\147\27\uffff\1\156",
			"\1\u00a2\41\uffff\1\u00a1\16\uffff\1\150\2\uffff\1\u0086",
			"\1\164\47\uffff\1\u00a3\27\uffff\1\134",
			"\1\164\47\uffff\1\u00a3\27\uffff\1\134",
			"\1\164\47\uffff\1\u00a3\27\uffff\1\134",
			"\1\u00a6\41\uffff\1\u00a5\16\uffff\1\u00a4\2\uffff\1\u00a7",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\164\77\uffff\1\134",
			"\1\u00ab\41\uffff\1\u00aa\16\uffff\1\u00a9",
			"\1\172\100\uffff\1\140",
			"\1\172\100\uffff\1\140",
			"\1\172\100\uffff\1\140",
			"\1\u00ae\41\uffff\1\u00ad\16\uffff\1\u00ac",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0087\100\uffff\1\153",
			"\1\u0087\100\uffff\1\153",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u00b1\41\uffff\1\u00b0\16\uffff\1\u00af\2\uffff\1\u00b2",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\164\77\uffff\1\134",
			"\1\u00b6\41\uffff\1\u00b5\16\uffff\1\u00b4",
			"\1\u0097\100\uffff\1\171",
			"\1\u0097\100\uffff\1\171",
			"\1\u0097\100\uffff\1\171",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\164\77\uffff\1\134",
			"\1\u00ba\41\uffff\1\u00b9\16\uffff\1\u00b8",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00bd\41\uffff\1\u00bc\16\uffff\1\u00bb",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\u00b7\100\uffff\1\u00b2"
	};

	static final short[] DFA129_eot = DFA.unpackEncodedString(DFA129_eotS);
	static final short[] DFA129_eof = DFA.unpackEncodedString(DFA129_eofS);
	static final char[] DFA129_min = DFA.unpackEncodedStringToUnsignedChars(DFA129_minS);
	static final char[] DFA129_max = DFA.unpackEncodedStringToUnsignedChars(DFA129_maxS);
	static final short[] DFA129_accept = DFA.unpackEncodedString(DFA129_acceptS);
	static final short[] DFA129_special = DFA.unpackEncodedString(DFA129_specialS);
	static final short[][] DFA129_transition;

	static {
		int numStates = DFA129_transitionS.length;
		DFA129_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA129_transition[i] = DFA.unpackEncodedString(DFA129_transitionS[i]);
		}
	}

	protected class DFA129 extends DFA {

		public DFA129(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 129;
			this.eot = DFA129_eot;
			this.eof = DFA129_eof;
			this.min = DFA129_min;
			this.max = DFA129_max;
			this.accept = DFA129_accept;
			this.special = DFA129_special;
			this.transition = DFA129_transition;
		}
		@Override
		public String getDescription() {
			return "686:1: aspectAtom : ( aspectParenthesis -> aspectParenthesis | aspectName -> aspectName | aspectGet -> aspectGet | aspectSet -> aspectSet | aspectCall -> aspectCall | aspectExecution -> aspectExecution | aspectMainExecution -> aspectMainExecution | aspectLoop -> aspectLoop | aspectLoopHead -> aspectLoopHead | aspectLoopBody -> aspectLoopBody | aspectAnnotate -> aspectAnnotate | aspectOperator -> aspectOperator | aspectWithin -> aspectWithin | aspectDimension -> aspectDimension | aspectIsType -> aspectIsType );";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA129_142 = input.LA(1);
						 
						int index129_142 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_142==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 104;}
						else if ( (LA129_142==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 161;}
						else if ( (LA129_142==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 162;}
						else if ( (LA129_142==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						 
						input.seek(index129_142);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA129_48 = input.LA(1);
						 
						int index129_48 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_48==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						else if ( (LA129_48==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						 
						input.seek(index129_48);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA129_53 = input.LA(1);
						 
						int index129_53 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_53==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 79;}
						else if ( (LA129_53==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 80;}
						else if ( (LA129_53==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 81;}
						else if ( (LA129_53==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						 
						input.seek(index129_53);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA129_69 = input.LA(1);
						 
						int index129_69 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_69==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						else if ( (LA129_69==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						 
						input.seek(index129_69);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA129_91 = input.LA(1);
						 
						int index129_91 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_91==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 118;}
						else if ( (LA129_91==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 119;}
						else if ( (LA129_91==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 120;}
						else if ( (LA129_91==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						 
						input.seek(index129_91);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA129_103 = input.LA(1);
						 
						int index129_103 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_103==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 129;}
						else if ( (LA129_103==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 130;}
						else if ( (LA129_103==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 131;}
						else if ( (LA129_103==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						 
						input.seek(index129_103);
						if ( s>=0 ) return s;
						break;

					case 6 : 
						int LA129_117 = input.LA(1);
						 
						int index129_117 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_117==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 147;}
						else if ( (LA129_117==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 148;}
						else if ( (LA129_117==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 149;}
						else if ( (LA129_117==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						 
						input.seek(index129_117);
						if ( s>=0 ) return s;
						break;

					case 7 : 
						int LA129_146 = input.LA(1);
						 
						int index129_146 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_146==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 164;}
						else if ( (LA129_146==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 165;}
						else if ( (LA129_146==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 166;}
						else if ( (LA129_146==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						 
						input.seek(index129_146);
						if ( s>=0 ) return s;
						break;

					case 8 : 
						int LA129_163 = input.LA(1);
						 
						int index129_163 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_163==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 175;}
						else if ( (LA129_163==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 176;}
						else if ( (LA129_163==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 177;}
						else if ( (LA129_163==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						 
						input.seek(index129_163);
						if ( s>=0 ) return s;
						break;

					case 9 : 
						int LA129_15 = input.LA(1);
						 
						int index129_15 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						else if ( ((Keyword_IdFollows("istype"))) ) {s = 30;}
						 
						input.seek(index129_15);
						if ( s>=0 ) return s;
						break;

					case 10 : 
						int LA129_33 = input.LA(1);
						 
						int index129_33 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_33==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA129_33==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA129_33==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 53;}
						 
						input.seek(index129_33);
						if ( s>=0 ) return s;
						break;

					case 11 : 
						int LA129_140 = input.LA(1);
						 
						int index129_140 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_140==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA129_140==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA129_140==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index129_140);
						if ( s>=0 ) return s;
						break;

					case 12 : 
						int LA129_18 = input.LA(1);
						 
						int index129_18 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						else if ( ((Keyword_IdFollows("op"))) ) {s = 11;}
						else if ( ((Keyword_IdFollows("istype"))) ) {s = 30;}
						 
						input.seek(index129_18);
						if ( s>=0 ) return s;
						break;

					case 13 : 
						int LA129_22 = input.LA(1);
						 
						int index129_22 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_22==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 46;}
						else if ( (LA129_22==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index129_22);
						if ( s>=0 ) return s;
						break;

					case 14 : 
						int LA129_49 = input.LA(1);
						 
						int index129_49 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_49==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						else if ( (LA129_49==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						 
						input.seek(index129_49);
						if ( s>=0 ) return s;
						break;

					case 15 : 
						int LA129_70 = input.LA(1);
						 
						int index129_70 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_70==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						else if ( (LA129_70==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						 
						input.seek(index129_70);
						if ( s>=0 ) return s;
						break;

					case 16 : 
						int LA129_90 = input.LA(1);
						 
						int index129_90 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_90==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA129_90==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA129_90==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 117;}
						 
						input.seek(index129_90);
						if ( s>=0 ) return s;
						break;

					case 17 : 
						int LA129_83 = input.LA(1);
						 
						int index129_83 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_83==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 111;}
						else if ( (LA129_83==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 112;}
						else if ( (LA129_83==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 113;}
						 
						input.seek(index129_83);
						if ( s>=0 ) return s;
						break;

					case 18 : 
						int LA129_108 = input.LA(1);
						 
						int index129_108 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_108==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 136;}
						else if ( (LA129_108==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 137;}
						else if ( (LA129_108==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 138;}
						 
						input.seek(index129_108);
						if ( s>=0 ) return s;
						break;

					case 19 : 
						int LA129_113 = input.LA(1);
						 
						int index129_113 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_113==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 84;}
						else if ( (LA129_113==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 83;}
						 
						input.seek(index129_113);
						if ( s>=0 ) return s;
						break;

					case 20 : 
						int LA129_133 = input.LA(1);
						 
						int index129_133 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_133==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 156;}
						else if ( (LA129_133==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 157;}
						else if ( (LA129_133==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 158;}
						 
						input.seek(index129_133);
						if ( s>=0 ) return s;
						break;

					case 21 : 
						int LA129_138 = input.LA(1);
						 
						int index129_138 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_138==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						else if ( (LA129_138==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						 
						input.seek(index129_138);
						if ( s>=0 ) return s;
						break;

					case 22 : 
						int LA129_174 = input.LA(1);
						 
						int index129_174 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_174==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						else if ( (LA129_174==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						 
						input.seek(index129_174);
						if ( s>=0 ) return s;
						break;

					case 23 : 
						int LA129_186 = input.LA(1);
						 
						int index129_186 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_186==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						else if ( (LA129_186==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						 
						input.seek(index129_186);
						if ( s>=0 ) return s;
						break;

					case 24 : 
						int LA129_171 = input.LA(1);
						 
						int index129_171 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_171==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						else if ( (LA129_171==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						 
						input.seek(index129_171);
						if ( s>=0 ) return s;
						break;

					case 25 : 
						int LA129_189 = input.LA(1);
						 
						int index129_189 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_189==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						else if ( (LA129_189==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						 
						input.seek(index129_189);
						if ( s>=0 ) return s;
						break;

					case 26 : 
						int LA129_151 = input.LA(1);
						 
						int index129_151 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_151==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 169;}
						else if ( (LA129_151==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 170;}
						else if ( (LA129_151==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 171;}
						 
						input.seek(index129_151);
						if ( s>=0 ) return s;
						break;

					case 27 : 
						int LA129_155 = input.LA(1);
						 
						int index129_155 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_155==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 172;}
						else if ( (LA129_155==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 173;}
						else if ( (LA129_155==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 174;}
						 
						input.seek(index129_155);
						if ( s>=0 ) return s;
						break;

					case 28 : 
						int LA129_158 = input.LA(1);
						 
						int index129_158 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_158==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						else if ( (LA129_158==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						 
						input.seek(index129_158);
						if ( s>=0 ) return s;
						break;

					case 29 : 
						int LA129_182 = input.LA(1);
						 
						int index129_182 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_182==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						else if ( (LA129_182==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						 
						input.seek(index129_182);
						if ( s>=0 ) return s;
						break;

					case 30 : 
						int LA129_168 = input.LA(1);
						 
						int index129_168 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_168==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 180;}
						else if ( (LA129_168==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 181;}
						else if ( (LA129_168==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 182;}
						 
						input.seek(index129_168);
						if ( s>=0 ) return s;
						break;

					case 31 : 
						int LA129_183 = input.LA(1);
						 
						int index129_183 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_183==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 187;}
						else if ( (LA129_183==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 188;}
						else if ( (LA129_183==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 189;}
						 
						input.seek(index129_183);
						if ( s>=0 ) return s;
						break;

					case 32 : 
						int LA129_179 = input.LA(1);
						 
						int index129_179 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_179==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 184;}
						else if ( (LA129_179==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 185;}
						else if ( (LA129_179==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 186;}
						 
						input.seek(index129_179);
						if ( s>=0 ) return s;
						break;

					case 33 : 
						int LA129_115 = input.LA(1);
						 
						int index129_115 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_115==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						else if ( (LA129_115==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 85;}
						 
						input.seek(index129_115);
						if ( s>=0 ) return s;
						break;

					case 34 : 
						int LA129_160 = input.LA(1);
						 
						int index129_160 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_160==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						else if ( (LA129_160==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 135;}
						 
						input.seek(index129_160);
						if ( s>=0 ) return s;
						break;

					case 35 : 
						int LA129_61 = input.LA(1);
						 
						int index129_61 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						else if ( ((Keyword_IdFollows("op"))) ) {s = 11;}
						else if ( ((Keyword_IdFollows("within"))) ) {s = 12;}
						 
						input.seek(index129_61);
						if ( s>=0 ) return s;
						break;

					case 36 : 
						int LA129_54 = input.LA(1);
						 
						int index129_54 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_54==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 83;}
						else if ( (LA129_54==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 84;}
						 
						input.seek(index129_54);
						if ( s>=0 ) return s;
						break;

					case 37 : 
						int LA129_79 = input.LA(1);
						 
						int index129_79 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_79==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						else if ( (LA129_79==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						 
						input.seek(index129_79);
						if ( s>=0 ) return s;
						break;

					case 38 : 
						int LA129_104 = input.LA(1);
						 
						int index129_104 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_104==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						else if ( (LA129_104==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						 
						input.seek(index129_104);
						if ( s>=0 ) return s;
						break;

					case 39 : 
						int LA129_118 = input.LA(1);
						 
						int index129_118 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_118==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						else if ( (LA129_118==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						 
						input.seek(index129_118);
						if ( s>=0 ) return s;
						break;

					case 40 : 
						int LA129_129 = input.LA(1);
						 
						int index129_129 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_129==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						else if ( (LA129_129==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						 
						input.seek(index129_129);
						if ( s>=0 ) return s;
						break;

					case 41 : 
						int LA129_147 = input.LA(1);
						 
						int index129_147 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_147==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						else if ( (LA129_147==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						 
						input.seek(index129_147);
						if ( s>=0 ) return s;
						break;

					case 42 : 
						int LA129_164 = input.LA(1);
						 
						int index129_164 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_164==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						else if ( (LA129_164==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						 
						input.seek(index129_164);
						if ( s>=0 ) return s;
						break;

					case 43 : 
						int LA129_175 = input.LA(1);
						 
						int index129_175 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_175==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						else if ( (LA129_175==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						 
						input.seek(index129_175);
						if ( s>=0 ) return s;
						break;

					case 44 : 
						int LA129_77 = input.LA(1);
						 
						int index129_77 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_77==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA129_77==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA129_77==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index129_77);
						if ( s>=0 ) return s;
						break;

					case 45 : 
						int LA129_39 = input.LA(1);
						 
						int index129_39 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_39==REAL) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 63;}
						else if ( (LA129_39==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 64;}
						else if ( (LA129_39==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 65;}
						else if ( (LA129_39==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						 
						input.seek(index129_39);
						if ( s>=0 ) return s;
						break;

					case 46 : 
						int LA129_62 = input.LA(1);
						 
						int index129_62 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_62==REAL) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 93;}
						else if ( (LA129_62==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 94;}
						else if ( (LA129_62==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 95;}
						else if ( (LA129_62==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						 
						input.seek(index129_62);
						if ( s>=0 ) return s;
						break;

					case 47 : 
						int LA129_178 = input.LA(1);
						 
						int index129_178 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_178==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA129_178==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						 
						input.seek(index129_178);
						if ( s>=0 ) return s;
						break;

					case 48 : 
						int LA129_31 = input.LA(1);
						 
						int index129_31 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_31==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA129_31==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA129_31==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 53;}
						 
						input.seek(index129_31);
						if ( s>=0 ) return s;
						break;

					case 49 : 
						int LA129_167 = input.LA(1);
						 
						int index129_167 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_167==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA129_167==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						 
						input.seek(index129_167);
						if ( s>=0 ) return s;
						break;

					case 50 : 
						int LA129_21 = input.LA(1);
						 
						int index129_21 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_21==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 46;}
						else if ( (LA129_21==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index129_21);
						if ( s>=0 ) return s;
						break;

					case 51 : 
						int LA129_4 = input.LA(1);
						 
						int index129_4 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_4==RPAREN) && ((Keyword_IdFollows("mainexecution")))) {s = 5;}
						else if ( (LA129_4==ID) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("execution"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("annotate"))))) {s = 6;}
						else if ( (LA129_4==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("istype"))||(Keyword_IdFollows("execution"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("annotate"))))) {s = 7;}
						else if ( (LA129_4==DOTDOT) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("execution"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("annotate"))))) {s = 8;}
						else if ( (LA129_4==FOR) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 9;}
						else if ( (LA129_4==WHILE) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 10;}
						else if ( (LA129_4==CTRANS||LA129_4==LDIV||(LA129_4 >= MINUS && LA129_4 <= MRDIV)||LA129_4==PLUS||LA129_4==POW||LA129_4==RDIV||(LA129_4 >= TIMES && LA129_4 <= TRANS)) && ((Keyword_IdFollows("op")))) {s = 11;}
						else if ( (LA129_4==FUNCTION) && ((Keyword_IdFollows("within")))) {s = 12;}
						else if ( (LA129_4==LSQUARE) && ((Keyword_IdFollows("dimension")))) {s = 13;}
						 
						input.seek(index129_4);
						if ( s>=0 ) return s;
						break;

					case 52 : 
						int LA129_123 = input.LA(1);
						 
						int index129_123 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_123==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						else if ( (LA129_123==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						 
						input.seek(index129_123);
						if ( s>=0 ) return s;
						break;

					case 53 : 
						int LA129_152 = input.LA(1);
						 
						int index129_152 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_152==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						else if ( (LA129_152==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						 
						input.seek(index129_152);
						if ( s>=0 ) return s;
						break;

					case 54 : 
						int LA129_80 = input.LA(1);
						 
						int index129_80 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_80==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						else if ( (LA129_80==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						 
						input.seek(index129_80);
						if ( s>=0 ) return s;
						break;

					case 55 : 
						int LA129_119 = input.LA(1);
						 
						int index129_119 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_119==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						else if ( (LA129_119==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						 
						input.seek(index129_119);
						if ( s>=0 ) return s;
						break;

					case 56 : 
						int LA129_130 = input.LA(1);
						 
						int index129_130 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_130==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						else if ( (LA129_130==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						 
						input.seek(index129_130);
						if ( s>=0 ) return s;
						break;

					case 57 : 
						int LA129_148 = input.LA(1);
						 
						int index129_148 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_148==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						else if ( (LA129_148==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						 
						input.seek(index129_148);
						if ( s>=0 ) return s;
						break;

					case 58 : 
						int LA129_161 = input.LA(1);
						 
						int index129_161 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_161==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						else if ( (LA129_161==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						 
						input.seek(index129_161);
						if ( s>=0 ) return s;
						break;

					case 59 : 
						int LA129_165 = input.LA(1);
						 
						int index129_165 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_165==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						else if ( (LA129_165==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						 
						input.seek(index129_165);
						if ( s>=0 ) return s;
						break;

					case 60 : 
						int LA129_176 = input.LA(1);
						 
						int index129_176 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_176==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						else if ( (LA129_176==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						 
						input.seek(index129_176);
						if ( s>=0 ) return s;
						break;

					case 61 : 
						int LA129_88 = input.LA(1);
						 
						int index129_88 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_88==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA129_88==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA129_88==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 117;}
						 
						input.seek(index129_88);
						if ( s>=0 ) return s;
						break;

					case 62 : 
						int LA129_67 = input.LA(1);
						 
						int index129_67 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						else if ( ((Keyword_IdFollows("within"))) ) {s = 12;}
						 
						input.seek(index129_67);
						if ( s>=0 ) return s;
						break;

					case 63 : 
						int LA129_92 = input.LA(1);
						 
						int index129_92 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("call"))) ) {s = 86;}
						else if ( ((Keyword_IdFollows("execution"))) ) {s = 87;}
						 
						input.seek(index129_92);
						if ( s>=0 ) return s;
						break;

					case 64 : 
						int LA129_125 = input.LA(1);
						 
						int index129_125 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_125==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						else if ( (LA129_125==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						 
						input.seek(index129_125);
						if ( s>=0 ) return s;
						break;

					case 65 : 
						int LA129_154 = input.LA(1);
						 
						int index129_154 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_154==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						else if ( (LA129_154==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						 
						input.seek(index129_154);
						if ( s>=0 ) return s;
						break;

					case 66 : 
						int LA129_55 = input.LA(1);
						 
						int index129_55 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_55==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 85;}
						else if ( (LA129_55==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						 
						input.seek(index129_55);
						if ( s>=0 ) return s;
						break;

					case 67 : 
						int LA129_105 = input.LA(1);
						 
						int index129_105 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_105==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 135;}
						else if ( (LA129_105==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						 
						input.seek(index129_105);
						if ( s>=0 ) return s;
						break;

					case 68 : 
						int LA129_32 = input.LA(1);
						 
						int index129_32 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_32==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA129_32==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA129_32==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 53;}
						 
						input.seek(index129_32);
						if ( s>=0 ) return s;
						break;

					case 69 : 
						int LA129_50 = input.LA(1);
						 
						int index129_50 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_50==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						else if ( (LA129_50==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						 
						input.seek(index129_50);
						if ( s>=0 ) return s;
						break;

					case 70 : 
						int LA129_71 = input.LA(1);
						 
						int index129_71 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_71==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						else if ( (LA129_71==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						 
						input.seek(index129_71);
						if ( s>=0 ) return s;
						break;

					case 71 : 
						int LA129_35 = input.LA(1);
						 
						int index129_35 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_35==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 59;}
						else if ( (LA129_35==COLON) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 60;}
						 
						input.seek(index129_35);
						if ( s>=0 ) return s;
						break;

					case 72 : 
						int LA129_132 = input.LA(1);
						 
						int index129_132 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_132==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA129_132==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						 
						input.seek(index129_132);
						if ( s>=0 ) return s;
						break;

					case 73 : 
						int LA129_68 = input.LA(1);
						 
						int index129_68 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						 
						input.seek(index129_68);
						if ( s>=0 ) return s;
						break;

					case 74 : 
						int LA129_75 = input.LA(1);
						 
						int index129_75 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_75==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA129_75==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA129_75==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index129_75);
						if ( s>=0 ) return s;
						break;

					case 75 : 
						int LA129_134 = input.LA(1);
						 
						int index129_134 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_134==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA129_134==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						 
						input.seek(index129_134);
						if ( s>=0 ) return s;
						break;

					case 76 : 
						int LA129_37 = input.LA(1);
						 
						int index129_37 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_37==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 61;}
						else if ( (LA129_37==LSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 62;}
						else if ( (LA129_37==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index129_37);
						if ( s>=0 ) return s;
						break;

					case 77 : 
						int LA129_44 = input.LA(1);
						 
						int index129_44 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_44==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 68;}
						 
						input.seek(index129_44);
						if ( s>=0 ) return s;
						break;

					case 78 : 
						int LA129_145 = input.LA(1);
						 
						int index129_145 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_145==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA129_145==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA129_145==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 163;}
						 
						input.seek(index129_145);
						if ( s>=0 ) return s;
						break;

					case 79 : 
						int LA129_96 = input.LA(1);
						 
						int index129_96 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_96==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 98;}
						else if ( (LA129_96==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index129_96);
						if ( s>=0 ) return s;
						break;

					case 80 : 
						int LA129_9 = input.LA(1);
						 
						int index129_9 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_9==COLON) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 20;}
						 
						input.seek(index129_9);
						if ( s>=0 ) return s;
						break;

					case 81 : 
						int LA129_19 = input.LA(1);
						 
						int index129_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_19==ID) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 40;}
						else if ( (LA129_19==MTIMES) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 41;}
						else if ( (LA129_19==DOTDOT) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 42;}
						else if ( (LA129_19==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 24;}
						 
						input.seek(index129_19);
						if ( s>=0 ) return s;
						break;

					case 82 : 
						int LA129_66 = input.LA(1);
						 
						int index129_66 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_66==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 98;}
						else if ( (LA129_66==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index129_66);
						if ( s>=0 ) return s;
						break;

					case 83 : 
						int LA129_41 = input.LA(1);
						 
						int index129_41 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_41==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 67;}
						else if ( (LA129_41==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index129_41);
						if ( s>=0 ) return s;
						break;

					case 84 : 
						int LA129_76 = input.LA(1);
						 
						int index129_76 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_76==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA129_76==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA129_76==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index129_76);
						if ( s>=0 ) return s;
						break;

					case 85 : 
						int LA129_60 = input.LA(1);
						 
						int index129_60 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_60==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 88;}
						else if ( (LA129_60==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 89;}
						else if ( (LA129_60==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 90;}
						else if ( (LA129_60==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 91;}
						else if ( (LA129_60==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						 
						input.seek(index129_60);
						if ( s>=0 ) return s;
						break;

					case 86 : 
						int LA129_16 = input.LA(1);
						 
						int index129_16 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_16==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 31;}
						else if ( (LA129_16==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 32;}
						else if ( (LA129_16==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 33;}
						else if ( (LA129_16==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 34;}
						else if ( (LA129_16==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						 
						input.seek(index129_16);
						if ( s>=0 ) return s;
						break;

					case 87 : 
						int LA129_74 = input.LA(1);
						 
						int index129_74 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						 
						input.seek(index129_74);
						if ( s>=0 ) return s;
						break;

					case 88 : 
						int LA129_64 = input.LA(1);
						 
						int index129_64 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_64==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						else if ( (LA129_64==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						 
						input.seek(index129_64);
						if ( s>=0 ) return s;
						break;

					case 89 : 
						int LA129_94 = input.LA(1);
						 
						int index129_94 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_94==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						else if ( (LA129_94==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						 
						input.seek(index129_94);
						if ( s>=0 ) return s;
						break;

					case 90 : 
						int LA129_81 = input.LA(1);
						 
						int index129_81 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_81==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						else if ( (LA129_81==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						 
						input.seek(index129_81);
						if ( s>=0 ) return s;
						break;

					case 91 : 
						int LA129_120 = input.LA(1);
						 
						int index129_120 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_120==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						else if ( (LA129_120==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						 
						input.seek(index129_120);
						if ( s>=0 ) return s;
						break;

					case 92 : 
						int LA129_131 = input.LA(1);
						 
						int index129_131 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_131==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						else if ( (LA129_131==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						 
						input.seek(index129_131);
						if ( s>=0 ) return s;
						break;

					case 93 : 
						int LA129_149 = input.LA(1);
						 
						int index129_149 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_149==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						else if ( (LA129_149==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						 
						input.seek(index129_149);
						if ( s>=0 ) return s;
						break;

					case 94 : 
						int LA129_162 = input.LA(1);
						 
						int index129_162 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_162==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						else if ( (LA129_162==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						 
						input.seek(index129_162);
						if ( s>=0 ) return s;
						break;

					case 95 : 
						int LA129_166 = input.LA(1);
						 
						int index129_166 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_166==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						else if ( (LA129_166==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						 
						input.seek(index129_166);
						if ( s>=0 ) return s;
						break;

					case 96 : 
						int LA129_177 = input.LA(1);
						 
						int index129_177 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_177==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						else if ( (LA129_177==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						 
						input.seek(index129_177);
						if ( s>=0 ) return s;
						break;

					case 97 : 
						int LA129_98 = input.LA(1);
						 
						int index129_98 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("op"))) ) {s = 11;}
						 
						input.seek(index129_98);
						if ( s>=0 ) return s;
						break;

					case 98 : 
						int LA129_42 = input.LA(1);
						 
						int index129_42 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_42==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 67;}
						else if ( (LA129_42==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index129_42);
						if ( s>=0 ) return s;
						break;

					case 99 : 
						int LA129_10 = input.LA(1);
						 
						int index129_10 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_10==COLON) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 20;}
						 
						input.seek(index129_10);
						if ( s>=0 ) return s;
						break;

					case 100 : 
						int LA129_141 = input.LA(1);
						 
						int index129_141 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_141==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA129_141==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA129_141==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index129_141);
						if ( s>=0 ) return s;
						break;

					case 101 : 
						int LA129_89 = input.LA(1);
						 
						int index129_89 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_89==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA129_89==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA129_89==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 117;}
						 
						input.seek(index129_89);
						if ( s>=0 ) return s;
						break;

					case 102 : 
						int LA129_109 = input.LA(1);
						 
						int index129_109 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_109==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 139;}
						else if ( (LA129_109==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 140;}
						else if ( (LA129_109==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 141;}
						else if ( (LA129_109==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 142;}
						 
						input.seek(index129_109);
						if ( s>=0 ) return s;
						break;

					case 103 : 
						int LA129_14 = input.LA(1);
						 
						int index129_14 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_14==ID) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 21;}
						else if ( (LA129_14==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 22;}
						else if ( (LA129_14==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 23;}
						else if ( (LA129_14==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 24;}
						 
						input.seek(index129_14);
						if ( s>=0 ) return s;
						break;

					case 104 : 
						int LA129_143 = input.LA(1);
						 
						int index129_143 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_143==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA129_143==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA129_143==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 163;}
						 
						input.seek(index129_143);
						if ( s>=0 ) return s;
						break;

					case 105 : 
						int LA129_100 = input.LA(1);
						 
						int index129_100 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_100==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						else if ( (LA129_100==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						 
						input.seek(index129_100);
						if ( s>=0 ) return s;
						break;

					case 106 : 
						int LA129_126 = input.LA(1);
						 
						int index129_126 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_126==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						else if ( (LA129_126==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						 
						input.seek(index129_126);
						if ( s>=0 ) return s;
						break;

					case 107 : 
						int LA129_85 = input.LA(1);
						 
						int index129_85 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_85==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 111;}
						else if ( (LA129_85==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 114;}
						else if ( (LA129_85==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 115;}
						else if ( (LA129_85==ID) && ((Keyword_IdFollows("annotate")))) {s = 58;}
						 
						input.seek(index129_85);
						if ( s>=0 ) return s;
						break;

					case 108 : 
						int LA129_135 = input.LA(1);
						 
						int index129_135 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_135==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 156;}
						else if ( (LA129_135==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 159;}
						else if ( (LA129_135==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 160;}
						else if ( (LA129_135==ID) && ((Keyword_IdFollows("annotate")))) {s = 58;}
						 
						input.seek(index129_135);
						if ( s>=0 ) return s;
						break;

					case 109 : 
						int LA129_110 = input.LA(1);
						 
						int index129_110 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_110==COLON) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 60;}
						else if ( (LA129_110==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						 
						input.seek(index129_110);
						if ( s>=0 ) return s;
						break;

					case 110 : 
						int LA129_24 = input.LA(1);
						 
						int index129_24 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_24==REAL) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 48;}
						else if ( (LA129_24==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 49;}
						else if ( (LA129_24==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 50;}
						else if ( (LA129_24==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						 
						input.seek(index129_24);
						if ( s>=0 ) return s;
						break;

					case 111 : 
						int LA129_47 = input.LA(1);
						 
						int index129_47 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_47==REAL) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 69;}
						else if ( (LA129_47==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 70;}
						else if ( (LA129_47==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 71;}
						else if ( (LA129_47==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						 
						input.seek(index129_47);
						if ( s>=0 ) return s;
						break;

					case 112 : 
						int LA129_52 = input.LA(1);
						 
						int index129_52 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_52==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 75;}
						else if ( (LA129_52==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 76;}
						else if ( (LA129_52==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 77;}
						else if ( (LA129_52==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 78;}
						 
						input.seek(index129_52);
						if ( s>=0 ) return s;
						break;

					case 113 : 
						int LA129_7 = input.LA(1);
						 
						int index129_7 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_7==COLON) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 17;}
						else if ( (LA129_7==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("istype"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 18;}
						else if ( (LA129_7==LPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 16;}
						 
						input.seek(index129_7);
						if ( s>=0 ) return s;
						break;

					case 114 : 
						int LA129_8 = input.LA(1);
						 
						int index129_8 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_8==COLON) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 19;}
						else if ( (LA129_8==RPAREN) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 15;}
						else if ( (LA129_8==LPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 16;}
						 
						input.seek(index129_8);
						if ( s>=0 ) return s;
						break;

					case 115 : 
						int LA129_116 = input.LA(1);
						 
						int index129_116 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_116==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 143;}
						else if ( (LA129_116==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 144;}
						else if ( (LA129_116==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 145;}
						else if ( (LA129_116==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 146;}
						 
						input.seek(index129_116);
						if ( s>=0 ) return s;
						break;

					case 116 : 
						int LA129_72 = input.LA(1);
						 
						int index129_72 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_72==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 74;}
						 
						input.seek(index129_72);
						if ( s>=0 ) return s;
						break;

					case 117 : 
						int LA129_43 = input.LA(1);
						 
						int index129_43 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_43==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 68;}
						 
						input.seek(index129_43);
						if ( s>=0 ) return s;
						break;

					case 118 : 
						int LA129_36 = input.LA(1);
						 
						int index129_36 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_36==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 61;}
						else if ( (LA129_36==LSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 62;}
						else if ( (LA129_36==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index129_36);
						if ( s>=0 ) return s;
						break;

					case 119 : 
						int LA129_38 = input.LA(1);
						 
						int index129_38 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_38==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 61;}
						else if ( (LA129_38==LSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 62;}
						else if ( (LA129_38==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index129_38);
						if ( s>=0 ) return s;
						break;

					case 120 : 
						int LA129_101 = input.LA(1);
						 
						int index129_101 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_101==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						else if ( (LA129_101==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						 
						input.seek(index129_101);
						if ( s>=0 ) return s;
						break;

					case 121 : 
						int LA129_127 = input.LA(1);
						 
						int index129_127 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_127==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						else if ( (LA129_127==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						 
						input.seek(index129_127);
						if ( s>=0 ) return s;
						break;

					case 122 : 
						int LA129_56 = input.LA(1);
						 
						int index129_56 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_56==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 85;}
						else if ( (LA129_56==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						 
						input.seek(index129_56);
						if ( s>=0 ) return s;
						break;

					case 123 : 
						int LA129_106 = input.LA(1);
						 
						int index129_106 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_106==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 135;}
						else if ( (LA129_106==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						 
						input.seek(index129_106);
						if ( s>=0 ) return s;
						break;

					case 124 : 
						int LA129_51 = input.LA(1);
						 
						int index129_51 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_51==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 74;}
						 
						input.seek(index129_51);
						if ( s>=0 ) return s;
						break;

					case 125 : 
						int LA129_59 = input.LA(1);
						 
						int index129_59 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("call"))) ) {s = 86;}
						else if ( ((Keyword_IdFollows("execution"))) ) {s = 87;}
						else if ( ((Keyword_IdFollows("annotate"))) ) {s = 58;}
						 
						input.seek(index129_59);
						if ( s>=0 ) return s;
						break;

					case 126 : 
						int LA129_23 = input.LA(1);
						 
						int index129_23 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_23==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 46;}
						else if ( (LA129_23==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index129_23);
						if ( s>=0 ) return s;
						break;

					case 127 : 
						int LA129_2 = input.LA(1);
						 
						int index129_2 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_2==AND||(LA129_2 >= COLON && LA129_2 <= COMMA)||(LA129_2 >= END && LA129_2 <= EOL)||LA129_2==OR||LA129_2==RPAREN||LA129_2==SEMICOLON) ) {s = 3;}
						else if ( (LA129_2==LPAREN) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("mainexecution"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("op"))||(Keyword_IdFollows("execution"))||(Keyword_IdFollows("dimension"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("annotate"))))) {s = 4;}
						 
						input.seek(index129_2);
						if ( s>=0 ) return s;
						break;

					case 128 : 
						int LA129_139 = input.LA(1);
						 
						int index129_139 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_139==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA129_139==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA129_139==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index129_139);
						if ( s>=0 ) return s;
						break;

					case 129 : 
						int LA129_114 = input.LA(1);
						 
						int index129_114 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_114==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						else if ( (LA129_114==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 85;}
						 
						input.seek(index129_114);
						if ( s>=0 ) return s;
						break;

					case 130 : 
						int LA129_159 = input.LA(1);
						 
						int index129_159 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_159==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						else if ( (LA129_159==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 135;}
						 
						input.seek(index129_159);
						if ( s>=0 ) return s;
						break;

					case 131 : 
						int LA129_111 = input.LA(1);
						 
						int index129_111 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_111==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 84;}
						else if ( (LA129_111==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 83;}
						 
						input.seek(index129_111);
						if ( s>=0 ) return s;
						break;

					case 132 : 
						int LA129_136 = input.LA(1);
						 
						int index129_136 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_136==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						else if ( (LA129_136==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						 
						input.seek(index129_136);
						if ( s>=0 ) return s;
						break;

					case 133 : 
						int LA129_156 = input.LA(1);
						 
						int index129_156 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_156==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						else if ( (LA129_156==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						 
						input.seek(index129_156);
						if ( s>=0 ) return s;
						break;

					case 134 : 
						int LA129_169 = input.LA(1);
						 
						int index129_169 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_169==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						else if ( (LA129_169==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						 
						input.seek(index129_169);
						if ( s>=0 ) return s;
						break;

					case 135 : 
						int LA129_172 = input.LA(1);
						 
						int index129_172 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_172==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						else if ( (LA129_172==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						 
						input.seek(index129_172);
						if ( s>=0 ) return s;
						break;

					case 136 : 
						int LA129_180 = input.LA(1);
						 
						int index129_180 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_180==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						else if ( (LA129_180==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						 
						input.seek(index129_180);
						if ( s>=0 ) return s;
						break;

					case 137 : 
						int LA129_184 = input.LA(1);
						 
						int index129_184 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_184==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						else if ( (LA129_184==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						 
						input.seek(index129_184);
						if ( s>=0 ) return s;
						break;

					case 138 : 
						int LA129_187 = input.LA(1);
						 
						int index129_187 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_187==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						else if ( (LA129_187==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						 
						input.seek(index129_187);
						if ( s>=0 ) return s;
						break;

					case 139 : 
						int LA129_6 = input.LA(1);
						 
						int index129_6 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_6==COLON) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 14;}
						else if ( (LA129_6==RPAREN) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 15;}
						else if ( (LA129_6==LPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 16;}
						 
						input.seek(index129_6);
						if ( s>=0 ) return s;
						break;

					case 140 : 
						int LA129_45 = input.LA(1);
						 
						int index129_45 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_45==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 68;}
						 
						input.seek(index129_45);
						if ( s>=0 ) return s;
						break;

					case 141 : 
						int LA129_82 = input.LA(1);
						 
						int index129_82 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_82==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA129_82==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						 
						input.seek(index129_82);
						if ( s>=0 ) return s;
						break;

					case 142 : 
						int LA129_57 = input.LA(1);
						 
						int index129_57 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_57==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA129_57==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						 
						input.seek(index129_57);
						if ( s>=0 ) return s;
						break;

					case 143 : 
						int LA129_84 = input.LA(1);
						 
						int index129_84 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_84==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA129_84==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						 
						input.seek(index129_84);
						if ( s>=0 ) return s;
						break;

					case 144 : 
						int LA129_34 = input.LA(1);
						 
						int index129_34 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_34==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 54;}
						else if ( (LA129_34==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 55;}
						else if ( (LA129_34==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 56;}
						else if ( (LA129_34==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						else if ( (LA129_34==ID) && ((Keyword_IdFollows("annotate")))) {s = 58;}
						 
						input.seek(index129_34);
						if ( s>=0 ) return s;
						break;

					case 145 : 
						int LA129_78 = input.LA(1);
						 
						int index129_78 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_78==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 104;}
						else if ( (LA129_78==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 105;}
						else if ( (LA129_78==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 106;}
						else if ( (LA129_78==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						else if ( (LA129_78==ID) && ((Keyword_IdFollows("annotate")))) {s = 58;}
						 
						input.seek(index129_78);
						if ( s>=0 ) return s;
						break;

					case 146 : 
						int LA129_20 = input.LA(1);
						 
						int index129_20 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_20==ID) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 43;}
						else if ( (LA129_20==MTIMES) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 44;}
						else if ( (LA129_20==DOTDOT) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 45;}
						 
						input.seek(index129_20);
						if ( s>=0 ) return s;
						break;

					case 147 : 
						int LA129_157 = input.LA(1);
						 
						int index129_157 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_157==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						else if ( (LA129_157==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						 
						input.seek(index129_157);
						if ( s>=0 ) return s;
						break;

					case 148 : 
						int LA129_73 = input.LA(1);
						 
						int index129_73 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_73==REAL) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 100;}
						else if ( (LA129_73==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 101;}
						else if ( (LA129_73==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 102;}
						 
						input.seek(index129_73);
						if ( s>=0 ) return s;
						break;

					case 149 : 
						int LA129_99 = input.LA(1);
						 
						int index129_99 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_99==REAL) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 126;}
						else if ( (LA129_99==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 127;}
						else if ( (LA129_99==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 128;}
						 
						input.seek(index129_99);
						if ( s>=0 ) return s;
						break;

					case 150 : 
						int LA129_112 = input.LA(1);
						 
						int index129_112 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_112==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 84;}
						else if ( (LA129_112==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 83;}
						 
						input.seek(index129_112);
						if ( s>=0 ) return s;
						break;

					case 151 : 
						int LA129_137 = input.LA(1);
						 
						int index129_137 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_137==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						else if ( (LA129_137==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						 
						input.seek(index129_137);
						if ( s>=0 ) return s;
						break;

					case 152 : 
						int LA129_170 = input.LA(1);
						 
						int index129_170 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_170==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						else if ( (LA129_170==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						 
						input.seek(index129_170);
						if ( s>=0 ) return s;
						break;

					case 153 : 
						int LA129_173 = input.LA(1);
						 
						int index129_173 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_173==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						else if ( (LA129_173==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						 
						input.seek(index129_173);
						if ( s>=0 ) return s;
						break;

					case 154 : 
						int LA129_181 = input.LA(1);
						 
						int index129_181 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_181==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						else if ( (LA129_181==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						 
						input.seek(index129_181);
						if ( s>=0 ) return s;
						break;

					case 155 : 
						int LA129_185 = input.LA(1);
						 
						int index129_185 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_185==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						else if ( (LA129_185==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						 
						input.seek(index129_185);
						if ( s>=0 ) return s;
						break;

					case 156 : 
						int LA129_188 = input.LA(1);
						 
						int index129_188 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_188==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						else if ( (LA129_188==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						 
						input.seek(index129_188);
						if ( s>=0 ) return s;
						break;

					case 157 : 
						int LA129_97 = input.LA(1);
						 
						int index129_97 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_97==REAL) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 123;}
						else if ( (LA129_97==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 124;}
						else if ( (LA129_97==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 125;}
						 
						input.seek(index129_97);
						if ( s>=0 ) return s;
						break;

					case 158 : 
						int LA129_122 = input.LA(1);
						 
						int index129_122 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_122==REAL) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 152;}
						else if ( (LA129_122==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 153;}
						else if ( (LA129_122==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 154;}
						 
						input.seek(index129_122);
						if ( s>=0 ) return s;
						break;

					case 159 : 
						int LA129_46 = input.LA(1);
						 
						int index129_46 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("within"))) ) {s = 12;}
						 
						input.seek(index129_46);
						if ( s>=0 ) return s;
						break;

					case 160 : 
						int LA129_144 = input.LA(1);
						 
						int index129_144 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_144==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA129_144==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA129_144==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 163;}
						 
						input.seek(index129_144);
						if ( s>=0 ) return s;
						break;

					case 161 : 
						int LA129_63 = input.LA(1);
						 
						int index129_63 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_63==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						else if ( (LA129_63==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						 
						input.seek(index129_63);
						if ( s>=0 ) return s;
						break;

					case 162 : 
						int LA129_93 = input.LA(1);
						 
						int index129_93 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_93==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						else if ( (LA129_93==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						 
						input.seek(index129_93);
						if ( s>=0 ) return s;
						break;

					case 163 : 
						int LA129_150 = input.LA(1);
						 
						int index129_150 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_150==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA129_150==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						 
						input.seek(index129_150);
						if ( s>=0 ) return s;
						break;

					case 164 : 
						int LA129_124 = input.LA(1);
						 
						int index129_124 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_124==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						else if ( (LA129_124==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						 
						input.seek(index129_124);
						if ( s>=0 ) return s;
						break;

					case 165 : 
						int LA129_153 = input.LA(1);
						 
						int index129_153 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_153==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						else if ( (LA129_153==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						 
						input.seek(index129_153);
						if ( s>=0 ) return s;
						break;

					case 166 : 
						int LA129_17 = input.LA(1);
						 
						int index129_17 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_17==ID) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 36;}
						else if ( (LA129_17==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 37;}
						else if ( (LA129_17==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 38;}
						else if ( (LA129_17==LSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 39;}
						 
						input.seek(index129_17);
						if ( s>=0 ) return s;
						break;

					case 167 : 
						int LA129_121 = input.LA(1);
						 
						int index129_121 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_121==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA129_121==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						 
						input.seek(index129_121);
						if ( s>=0 ) return s;
						break;

					case 168 : 
						int LA129_65 = input.LA(1);
						 
						int index129_65 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_65==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						else if ( (LA129_65==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						 
						input.seek(index129_65);
						if ( s>=0 ) return s;
						break;

					case 169 : 
						int LA129_95 = input.LA(1);
						 
						int index129_95 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_95==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						else if ( (LA129_95==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						 
						input.seek(index129_95);
						if ( s>=0 ) return s;
						break;

					case 170 : 
						int LA129_40 = input.LA(1);
						 
						int index129_40 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_40==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 67;}
						else if ( (LA129_40==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index129_40);
						if ( s>=0 ) return s;
						break;

					case 171 : 
						int LA129_107 = input.LA(1);
						 
						int index129_107 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_107==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA129_107==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						 
						input.seek(index129_107);
						if ( s>=0 ) return s;
						break;

					case 172 : 
						int LA129_102 = input.LA(1);
						 
						int index129_102 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_102==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						else if ( (LA129_102==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						 
						input.seek(index129_102);
						if ( s>=0 ) return s;
						break;

					case 173 : 
						int LA129_128 = input.LA(1);
						 
						int index129_128 = input.index();
						input.rewind();
						s = -1;
						if ( (LA129_128==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						else if ( (LA129_128==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						 
						input.seek(index129_128);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 129, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	public static final BitSet FOLLOW_scriptFile_in_file391 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_functionFile_in_file402 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_classFile_in_file413 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectFile_in_file424 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_statements_in_scriptFile442 = new BitSet(new long[]{0x0000000000000000L});
	public static final BitSet FOLLOW_EOF_in_scriptFile444 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_statement_in_statements466 = new BitSet(new long[]{0x84C05CAB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_xEOS_in_statements470 = new BitSet(new long[]{0x84C05CAB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_openFunctionFile_in_functionFile495 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_closeFunctionFile_in_functionFile507 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_openFunctionFile527 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_openFunctions_in_openFunctionFile531 = new BitSet(new long[]{0x0000000000000000L});
	public static final BitSet FOLLOW_EOF_in_openFunctionFile533 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_openFunction_in_openFunctions552 = new BitSet(new long[]{0x0000004000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_openFunction570 = new BitSet(new long[]{0x0080040000000000L});
	public static final BitSet FOLLOW_functionSignature_in_openFunction572 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_openBody_in_openFunction574 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_outputPortion_in_functionSignature596 = new BitSet(new long[]{0x0000040100000000L});
	public static final BitSet FOLLOW_functionName_in_functionSignature598 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_functionSignature601 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_functionSignature627 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_functionSignature630 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_output_in_outputPortion656 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_outputPortion658 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_outputVector_in_outputPortion671 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_outputPortion673 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_output694 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_name712 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_outputVector730 = new BitSet(new long[]{0x0000040000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_vectorOutputs_in_outputVector733 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_outputVector737 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_vectorOutput_in_vectorOutputs753 = new BitSet(new long[]{0x0000040000008002L});
	public static final BitSet FOLLOW_COMMA_in_vectorOutputs760 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_vectorOutput_in_vectorOutputs764 = new BitSet(new long[]{0x0000040000008002L});
	public static final BitSet FOLLOW_name_in_vectorOutput782 = new BitSet(new long[]{0x0000000000000082L});
	public static final BitSet FOLLOW_filter_in_vectorOutput788 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_in_filter813 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_classReference_in_filter815 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xFUNCTIONID_in_functionName828 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_inputPortion846 = new BitSet(new long[]{0x8000040000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_parameters_in_inputPortion849 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_inputPortion853 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parameter_in_parameters869 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_parameters872 = new BitSet(new long[]{0x8000040000000000L});
	public static final BitSet FOLLOW_parameter_in_parameters874 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_parameterName_in_parameter892 = new BitSet(new long[]{0x0000000000000082L});
	public static final BitSet FOLLOW_filter_in_parameter898 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xPARAMETERID_in_parameterName923 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xEOS_in_openBody942 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_openItems_in_openBody944 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_openItem_in_openItems963 = new BitSet(new long[]{0x84C05CAB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_xEOS_in_openItems967 = new BitSet(new long[]{0x84C05CAB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statement_in_openItem985 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_closeFunctionFile1001 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_closeFunctions_in_closeFunctionFile1005 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOL_in_closeFunctionFile1008 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOF_in_closeFunctionFile1012 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_closeFunction_in_closeFunctions1030 = new BitSet(new long[]{0x0000004200000002L});
	public static final BitSet FOLLOW_EOL_in_closeFunctions1034 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_closeFunction_in_closeFunctions1038 = new BitSet(new long[]{0x0000004200000002L});
	public static final BitSet FOLLOW_FUNCTION_in_closeFunction1056 = new BitSet(new long[]{0x0080040000000000L});
	public static final BitSet FOLLOW_functionSignature_in_closeFunction1058 = new BitSet(new long[]{0x0000000300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_closeBody_in_closeFunction1060 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_closeFunction1062 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xEOS_in_closeBody1085 = new BitSet(new long[]{0x84C05CEB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_closeItems_in_closeBody1087 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_closeItem_in_closeItems1106 = new BitSet(new long[]{0x84C05CEB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_xEOS_in_closeItems1110 = new BitSet(new long[]{0x84C05CEB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_nestedFunction_in_closeItem1128 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_statement_in_closeItem1146 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_nestedFunction1163 = new BitSet(new long[]{0x0080040000000000L});
	public static final BitSet FOLLOW_functionSignature_in_nestedFunction1165 = new BitSet(new long[]{0x0000000300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_closeBody_in_nestedFunction1167 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_nestedFunction1169 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_classFile1195 = new BitSet(new long[]{0x0000000200002000L});
	public static final BitSet FOLLOW_classDef_in_classFile1199 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_EOL_in_classFile1202 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_closeFunctions_in_classFile1207 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOL_in_classFile1210 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOF_in_classFile1216 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CLASSDEF_in_classDef1239 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_annotationPortion_in_classDef1242 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_name_in_classDef1246 = new BitSet(new long[]{0x0100000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_genealogyPortion_in_classDef1249 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_classDef1253 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_sections_in_classDef1255 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_classDef1257 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_annotationPortion1289 = new BitSet(new long[]{0x8000040000000000L});
	public static final BitSet FOLLOW_attributes_in_annotationPortion1291 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_annotationPortion1293 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_attribute_in_attributes1306 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_attributes1309 = new BitSet(new long[]{0x8000040000000000L});
	public static final BitSet FOLLOW_attribute_in_attributes1311 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_NOT_in_attribute1329 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_name_in_attribute1331 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_attribute1363 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_attribute1401 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_attribute1403 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_attribute1405 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LT_in_genealogyPortion1429 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_baseClasses_in_genealogyPortion1431 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_classReference_in_baseClasses1444 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_AND_in_baseClasses1447 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_classReference_in_baseClasses1449 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_fullClassName_in_classReference1467 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_fullClassName1485 = new BitSet(new long[]{0x0000000008000002L});
	public static final BitSet FOLLOW_DOT_in_fullClassName1491 = new BitSet(new long[]{0x00000CE1C0043C00L,0x00000000A4404038L});
	public static final BitSet FOLLOW_xANYID_in_fullClassName1493 = new BitSet(new long[]{0x0000000008000002L});
	public static final BitSet FOLLOW_section_in_sections1519 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_sections1523 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_eventSection_in_section1541 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_propertySection_in_section1551 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_methodSection_in_section1561 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumerationSection_in_section1571 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xEVENTS_in_eventSection1588 = new BitSet(new long[]{0x0040040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_annotationPortion_in_eventSection1591 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_events_in_eventSection1595 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_eventSection1597 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_event_in_events1624 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_events1628 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_name_in_event1646 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_event1648 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xPROPERTIES_in_propertySection1668 = new BitSet(new long[]{0x0040040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_annotationPortion_in_propertySection1671 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_properties_in_propertySection1675 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_propertySection1677 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_properties1704 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_properties1708 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_name_in_property1726 = new BitSet(new long[]{0x00000000000000C2L});
	public static final BitSet FOLLOW_filter_in_property1729 = new BitSet(new long[]{0x0000000000000042L});
	public static final BitSet FOLLOW_ASSIGN_in_property1734 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_property1736 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xMETHODS_in_methodSection1768 = new BitSet(new long[]{0x00C0044300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_annotationPortion_in_methodSection1771 = new BitSet(new long[]{0x0080044300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_methods_in_methodSection1775 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_methodSection1777 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_method_in_methods1804 = new BitSet(new long[]{0x0080044200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_methods1808 = new BitSet(new long[]{0x0080044200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_regularMethod_in_method1826 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_externalMethod_in_method1838 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_regularMethod1855 = new BitSet(new long[]{0x0080040000000000L});
	public static final BitSet FOLLOW_methodSignature_in_regularMethod1857 = new BitSet(new long[]{0x0000000300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_closeBody_in_regularMethod1859 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_regularMethod1861 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_outputPortion_in_methodSignature1892 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_methodName1_in_methodSignature1896 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_methodSignature1899 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_outputPortion_in_methodSignature1919 = new BitSet(new long[]{0x0000040100000000L});
	public static final BitSet FOLLOW_methodName2_in_methodSignature1921 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_methodSignature1924 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_methodName3_in_methodSignature1944 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_methodSignature1947 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_methodName11971 = new BitSet(new long[]{0x0000000008000000L});
	public static final BitSet FOLLOW_DOT_in_methodName11973 = new BitSet(new long[]{0x0000040100000000L});
	public static final BitSet FOLLOW_xFUNCTIONID_in_methodName11975 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xFUNCTIONID_in_methodName21995 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_methodName32013 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_methodSignature_in_externalMethod2031 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_externalMethod2033 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xENUMERATION_in_enumerationSection2053 = new BitSet(new long[]{0x0040040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_annotationPortion_in_enumerationSection2056 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_enumerations_in_enumerationSection2060 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_enumerationSection2062 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_in_enumerations2089 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_enumerations2093 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_name_in_enumeration2111 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_call_in_enumeration2114 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_call2144 = new BitSet(new long[]{0x84C0540100000080L,0x000000000100A240L});
	public static final BitSet FOLLOW_expressions_in_call2147 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_call2151 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expressions2171 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_expressions2174 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_expressions2176 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_assignment_in_statement2201 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_action_in_statement2224 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simpleCommand_in_statement2241 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_abortCommand_in_statement2258 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_standardCommand_in_statement2270 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_bang_in_statement2282 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_breakDef_in_statement2300 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_continueDef_in_statement2318 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_forDef_in_statement2336 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_global_in_statement2354 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ifDef_in_statement2372 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parfor_in_statement2390 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_persistent_in_statement2408 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_returnDef_in_statement2426 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_spmd_in_statement2438 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_switchDef_in_statement2456 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_tryDef_in_statement2474 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_whileDef_in_statement2492 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assignmentCore_in_assignment2520 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_chain_in_assignmentCore2533 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_assignmentCore2535 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_assignmentCore2537 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_assignmentCore2539 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_storage_in_assignmentCore2561 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_assignmentCore2563 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_assignmentCore2565 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_assignmentCore2567 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_storage2599 = new BitSet(new long[]{0x8000040000008000L,0x0000000000000200L});
	public static final BitSet FOLLOW_COMMA_in_storage2602 = new BitSet(new long[]{0x8000040000000000L,0x0000000000000200L});
	public static final BitSet FOLLOW_slots_in_storage2606 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_COMMA_in_storage2609 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_storage2613 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_slot_in_slots2635 = new BitSet(new long[]{0x8000040000008002L,0x0000000000000200L});
	public static final BitSet FOLLOW_COMMA_in_slots2642 = new BitSet(new long[]{0x8000040000000000L,0x0000000000000200L});
	public static final BitSet FOLLOW_slot_in_slots2646 = new BitSet(new long[]{0x8000040000008002L,0x0000000000000200L});
	public static final BitSet FOLLOW_chain_in_slot2664 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_metaclass_in_slot2674 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOT_in_slot2684 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_action2715 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_action2717 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_simpleCommand2742 = new BitSet(new long[]{0xFF3FBFFDFFF77FF0L,0xFFFFFFFFEFFC73FFL,0x0000003FFFFFFFFFL});
	public static final BitSet FOLLOW_simpleTexts_in_simpleCommand2744 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_simpleCommand2746 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simpleText_in_simpleTexts2773 = new BitSet(new long[]{0xFF3FBFFDFFF77FF2L,0xFFFFFFFFEFFC73FFL,0x0000003FFFFFFFFFL});
	public static final BitSet FOLLOW_simpleText_in_simpleTexts2779 = new BitSet(new long[]{0xFF3FBFFDFFF77FF2L,0xFFFFFFFFEFFC73FFL,0x0000003FFFFFFFFFL});
	public static final BitSet FOLLOW_simpleBlock_in_simpleText2805 = new BitSet(new long[]{0xFF3FBFFDFFF77FF2L,0xFFFFFFFFEFFC73FFL,0x0000003FFFFFFFFFL});
	public static final BitSet FOLLOW_simpleBlock_in_simpleText2824 = new BitSet(new long[]{0xFF3FBFFDFFF77FF2L,0xFFFFFFFFEFFC73FFL,0x0000003FFFFFFFFFL});
	public static final BitSet FOLLOW_STRING_in_simpleBlock2852 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_set_in_simpleBlock2861 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_abortCommand2930 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMAND_in_standardCommand2947 = new BitSet(new long[]{0x0000000000100000L,0x0000000002000000L});
	public static final BitSet FOLLOW_standardTexts_in_standardCommand2949 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_standardCommand2951 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_standardText_in_standardTexts2989 = new BitSet(new long[]{0x0000000000100002L,0x0000000002000000L});
	public static final BitSet FOLLOW_standardText_in_standardTexts2995 = new BitSet(new long[]{0x0000000000100002L,0x0000000002000000L});
	public static final BitSet FOLLOW_standardBlock_in_standardText3021 = new BitSet(new long[]{0x0000000000100002L,0x0000000002000000L});
	public static final BitSet FOLLOW_standardBlock_in_standardText3040 = new BitSet(new long[]{0x0000000000100002L,0x0000000002000000L});
	public static final BitSet FOLLOW_STRINGBLOCK_in_standardBlock3069 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DEFAULTBLOCK_in_standardBlock3078 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXCLAMATION_in_bang3097 = new BitSet(new long[]{0x0002000000000000L});
	public static final BitSet FOLLOW_LINE_in_bang3099 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_xEOL_in_bang3103 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_BREAK_in_breakDef3125 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_breakDef3127 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CONTINUE_in_continueDef3146 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_continueDef3148 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FOR_in_forDef3167 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_forHead_in_forDef3169 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_forDef3171 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_forDef3173 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_forDef3175 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_forHead3199 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_forHead3201 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_forHead3203 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_forHead3215 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_forHead3217 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_forHead3219 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_forHead3221 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_forHead3223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_GLOBAL_in_global3242 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_global3245 = new BitSet(new long[]{0x0000040200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_global3249 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ifPart_in_ifDef3273 = new BitSet(new long[]{0x00000001C0000000L});
	public static final BitSet FOLLOW_elseIfPart_in_ifDef3276 = new BitSet(new long[]{0x00000001C0000000L});
	public static final BitSet FOLLOW_elsePart_in_ifDef3281 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_ifDef3285 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_ifDef3287 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IF_in_ifPart3317 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_ifPart3319 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_ifPart3321 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ELSEIF_in_elseIfPart3343 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_elseIfPart3345 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_elseIfPart3347 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ELSE_in_elsePart3369 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_elsePart3371 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PARFOR_in_parfor3393 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_parforHead_in_parfor3395 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_parfor3397 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_parfor3399 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_parfor3401 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parforHead3438 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_parforHead3440 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_parforHead3442 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parforHead3444 = new BitSet(new long[]{0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_parforHead3446 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parforHead3448 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_parforHead3450 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parforHead3468 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_parforHead3470 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_parforHead3472 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parforHead3474 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_parforHead3476 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_parforHead3491 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_parforHead3493 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parforHead3495 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERSISTENT_in_persistent3517 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_persistent3520 = new BitSet(new long[]{0x0000040200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_persistent3524 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RETURN_in_returnDef3548 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_returnDef3550 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SPMD_in_spmd3569 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_spmdHead_in_spmd3580 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_spmd3584 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_spmd3586 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_spmd3588 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_spmdHead3615 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_spmdHead3617 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_spmdHead3620 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_spmdHead3622 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_spmdHead3626 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_switchPart_in_switchDef3644 = new BitSet(new long[]{0x0000000100000800L,0x0000000000000008L});
	public static final BitSet FOLLOW_casePart_in_switchDef3647 = new BitSet(new long[]{0x0000000100000800L,0x0000000000000008L});
	public static final BitSet FOLLOW_otherwisePart_in_switchDef3652 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_switchDef3656 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_switchDef3658 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SWITCH_in_switchPart3688 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_switchPart3690 = new BitSet(new long[]{0x0000000200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_switchPart3693 = new BitSet(new long[]{0x0000000200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_CASE_in_casePart3712 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_casePart3714 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_casePart3716 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_casePart3718 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OTHERWISE_in_otherwisePart3740 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_otherwisePart3742 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_tryPart_in_tryDef3764 = new BitSet(new long[]{0x0000000100001000L});
	public static final BitSet FOLLOW_catchPart_in_tryDef3767 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_tryDef3771 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_tryDef3773 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TRY_in_tryPart3798 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_tryPart3800 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CATCH_in_catchPart3820 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_capturePortion_in_catchPart3834 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_catchPart3838 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_capturePortion3863 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_capturePortion3865 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WHILE_in_whileDef3880 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_whileDef3882 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_whileDef3884 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_whileDef3886 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_whileDef3888 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression11_in_expression3914 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression10_in_expression113930 = new BitSet(new long[]{0x0000000000000002L,0x0000000000080000L});
	public static final BitSet FOLLOW_SHORTOR_in_expression113947 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression10_in_expression113951 = new BitSet(new long[]{0x0000000000000002L,0x0000000000080000L});
	public static final BitSet FOLLOW_expression09_in_expression103977 = new BitSet(new long[]{0x0000000000000002L,0x0000000000040000L});
	public static final BitSet FOLLOW_SHORTAND_in_expression103994 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression09_in_expression103998 = new BitSet(new long[]{0x0000000000000002L,0x0000000000040000L});
	public static final BitSet FOLLOW_expression08_in_expression094024 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000004L});
	public static final BitSet FOLLOW_OR_in_expression094041 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression08_in_expression094045 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000004L});
	public static final BitSet FOLLOW_expression07_in_expression084071 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_AND_in_expression084088 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression07_in_expression084092 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_expression06_in_expression074118 = new BitSet(new long[]{0x0300030400000002L,0x0000000000000001L});
	public static final BitSet FOLLOW_operator06_in_expression074137 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression06_in_expression074141 = new BitSet(new long[]{0x0300030400000002L,0x0000000000000001L});
	public static final BitSet FOLLOW_LT_in_operator064165 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LTEQ_in_operator064178 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_GT_in_operator064191 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_GTEQ_in_operator064204 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EQ_in_operator064217 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOTEQ_in_operator064230 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression05_in_expression064251 = new BitSet(new long[]{0x0000000000004002L});
	public static final BitSet FOLLOW_COLON_in_expression064280 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression05_in_expression064284 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_expression064286 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression05_in_expression064290 = new BitSet(new long[]{0x0000000000004002L});
	public static final BitSet FOLLOW_COLON_in_expression064318 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression05_in_expression064322 = new BitSet(new long[]{0x0000000000004002L});
	public static final BitSet FOLLOW_expression04_in_expression054349 = new BitSet(new long[]{0x0400000000000002L,0x0000000000000040L});
	public static final BitSet FOLLOW_operator04_in_expression054371 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression04_in_expression054375 = new BitSet(new long[]{0x0400000000000002L,0x0000000000000040L});
	public static final BitSet FOLLOW_PLUS_in_operator044399 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_operator044412 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression03_in_expression044433 = new BitSet(new long[]{0x6800800000000002L,0x0000000008001000L});
	public static final BitSet FOLLOW_operator03_in_expression044452 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression03_in_expression044456 = new BitSet(new long[]{0x6800800000000002L,0x0000000008001000L});
	public static final BitSet FOLLOW_TIMES_in_operator034480 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RDIV_in_operator034493 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LDIV_in_operator034506 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MTIMES_in_operator034519 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MRDIV_in_operator034532 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MLDIV_in_operator034545 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_operator02_in_expression034565 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression03_in_expression034569 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression02_in_expression034589 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_operator024607 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_operator024621 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOT_in_operator024635 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression00_in_expression024656 = new BitSet(new long[]{0x1000000000080002L,0x0000000010000100L});
	public static final BitSet FOLLOW_operator01_in_expression024691 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression01_in_expression024695 = new BitSet(new long[]{0x1000000000080002L,0x0000000010000100L});
	public static final BitSet FOLLOW_TRANS_in_expression024720 = new BitSet(new long[]{0x1000000000080002L,0x0000000010000100L});
	public static final BitSet FOLLOW_CTRANS_in_expression024741 = new BitSet(new long[]{0x1000000000080002L,0x0000000010000100L});
	public static final BitSet FOLLOW_POW_in_operator014769 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MPOW_in_operator014782 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_operator02_in_expression014802 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression01_in_expression014806 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression00_in_expression014826 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_atom_in_expression004844 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_chain_in_atom4859 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_real_in_atom4872 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_imaginary_in_atom4882 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_stringDef_in_atom4892 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_regularArray_in_atom4902 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cellArray_in_atom4912 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_in_atom4922 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_end_in_atom4932 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_functionHandle_in_atom4942 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_anonymousFunction_in_atom4952 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_metaclass_in_atom4962 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_chain4987 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_dotExpressionOperator_in_chain5008 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_dotNameOperator_in_chain5029 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_parenthesisOperator_in_chain5050 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_curlyBraceOperator_in_chain5074 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_atBaseOperator_in_chain5095 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_name_in_var5124 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOT_in_dotExpressionOperator5150 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_dotExpressionOperator5152 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_dotExpressionOperator5154 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_dotExpressionOperator5156 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOT_in_dotNameOperator5176 = new BitSet(new long[]{0x00000CE1C0043C00L,0x00000000A4404038L});
	public static final BitSet FOLLOW_anyName_in_dotNameOperator5178 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xANYID_in_anyName5195 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesisOperator5224 = new BitSet(new long[]{0x84C0540100004080L,0x000000000100A240L});
	public static final BitSet FOLLOW_arguments_in_parenthesisOperator5227 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesisOperator5231 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_argument_in_arguments5251 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_arguments5254 = new BitSet(new long[]{0x84C0540100004080L,0x0000000001002240L});
	public static final BitSet FOLLOW_argument_in_arguments5256 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_expression_in_argument5274 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COLON_in_argument5285 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LCURLY_in_curlyBraceOperator5313 = new BitSet(new long[]{0x84C0540100004080L,0x0000000001002240L});
	public static final BitSet FOLLOW_arguments_in_curlyBraceOperator5315 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_RCURLY_in_curlyBraceOperator5317 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_in_atBaseOperator5340 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_classReference_in_atBaseOperator5342 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REAL_in_real5361 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IMAGINARY_in_imaginary5376 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_STRING_in_stringDef5391 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_regularArray5413 = new BitSet(new long[]{0x84C0540300008080L,0x0000000001022240L});
	public static final BitSet FOLLOW_rows_in_regularArray5415 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_regularArray5417 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_row_in_rows5444 = new BitSet(new long[]{0x0000000200000002L,0x0000000000020000L});
	public static final BitSet FOLLOW_SEMICOLON_in_rows5448 = new BitSet(new long[]{0x84C0540300008080L,0x0000000001022240L});
	public static final BitSet FOLLOW_EOL_in_rows5452 = new BitSet(new long[]{0x84C0540300008080L,0x0000000001022240L});
	public static final BitSet FOLLOW_row_in_rows5455 = new BitSet(new long[]{0x0000000200000002L,0x0000000000020000L});
	public static final BitSet FOLLOW_COMMA_in_row5474 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_columns_in_row5478 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_row5481 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_row5497 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_column_in_columns5523 = new BitSet(new long[]{0x84C0540100008082L,0x0000000001002240L});
	public static final BitSet FOLLOW_COMMA_in_columns5530 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_column_in_columns5534 = new BitSet(new long[]{0x84C0540100008082L,0x0000000001002240L});
	public static final BitSet FOLLOW_NOT_in_column5573 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_column5596 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LCURLY_in_cellArray5620 = new BitSet(new long[]{0x84C0540300008080L,0x0000000001022240L});
	public static final BitSet FOLLOW_rows_in_cellArray5622 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_RCURLY_in_cellArray5624 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized5658 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parenthesized5660 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized5662 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_END_in_end5684 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_in_functionHandle5699 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_functionReference_in_functionHandle5701 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_fullFunctioName_in_functionReference5719 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_fullFunctioName5737 = new BitSet(new long[]{0x0000000008000002L});
	public static final BitSet FOLLOW_DOT_in_fullFunctioName5740 = new BitSet(new long[]{0x00000CE1C0043C00L,0x00000000A4404038L});
	public static final BitSet FOLLOW_xANYID_in_fullFunctioName5742 = new BitSet(new long[]{0x0000000008000002L});
	public static final BitSet FOLLOW_AT_in_anonymousFunction5769 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_inputPortion_in_anonymousFunction5771 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_anonymousFunction5773 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_QUESTION_in_metaclass5798 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_classReference_in_metaclass5800 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SEMICOLON_in_xEOS5819 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_xEOS5830 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_xEOS5841 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_xEOL5857 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xID5871 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xANYID5884 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_BREAK_in_xANYID5896 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CASE_in_xANYID5909 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CATCH_in_xANYID5922 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CLASSDEF_in_xANYID5935 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CONTINUE_in_xANYID5948 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ELSE_in_xANYID5961 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ELSEIF_in_xANYID5974 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_END_in_xANYID5987 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FOR_in_xANYID6000 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_xANYID6013 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_GLOBAL_in_xANYID6026 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IF_in_xANYID6039 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OTHERWISE_in_xANYID6052 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PARFOR_in_xANYID6065 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERSISTENT_in_xANYID6078 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RETURN_in_xANYID6091 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SPMD_in_xANYID6104 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SWITCH_in_xANYID6117 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TRY_in_xANYID6130 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WHILE_in_xANYID6143 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xFUNCTIONID6161 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_END_in_xFUNCTIONID6172 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xPARAMETERID6189 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOT_in_xPARAMETERID6201 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xEVENTS6222 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xPROPERTIES6238 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xMETHODS6254 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xENUMERATION6270 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_aspectFile6286 = new BitSet(new long[]{0x0000000200000020L});
	public static final BitSet FOLLOW_aspectDef_in_aspectFile6290 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOL_in_aspectFile6293 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOF_in_aspectFile6297 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASPECT_in_aspectDef6315 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_name_in_aspectDef6317 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectDef6319 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectSections_in_aspectDef6321 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_aspectDef6323 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectSection_in_aspectSections6346 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectSections6350 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_eventSection_in_aspectSection6368 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_propertySection_in_aspectSection6381 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_methodSection_in_aspectSection6397 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumerationSection_in_aspectSection6413 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectPatternSection_in_aspectSection6426 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectActionSection_in_aspectSection6439 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wACTIONS_in_aspectActionSection6462 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectActions_in_aspectActionSection6464 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_aspectActionSection6466 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectAction_in_aspectActions6488 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectActions6492 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectActionSignature_in_aspectAction6510 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectActionBody_in_aspectAction6512 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_aspectAction6514 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_aspectActionSignature6535 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectActionSignature6537 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_aspectActionType_in_aspectActionSignature6539 = new BitSet(new long[]{0x8040040000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectActionSignature6542 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression_in_aspectActionSignature6546 = new BitSet(new long[]{0x0000000000004002L});
	public static final BitSet FOLLOW_COLON_in_aspectActionSignature6549 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_inputPortion_in_aspectActionSignature6551 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wBEFORE_in_aspectActionType6575 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wAFTER_in_aspectActionType6600 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wAROUND_in_aspectActionType6613 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_closeBody_in_aspectActionBody6631 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wPATTERNS_in_aspectPatternSection6649 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectPatterns_in_aspectPatternSection6651 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_aspectPatternSection6653 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectPattern_in_aspectPatterns6675 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectPatterns6679 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_name_in_aspectPattern6697 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectPattern6699 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression_in_aspectPattern6701 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectPattern6703 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectExpression04_in_aspectExpression6722 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectExpression03_in_aspectExpression046738 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000004L});
	public static final BitSet FOLLOW_OR_in_aspectExpression046755 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression03_in_aspectExpression046759 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000004L});
	public static final BitSet FOLLOW_aspectExpression02_in_aspectExpression036785 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_AND_in_aspectExpression036802 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression02_in_aspectExpression036806 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_NOT_in_aspectExpression026829 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression02_in_aspectExpression026833 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectExpression01_in_aspectExpression026858 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectAtom_in_aspectExpression016882 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectParenthesis_in_aspectAtom6895 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectName_in_aspectAtom6914 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectGet_in_aspectAtom6933 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectSet_in_aspectAtom6952 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectCall_in_aspectAtom6971 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectExecution_in_aspectAtom6990 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectMainExecution_in_aspectAtom7009 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectLoop_in_aspectAtom7028 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectLoopHead_in_aspectAtom7047 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectLoopBody_in_aspectAtom7066 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectAnnotate_in_aspectAtom7085 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectOperator_in_aspectAtom7104 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectWithin_in_aspectAtom7123 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectDimension_in_aspectAtom7142 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectIsType_in_aspectAtom7161 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_aspectParenthesis7185 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression_in_aspectParenthesis7187 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectParenthesis7189 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_aspectName7202 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wID_in_aspectIdentifier7220 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectIdentifier7245 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectIdentifier7270 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wID_in_aspectTypeSignature7300 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectTypeSignature7332 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectTypeSignature7364 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wREAL_in_aspectPartSignature7401 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectPartSignature7429 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectPartSignature7457 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_aspectDimensionSignature7490 = new BitSet(new long[]{0x4000000010000000L,0x0000000000012000L});
	public static final BitSet FOLLOW_aspectPartSignature_in_aspectDimensionSignature7493 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_COMMA_in_aspectDimensionSignature7496 = new BitSet(new long[]{0x4000000010000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_aspectPartSignature_in_aspectDimensionSignature7498 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_aspectDimensionSignature7504 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectTypeSignature_in_aspectFullSignature7524 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectTypeSignature_in_aspectFullSignature7556 = new BitSet(new long[]{0x0080000000000000L});
	public static final BitSet FOLLOW_aspectDimensionSignature_in_aspectFullSignature7558 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectDimensionSignature_in_aspectFullSignature7593 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wGET_in_aspectGet7631 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectGet7633 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectGet7635 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectGet7638 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectGet7640 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectGet7644 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSET_in_aspectSet7666 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectSet7668 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectSet7670 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectSet7673 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectSet7675 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectSet7679 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectInput7702 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_aspectInput7705 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectInput7707 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectOutput7728 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_aspectOutput7731 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectOutput7733 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_wCALL_in_aspectCall7754 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectCall7756 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectCall7758 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectCall7760 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectInput_in_aspectCall7762 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectCall7764 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectCall7767 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectOutput_in_aspectCall7769 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectCall7773 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wEXECUTION_in_aspectExecution7808 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectExecution7810 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectExecution7812 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectExecution7814 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectInput_in_aspectExecution7816 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectExecution7818 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectExecution7821 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectOutput_in_aspectExecution7823 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectExecution7827 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMAINEXECUTION_in_aspectMainExecution7862 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectMainExecution7864 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectMainExecution7866 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wFOR_in_aspectLoopType7879 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wWHILE_in_aspectLoopType7902 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectLoopType7925 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectLoopType7948 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLOOP_in_aspectLoop7976 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectLoop7978 = new BitSet(new long[]{0x4000042010000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_aspectLoopType_in_aspectLoop7981 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectLoop7983 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectLoop7987 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectLoop7989 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLOOPBODY_in_aspectLoopBody8010 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectLoopBody8012 = new BitSet(new long[]{0x4000042010000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_aspectLoopType_in_aspectLoopBody8015 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectLoopBody8017 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectLoopBody8021 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectLoopBody8023 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLOOPHEAD_in_aspectLoopHead8044 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectLoopHead8046 = new BitSet(new long[]{0x4000042010000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_aspectLoopType_in_aspectLoopHead8049 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectLoopHead8051 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectLoopHead8055 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectLoopHead8057 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wVAR_in_aspectPartSelector8078 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTR_in_aspectPartSelector8105 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wNUM_in_aspectPartSelector8132 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectPartSelector8159 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectPartSelector8186 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectPartSelector_in_aspectSimpleSelector8218 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_aspectCompoundSelector8235 = new BitSet(new long[]{0x4000040010000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_aspectPartSelector_in_aspectCompoundSelector8238 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_COMMA_in_aspectCompoundSelector8241 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectPartSelector_in_aspectCompoundSelector8243 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_aspectCompoundSelector8249 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectSimpleSelector_in_aspectSelector8268 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectCompoundSelector_in_aspectSelector8291 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wANNOTATE_in_aspectAnnotate8319 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectAnnotate8321 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectAnnotate8323 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectAnnotate8325 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectSelector_in_aspectAnnotate8328 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_aspectAnnotate8331 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectSelector_in_aspectAnnotate8333 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectAnnotate8339 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectAnnotate8341 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wPLUS_in_aspectOperatorType8363 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMINUS_in_aspectOperatorType8390 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMTIMES_in_aspectOperatorType8417 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wTIMES_in_aspectOperatorType8444 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMRDIV_in_aspectOperatorType8471 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wRDIV_in_aspectOperatorType8498 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMLDIV_in_aspectOperatorType8525 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLDIV_in_aspectOperatorType8552 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMPOW_in_aspectOperatorType8579 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wPOW_in_aspectOperatorType8606 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wCTRANS_in_aspectOperatorType8633 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wTRANS_in_aspectOperatorType8660 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wOPERATOR_in_aspectOperator8692 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectOperator8694 = new BitSet(new long[]{0x7C00800000080000L,0x0000000018001140L});
	public static final BitSet FOLLOW_aspectOperatorType_in_aspectOperator8696 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectOperator8699 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectOperator8701 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_aspectOperator8704 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectOperator8706 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectOperator8712 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wWITHIN_in_aspectWithin8734 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectWithin8736 = new BitSet(new long[]{0x4000044010000000L});
	public static final BitSet FOLLOW_aspectScopeType_in_aspectWithin8738 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectWithin8740 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectWithin8742 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectWithin8744 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wFUNCTION_in_aspectScopeType8763 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSCRIPT_in_aspectScopeType8787 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wCLASS_in_aspectScopeType8811 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wASPECT_in_aspectScopeType8835 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLOOP_in_aspectScopeType8859 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectScopeType8883 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectScopeType8907 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDIMENSION_in_aspectDimension8936 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectDimension8938 = new BitSet(new long[]{0x0080000000000000L});
	public static final BitSet FOLLOW_aspectDimensionSignature_in_aspectDimension8940 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectDimension8942 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wISTYPE_in_aspectIsType8958 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectIsType8960 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectTypeSignature_in_aspectIsType8962 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectIsType8964 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wID8983 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REAL_in_wREAL9001 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wASPECT9023 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wACTIONS9044 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wPATTERNS9065 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wBEFORE9086 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wAFTER9107 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wAROUND9128 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wGET9149 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wSET9170 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wCALL9191 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wEXECUTION9212 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wMAINEXECUTION9233 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wLOOP9254 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wLOOPBODY9275 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wLOOPHEAD9296 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wANNOTATE9317 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wOPERATOR9338 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wWITHIN9359 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wDIMENSION9380 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wISTYPE9401 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MTIMES_in_wSTAR9419 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_wFUNCTION9438 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wSCRIPT9460 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wLOOPS9481 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wCLASS9502 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOTDOT_in_wDOTDOT9520 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FOR_in_wFOR9539 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WHILE_in_wWHILE9559 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_wPLUS9579 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_wMINUS9598 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MTIMES_in_wMTIMES9617 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TIMES_in_wTIMES9636 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MRDIV_in_wMRDIV9655 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RDIV_in_wRDIV9674 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MLDIV_in_wMLDIV9693 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LDIV_in_wLDIV9712 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MPOW_in_wMPOW9731 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_POW_in_wPOW9750 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TRANS_in_wTRANS9769 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CTRANS_in_wCTRANS9788 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wVAR9810 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wSTR9831 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wNUM9852 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_openFunctionFile_in_synpred1_MatlabParser491 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assignment_in_synpred2_MatlabParser2197 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_action_in_synpred3_MatlabParser2220 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simpleCommand_in_synpred4_MatlabParser2237 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_abortCommand_in_synpred5_MatlabParser2254 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred6_MatlabParser3426 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_synpred6_MatlabParser3428 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_synpred6_MatlabParser3430 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_synpred6_MatlabParser3432 = new BitSet(new long[]{0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_synpred6_MatlabParser3434 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COLON_in_synpred7_MatlabParser4270 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression05_in_synpred7_MatlabParser4272 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_synpred7_MatlabParser4274 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression05_in_synpred7_MatlabParser4276 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COLON_in_synpred8_MatlabParser4312 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression05_in_synpred8_MatlabParser4314 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOT_in_synpred9_MatlabParser5000 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_synpred9_MatlabParser5002 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOT_in_synpred10_MatlabParser5553 = new BitSet(new long[]{0x0000000200008000L,0x0000000000030000L});
	public static final BitSet FOLLOW_set_in_synpred10_MatlabParser5555 = new BitSet(new long[]{0x0000000000000002L});
}
