// $ANTLR 3.5.2 D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3 2016-07-04 16:34:33

package Matlab.Recognizer;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


@SuppressWarnings("all")
public class MatlabParser extends MatlabParserBase {
	public static final String[] tokenNames = new String[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASPECT", "ASSIGN", "AT", 
		"BANG_MODE", "BLOCKCOMMENT", "BREAK", "CASE", "CATCH", "CLASSDEF", "COLON", 
		"COMMA", "COMMAND", "COMMAND_MODE", "CONTINUE", "CTRANS", "DEFAULTBLOCK", 
		"DEFAULTBLOCK1", "DEFAULTBLOCK2", "DEFAULTBLOCK3", "DEFAULTBLOCK4", "DEFAULT_MODE", 
		"DIGIT", "DOT", "DOTDOT", "ELLIPSIS", "ELSE", "ELSEIF", "END", "EOL", 
		"EQ", "EXCLAMATION", "EXP", "FOR", "FUNCTION", "GLOBAL", "GT", "GTEQ", 
		"ID", "IF", "IMAGINARY", "IMG", "LCURLY", "LDIV", "LETTER", "LINE", "LINECOMMENT", 
		"LINECOMMENT1", "LINECOMMENT2", "LINECOMMENT3", "LPAREN", "LSQUARE", "LT", 
		"LTEQ", "MINUS", "MLDIV", "MPOW", "MRDIV", "MTIMES", "NOT", "NOTEQ", "NUMBER", 
		"OR", "OTHERWISE", "PARFOR", "PERSISTENT", "PLUS", "POINT", "POW", "QUESTION", 
		"QUOTATION", "RCURLY", "RDIV", "REAL", "RETURN", "RPAREN", "RSQUARE", 
		"SEMICOLON", "SHORTAND", "SHORTOR", "SIGN", "SPACES", "SPMD", "START", 
		"STRING", "STRINGBLOCK", "SWITCH", "TIMES", "TRANS", "TRY", "UNKNOWN", 
		"WHILE", "WS", "ABORT", "ACTION", "ALL", "ANONYMOUSFUNCTION", "ASPECTACTION", 
		"ASPECTACTIONSECTION", "ASPECTANNOTATE", "ASPECTCALL", "ASPECTDEF", "ASPECTDIMENSION", 
		"ASPECTDIMENSIONSIGNATURE", "ASPECTEXECUTION", "ASPECTFILE", "ASPECTFULLSIGNATURE", 
		"ASPECTGET", "ASPECTINPUT", "ASPECTISTYPE", "ASPECTLOOP", "ASPECTLOOPBODY", 
		"ASPECTLOOPHEAD", "ASPECTMAINEXECUTION", "ASPECTNAME", "ASPECTOPERATOR", 
		"ASPECTOUTPUT", "ASPECTPATTERN", "ASPECTPATTERNSECTION", "ASPECTSELECTOR", 
		"ASPECTSET", "ASPECTTYPESIGNATURE", "ASPECTWITHIN", "ATBASE", "ATTRIBUTE", 
		"CELLARRAY", "CLASSFILE", "CLASSREF", "CURLYBRACE", "DOTEXPRESSION", "DOTNAME", 
		"ENUMERATION", "ENUMERATIONSECTION", "EVENT", "EVENTSECTION", "EXTERNALMETHOD", 
		"FUNCTIONFILE", "FUNCTIONHANDLE", "FUNCTIONREF", "HCAT", "IFELSE", "INPUT", 
		"METHODSECTION", "NAME", "NEGATIVE", "NESTEDFUNCTION", "NOPRINT", "OUTPUT", 
		"PARENTHESIS", "POSITIVE", "PRINT", "PROPERTY", "PROPERTYSECTION", "REGULARARRAY", 
		"REGULARMETHOD", "SCRIPTFILE", "STORAGE", "SWITCHCASE", "TRYCATCH", "VAR", 
		"VCAT"
	};
	public static final int EOF=-1;
	public static final int AND=4;
	public static final int ASPECT=5;
	public static final int ASSIGN=6;
	public static final int AT=7;
	public static final int BANG_MODE=8;
	public static final int BLOCKCOMMENT=9;
	public static final int BREAK=10;
	public static final int CASE=11;
	public static final int CATCH=12;
	public static final int CLASSDEF=13;
	public static final int COLON=14;
	public static final int COMMA=15;
	public static final int COMMAND=16;
	public static final int COMMAND_MODE=17;
	public static final int CONTINUE=18;
	public static final int CTRANS=19;
	public static final int DEFAULTBLOCK=20;
	public static final int DEFAULTBLOCK1=21;
	public static final int DEFAULTBLOCK2=22;
	public static final int DEFAULTBLOCK3=23;
	public static final int DEFAULTBLOCK4=24;
	public static final int DEFAULT_MODE=25;
	public static final int DIGIT=26;
	public static final int DOT=27;
	public static final int DOTDOT=28;
	public static final int ELLIPSIS=29;
	public static final int ELSE=30;
	public static final int ELSEIF=31;
	public static final int END=32;
	public static final int EOL=33;
	public static final int EQ=34;
	public static final int EXCLAMATION=35;
	public static final int EXP=36;
	public static final int FOR=37;
	public static final int FUNCTION=38;
	public static final int GLOBAL=39;
	public static final int GT=40;
	public static final int GTEQ=41;
	public static final int ID=42;
	public static final int IF=43;
	public static final int IMAGINARY=44;
	public static final int IMG=45;
	public static final int LCURLY=46;
	public static final int LDIV=47;
	public static final int LETTER=48;
	public static final int LINE=49;
	public static final int LINECOMMENT=50;
	public static final int LINECOMMENT1=51;
	public static final int LINECOMMENT2=52;
	public static final int LINECOMMENT3=53;
	public static final int LPAREN=54;
	public static final int LSQUARE=55;
	public static final int LT=56;
	public static final int LTEQ=57;
	public static final int MINUS=58;
	public static final int MLDIV=59;
	public static final int MPOW=60;
	public static final int MRDIV=61;
	public static final int MTIMES=62;
	public static final int NOT=63;
	public static final int NOTEQ=64;
	public static final int NUMBER=65;
	public static final int OR=66;
	public static final int OTHERWISE=67;
	public static final int PARFOR=68;
	public static final int PERSISTENT=69;
	public static final int PLUS=70;
	public static final int POINT=71;
	public static final int POW=72;
	public static final int QUESTION=73;
	public static final int QUOTATION=74;
	public static final int RCURLY=75;
	public static final int RDIV=76;
	public static final int REAL=77;
	public static final int RETURN=78;
	public static final int RPAREN=79;
	public static final int RSQUARE=80;
	public static final int SEMICOLON=81;
	public static final int SHORTAND=82;
	public static final int SHORTOR=83;
	public static final int SIGN=84;
	public static final int SPACES=85;
	public static final int SPMD=86;
	public static final int START=87;
	public static final int STRING=88;
	public static final int STRINGBLOCK=89;
	public static final int SWITCH=90;
	public static final int TIMES=91;
	public static final int TRANS=92;
	public static final int TRY=93;
	public static final int UNKNOWN=94;
	public static final int WHILE=95;
	public static final int WS=96;
	public static final int ABORT=97;
	public static final int ACTION=98;
	public static final int ALL=99;
	public static final int ANONYMOUSFUNCTION=100;
	public static final int ASPECTACTION=101;
	public static final int ASPECTACTIONSECTION=102;
	public static final int ASPECTANNOTATE=103;
	public static final int ASPECTCALL=104;
	public static final int ASPECTDEF=105;
	public static final int ASPECTDIMENSION=106;
	public static final int ASPECTDIMENSIONSIGNATURE=107;
	public static final int ASPECTEXECUTION=108;
	public static final int ASPECTFILE=109;
	public static final int ASPECTFULLSIGNATURE=110;
	public static final int ASPECTGET=111;
	public static final int ASPECTINPUT=112;
	public static final int ASPECTISTYPE=113;
	public static final int ASPECTLOOP=114;
	public static final int ASPECTLOOPBODY=115;
	public static final int ASPECTLOOPHEAD=116;
	public static final int ASPECTMAINEXECUTION=117;
	public static final int ASPECTNAME=118;
	public static final int ASPECTOPERATOR=119;
	public static final int ASPECTOUTPUT=120;
	public static final int ASPECTPATTERN=121;
	public static final int ASPECTPATTERNSECTION=122;
	public static final int ASPECTSELECTOR=123;
	public static final int ASPECTSET=124;
	public static final int ASPECTTYPESIGNATURE=125;
	public static final int ASPECTWITHIN=126;
	public static final int ATBASE=127;
	public static final int ATTRIBUTE=128;
	public static final int CELLARRAY=129;
	public static final int CLASSFILE=130;
	public static final int CLASSREF=131;
	public static final int CURLYBRACE=132;
	public static final int DOTEXPRESSION=133;
	public static final int DOTNAME=134;
	public static final int ENUMERATION=135;
	public static final int ENUMERATIONSECTION=136;
	public static final int EVENT=137;
	public static final int EVENTSECTION=138;
	public static final int EXTERNALMETHOD=139;
	public static final int FUNCTIONFILE=140;
	public static final int FUNCTIONHANDLE=141;
	public static final int FUNCTIONREF=142;
	public static final int HCAT=143;
	public static final int IFELSE=144;
	public static final int INPUT=145;
	public static final int METHODSECTION=146;
	public static final int NAME=147;
	public static final int NEGATIVE=148;
	public static final int NESTEDFUNCTION=149;
	public static final int NOPRINT=150;
	public static final int OUTPUT=151;
	public static final int PARENTHESIS=152;
	public static final int POSITIVE=153;
	public static final int PRINT=154;
	public static final int PROPERTY=155;
	public static final int PROPERTYSECTION=156;
	public static final int REGULARARRAY=157;
	public static final int REGULARMETHOD=158;
	public static final int SCRIPTFILE=159;
	public static final int STORAGE=160;
	public static final int SWITCHCASE=161;
	public static final int TRYCATCH=162;
	public static final int VAR=163;
	public static final int VCAT=164;

	// delegates
	public MatlabParserBase[] getDelegates() {
		return new MatlabParserBase[] {};
	}

	// delegators


	public MatlabParser(TokenStream input) {
		this(input, new RecognizerSharedState());
	}
	public MatlabParser(TokenStream input, RecognizerSharedState state) {
		super(input, state);
	}

	protected TreeAdaptor adaptor = new CommonTreeAdaptor();

	public void setTreeAdaptor(TreeAdaptor adaptor) {
		this.adaptor = adaptor;
	}
	public TreeAdaptor getTreeAdaptor() {
		return adaptor;
	}
	@Override public String[] getTokenNames() { return MatlabParser.tokenNames; }
	@Override public String getGrammarFileName() { return "D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3"; }


	public static class file_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "file"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:57:8: public file : ( scriptFile -> scriptFile | functionFile -> functionFile | classFile -> classFile | aspectFile -> aspectFile );
	public final MatlabParser.file_return file() throws RecognitionException {
		MatlabParser.file_return retval = new MatlabParser.file_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope scriptFile1 =null;
		ParserRuleReturnScope functionFile2 =null;
		ParserRuleReturnScope classFile3 =null;
		ParserRuleReturnScope aspectFile4 =null;

		RewriteRuleSubtreeStream stream_classFile=new RewriteRuleSubtreeStream(adaptor,"rule classFile");
		RewriteRuleSubtreeStream stream_functionFile=new RewriteRuleSubtreeStream(adaptor,"rule functionFile");
		RewriteRuleSubtreeStream stream_aspectFile=new RewriteRuleSubtreeStream(adaptor,"rule aspectFile");
		RewriteRuleSubtreeStream stream_scriptFile=new RewriteRuleSubtreeStream(adaptor,"rule scriptFile");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:57:13: ( scriptFile -> scriptFile | functionFile -> functionFile | classFile -> classFile | aspectFile -> aspectFile )
			int alt1=4;
			alt1 = dfa1.predict(input);
			switch (alt1) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:57:15: scriptFile
					{
					pushFollow(FOLLOW_scriptFile_in_file387);
					scriptFile1=scriptFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_scriptFile.add(scriptFile1.getTree());
					// AST REWRITE
					// elements: scriptFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 57:26: -> scriptFile
					{
						adaptor.addChild(root_0, stream_scriptFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:58:6: functionFile
					{
					pushFollow(FOLLOW_functionFile_in_file398);
					functionFile2=functionFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_functionFile.add(functionFile2.getTree());
					// AST REWRITE
					// elements: functionFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 58:19: -> functionFile
					{
						adaptor.addChild(root_0, stream_functionFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:59:6: classFile
					{
					pushFollow(FOLLOW_classFile_in_file409);
					classFile3=classFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_classFile.add(classFile3.getTree());
					// AST REWRITE
					// elements: classFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 59:16: -> classFile
					{
						adaptor.addChild(root_0, stream_classFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:60:6: aspectFile
					{
					pushFollow(FOLLOW_aspectFile_in_file420);
					aspectFile4=aspectFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFile.add(aspectFile4.getTree());
					// AST REWRITE
					// elements: aspectFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 60:17: -> aspectFile
					{
						adaptor.addChild(root_0, stream_aspectFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "file"


	public static class scriptFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "scriptFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:1: scriptFile : statements EOF -> ^( SCRIPTFILE[\"\"] ( statements )? ) ;
	public final MatlabParser.scriptFile_return scriptFile() throws RecognitionException {
		MatlabParser.scriptFile_return retval = new MatlabParser.scriptFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOF6=null;
		ParserRuleReturnScope statements5 =null;

		Object EOF6_tree=null;
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:12: ( statements EOF -> ^( SCRIPTFILE[\"\"] ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:14: statements EOF
			{
			pushFollow(FOLLOW_statements_in_scriptFile438);
			statements5=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements5.getTree());
			EOF6=(Token)match(input,EOF,FOLLOW_EOF_in_scriptFile440); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF6);

			// AST REWRITE
			// elements: statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 65:29: -> ^( SCRIPTFILE[\"\"] ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:32: ^( SCRIPTFILE[\"\"] ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SCRIPTFILE, ""), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:65:49: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "scriptFile"


	public static class statements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "statements"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:1: statements : ( statement | xEOS )* -> ( statement )* ;
	public final MatlabParser.statements_return statements() throws RecognitionException {
		MatlabParser.statements_return retval = new MatlabParser.statements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope statement7 =null;
		ParserRuleReturnScope xEOS8 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:12: ( ( statement | xEOS )* -> ( statement )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:14: ( statement | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:14: ( statement | xEOS )*
			loop2:
			while (true) {
				int alt2=3;
				int LA2_0 = input.LA(1);
				if ( (LA2_0==END) ) {
					int LA2_2 = input.LA(2);
					if ( (LA2_2==SEMICOLON) ) {
						int LA2_7 = input.LA(3);
						if ( (((Index_IsActive())&&(True()))) ) {
							alt2=1;
						}

					}
					else if ( (LA2_2==COMMA) ) {
						int LA2_8 = input.LA(3);
						if ( (((Index_IsActive())&&(True()))) ) {
							alt2=1;
						}

					}
					else if ( (LA2_2==EOL) ) {
						int LA2_9 = input.LA(3);
						if ( (((Index_IsActive())&&(True()))) ) {
							alt2=1;
						}

					}
					else if ( (LA2_2==AND||LA2_2==COLON||LA2_2==CTRANS||LA2_2==EQ||(LA2_2 >= GT && LA2_2 <= GTEQ)||LA2_2==LDIV||(LA2_2 >= LT && LA2_2 <= MTIMES)||LA2_2==NOTEQ||LA2_2==OR||LA2_2==PLUS||LA2_2==POW||LA2_2==RDIV||(LA2_2 >= SHORTAND && LA2_2 <= SHORTOR)||(LA2_2 >= TIMES && LA2_2 <= TRANS)) && (((Index_IsActive())&&(True())))) {
						alt2=1;
					}

				}
				else if ( (LA2_0==ID) && (((Command_IsEnabled())||(True())))) {
					alt2=1;
				}
				else if ( (LA2_0==AT||LA2_0==IMAGINARY||LA2_0==LCURLY||(LA2_0 >= LPAREN && LA2_0 <= LSQUARE)||LA2_0==MINUS||LA2_0==NOT||LA2_0==PLUS||LA2_0==QUESTION||LA2_0==REAL||LA2_0==STRING) && ((True()))) {
					alt2=1;
				}
				else if ( (LA2_0==BREAK||LA2_0==COMMAND||LA2_0==CONTINUE||LA2_0==EXCLAMATION||LA2_0==FOR||LA2_0==GLOBAL||LA2_0==IF||(LA2_0 >= PARFOR && LA2_0 <= PERSISTENT)||LA2_0==RETURN||LA2_0==SPMD||LA2_0==SWITCH||LA2_0==TRY||LA2_0==WHILE) ) {
					alt2=1;
				}
				else if ( (LA2_0==COMMA||LA2_0==EOL||LA2_0==SEMICOLON) ) {
					alt2=2;
				}

				switch (alt2) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:15: statement
					{
					pushFollow(FOLLOW_statement_in_statements462);
					statement7=statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_statement.add(statement7.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:27: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_statements466);
					xEOS8=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS8.getTree());
					}
					break;

				default :
					break loop2;
				}
			}

			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 67:34: -> ( statement )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:67:37: ( statement )*
				while ( stream_statement.hasNext() ) {
					adaptor.addChild(root_0, stream_statement.nextTree());
				}
				stream_statement.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "statements"


	public static class functionFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:1: functionFile : ( ( openFunctionFile )=> openFunctionFile -> openFunctionFile | closeFunctionFile -> closeFunctionFile );
	public final MatlabParser.functionFile_return functionFile() throws RecognitionException {
		MatlabParser.functionFile_return retval = new MatlabParser.functionFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope openFunctionFile9 =null;
		ParserRuleReturnScope closeFunctionFile10 =null;

		RewriteRuleSubtreeStream stream_closeFunctionFile=new RewriteRuleSubtreeStream(adaptor,"rule closeFunctionFile");
		RewriteRuleSubtreeStream stream_openFunctionFile=new RewriteRuleSubtreeStream(adaptor,"rule openFunctionFile");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:14: ( ( openFunctionFile )=> openFunctionFile -> openFunctionFile | closeFunctionFile -> closeFunctionFile )
			int alt3=2;
			int LA3_0 = input.LA(1);
			if ( (LA3_0==EOL) ) {
				int LA3_1 = input.LA(2);
				if ( (synpred1_MatlabParser()) ) {
					alt3=1;
				}
				else if ( (true) ) {
					alt3=2;
				}

			}
			else if ( (LA3_0==FUNCTION) ) {
				int LA3_2 = input.LA(2);
				if ( (synpred1_MatlabParser()) ) {
					alt3=1;
				}
				else if ( (true) ) {
					alt3=2;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 3, 0, input);
				throw nvae;
			}

			switch (alt3) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:16: ( openFunctionFile )=> openFunctionFile
					{
					pushFollow(FOLLOW_openFunctionFile_in_functionFile491);
					openFunctionFile9=openFunctionFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_openFunctionFile.add(openFunctionFile9.getTree());
					// AST REWRITE
					// elements: openFunctionFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 71:54: -> openFunctionFile
					{
						adaptor.addChild(root_0, stream_openFunctionFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:72:7: closeFunctionFile
					{
					pushFollow(FOLLOW_closeFunctionFile_in_functionFile503);
					closeFunctionFile10=closeFunctionFile();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeFunctionFile.add(closeFunctionFile10.getTree());
					// AST REWRITE
					// elements: closeFunctionFile
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 72:25: -> closeFunctionFile
					{
						adaptor.addChild(root_0, stream_closeFunctionFile.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionFile"


	public static class openFunctionFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openFunctionFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:1: openFunctionFile : ( EOL )* openFunctions EOF -> ^( FUNCTIONFILE[\"\"] openFunctions ) ;
	public final MatlabParser.openFunctionFile_return openFunctionFile() throws RecognitionException {
		MatlabParser.openFunctionFile_return retval = new MatlabParser.openFunctionFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL11=null;
		Token EOF13=null;
		ParserRuleReturnScope openFunctions12 =null;

		Object EOL11_tree=null;
		Object EOF13_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_openFunctions=new RewriteRuleSubtreeStream(adaptor,"rule openFunctions");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:18: ( ( EOL )* openFunctions EOF -> ^( FUNCTIONFILE[\"\"] openFunctions ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:20: ( EOL )* openFunctions EOF
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:20: ( EOL )*
			loop4:
			while (true) {
				int alt4=2;
				int LA4_0 = input.LA(1);
				if ( (LA4_0==EOL) ) {
					alt4=1;
				}

				switch (alt4) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:21: EOL
					{
					EOL11=(Token)match(input,EOL,FOLLOW_EOL_in_openFunctionFile523); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL11);

					}
					break;

				default :
					break loop4;
				}
			}

			pushFollow(FOLLOW_openFunctions_in_openFunctionFile527);
			openFunctions12=openFunctions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_openFunctions.add(openFunctions12.getTree());
			EOF13=(Token)match(input,EOF,FOLLOW_EOF_in_openFunctionFile529); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF13);

			// AST REWRITE
			// elements: openFunctions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 77:45: -> ^( FUNCTIONFILE[\"\"] openFunctions )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:77:48: ^( FUNCTIONFILE[\"\"] openFunctions )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNCTIONFILE, ""), root_1);
				adaptor.addChild(root_1, stream_openFunctions.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openFunctionFile"


	public static class openFunctions_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openFunctions"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:1: openFunctions : ( openFunction )+ -> ( openFunction )+ ;
	public final MatlabParser.openFunctions_return openFunctions() throws RecognitionException {
		MatlabParser.openFunctions_return retval = new MatlabParser.openFunctions_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope openFunction14 =null;

		RewriteRuleSubtreeStream stream_openFunction=new RewriteRuleSubtreeStream(adaptor,"rule openFunction");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:15: ( ( openFunction )+ -> ( openFunction )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:17: ( openFunction )+
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:17: ( openFunction )+
			int cnt5=0;
			loop5:
			while (true) {
				int alt5=2;
				int LA5_0 = input.LA(1);
				if ( (LA5_0==FUNCTION) ) {
					alt5=1;
				}

				switch (alt5) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:79:18: openFunction
					{
					pushFollow(FOLLOW_openFunction_in_openFunctions548);
					openFunction14=openFunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_openFunction.add(openFunction14.getTree());
					}
					break;

				default :
					if ( cnt5 >= 1 ) break loop5;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(5, input);
					throw eee;
				}
				cnt5++;
			}

			// AST REWRITE
			// elements: openFunction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 79:33: -> ( openFunction )+
			{
				if ( !(stream_openFunction.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_openFunction.hasNext() ) {
					adaptor.addChild(root_0, stream_openFunction.nextTree());
				}
				stream_openFunction.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openFunctions"


	public static class openFunction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openFunction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:1: openFunction : FUNCTION functionSignature openBody -> ^( FUNCTION functionSignature ( openBody )? ) ;
	public final MatlabParser.openFunction_return openFunction() throws RecognitionException {
		MatlabParser.openFunction_return retval = new MatlabParser.openFunction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION15=null;
		ParserRuleReturnScope functionSignature16 =null;
		ParserRuleReturnScope openBody17 =null;

		Object FUNCTION15_tree=null;
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_functionSignature=new RewriteRuleSubtreeStream(adaptor,"rule functionSignature");
		RewriteRuleSubtreeStream stream_openBody=new RewriteRuleSubtreeStream(adaptor,"rule openBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:14: ( FUNCTION functionSignature openBody -> ^( FUNCTION functionSignature ( openBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:16: FUNCTION functionSignature openBody
			{
			FUNCTION15=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_openFunction566); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION15);

			pushFollow(FOLLOW_functionSignature_in_openFunction568);
			functionSignature16=functionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_functionSignature.add(functionSignature16.getTree());
			pushFollow(FOLLOW_openBody_in_openFunction570);
			openBody17=openBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_openBody.add(openBody17.getTree());
			// AST REWRITE
			// elements: functionSignature, openBody, FUNCTION
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 81:52: -> ^( FUNCTION functionSignature ( openBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:55: ^( FUNCTION functionSignature ( openBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_FUNCTION.nextNode(), root_1);
				adaptor.addChild(root_1, stream_functionSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:81:84: ( openBody )?
				if ( stream_openBody.hasNext() ) {
					adaptor.addChild(root_1, stream_openBody.nextTree());
				}
				stream_openBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openFunction"


	public static class functionSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:1: functionSignature : ( outputPortion functionName ( inputPortion )? -> ( outputPortion )? functionName ( inputPortion )? | name ( inputPortion )? -> name ( inputPortion )? );
	public final MatlabParser.functionSignature_return functionSignature() throws RecognitionException {
		MatlabParser.functionSignature_return retval = new MatlabParser.functionSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope outputPortion18 =null;
		ParserRuleReturnScope functionName19 =null;
		ParserRuleReturnScope inputPortion20 =null;
		ParserRuleReturnScope name21 =null;
		ParserRuleReturnScope inputPortion22 =null;

		RewriteRuleSubtreeStream stream_functionName=new RewriteRuleSubtreeStream(adaptor,"rule functionName");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_outputPortion=new RewriteRuleSubtreeStream(adaptor,"rule outputPortion");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:19: ( outputPortion functionName ( inputPortion )? -> ( outputPortion )? functionName ( inputPortion )? | name ( inputPortion )? -> name ( inputPortion )? )
			int alt8=2;
			int LA8_0 = input.LA(1);
			if ( (LA8_0==ID) ) {
				int LA8_1 = input.LA(2);
				if ( (LA8_1==ASSIGN) ) {
					alt8=1;
				}
				else if ( (LA8_1==EOF||LA8_1==COMMA||(LA8_1 >= END && LA8_1 <= EOL)||LA8_1==FUNCTION||LA8_1==LPAREN||LA8_1==SEMICOLON) ) {
					alt8=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 8, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA8_0==LSQUARE) ) {
				alt8=1;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 8, 0, input);
				throw nvae;
			}

			switch (alt8) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:21: outputPortion functionName ( inputPortion )?
					{
					pushFollow(FOLLOW_outputPortion_in_functionSignature592);
					outputPortion18=outputPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_outputPortion.add(outputPortion18.getTree());
					pushFollow(FOLLOW_functionName_in_functionSignature594);
					functionName19=functionName();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_functionName.add(functionName19.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:48: ( inputPortion )?
					int alt6=2;
					int LA6_0 = input.LA(1);
					if ( (LA6_0==LPAREN) ) {
						alt6=1;
					}
					switch (alt6) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:49: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_functionSignature597);
							inputPortion20=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion20.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: functionName, inputPortion, outputPortion
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 83:64: -> ( outputPortion )? functionName ( inputPortion )?
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:67: ( outputPortion )?
						if ( stream_outputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_outputPortion.nextTree());
						}
						stream_outputPortion.reset();

						adaptor.addChild(root_0, stream_functionName.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:83:97: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:84:9: name ( inputPortion )?
					{
					pushFollow(FOLLOW_name_in_functionSignature623);
					name21=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(name21.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:84:14: ( inputPortion )?
					int alt7=2;
					int LA7_0 = input.LA(1);
					if ( (LA7_0==LPAREN) ) {
						alt7=1;
					}
					switch (alt7) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:84:15: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_functionSignature626);
							inputPortion22=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion22.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: inputPortion, name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 84:30: -> name ( inputPortion )?
					{
						adaptor.addChild(root_0, stream_name.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:84:38: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionSignature"


	public static class outputPortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "outputPortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:87:1: outputPortion : ( output ASSIGN -> output | outputVector ASSIGN -> ( outputVector )? );
	public final MatlabParser.outputPortion_return outputPortion() throws RecognitionException {
		MatlabParser.outputPortion_return retval = new MatlabParser.outputPortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASSIGN24=null;
		Token ASSIGN26=null;
		ParserRuleReturnScope output23 =null;
		ParserRuleReturnScope outputVector25 =null;

		Object ASSIGN24_tree=null;
		Object ASSIGN26_tree=null;
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_output=new RewriteRuleSubtreeStream(adaptor,"rule output");
		RewriteRuleSubtreeStream stream_outputVector=new RewriteRuleSubtreeStream(adaptor,"rule outputVector");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:87:15: ( output ASSIGN -> output | outputVector ASSIGN -> ( outputVector )? )
			int alt9=2;
			int LA9_0 = input.LA(1);
			if ( (LA9_0==ID) ) {
				alt9=1;
			}
			else if ( (LA9_0==LSQUARE) ) {
				alt9=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 9, 0, input);
				throw nvae;
			}

			switch (alt9) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:87:17: output ASSIGN
					{
					pushFollow(FOLLOW_output_in_outputPortion652);
					output23=output();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_output.add(output23.getTree());
					ASSIGN24=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_outputPortion654); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN24);

					// AST REWRITE
					// elements: output
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 87:31: -> output
					{
						adaptor.addChild(root_0, stream_output.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:88:8: outputVector ASSIGN
					{
					pushFollow(FOLLOW_outputVector_in_outputPortion667);
					outputVector25=outputVector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_outputVector.add(outputVector25.getTree());
					ASSIGN26=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_outputPortion669); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN26);

					// AST REWRITE
					// elements: outputVector
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 88:28: -> ( outputVector )?
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:88:31: ( outputVector )?
						if ( stream_outputVector.hasNext() ) {
							adaptor.addChild(root_0, stream_outputVector.nextTree());
						}
						stream_outputVector.reset();

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "outputPortion"


	public static class output_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "output"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:91:1: output : name -> ^( OUTPUT[\"\"] name ) ;
	public final MatlabParser.output_return output() throws RecognitionException {
		MatlabParser.output_return retval = new MatlabParser.output_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name27 =null;

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:91:8: ( name -> ^( OUTPUT[\"\"] name ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:91:10: name
			{
			pushFollow(FOLLOW_name_in_output690);
			name27=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name27.getTree());
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 91:15: -> ^( OUTPUT[\"\"] name )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:91:18: ^( OUTPUT[\"\"] name )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OUTPUT, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "output"


	public static class name_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "name"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:93:1: name : xID -> ^( NAME[\"\"] xID ) ;
	public final MatlabParser.name_return name() throws RecognitionException {
		MatlabParser.name_return retval = new MatlabParser.name_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xID28 =null;

		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:93:6: ( xID -> ^( NAME[\"\"] xID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:93:8: xID
			{
			pushFollow(FOLLOW_xID_in_name708);
			xID28=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID28.getTree());
			// AST REWRITE
			// elements: xID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 93:12: -> ^( NAME[\"\"] xID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:93:15: ^( NAME[\"\"] xID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name"


	public static class outputVector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "outputVector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:1: outputVector : LSQUARE ( vectorOutputs )? RSQUARE -> ( vectorOutputs )? ;
	public final MatlabParser.outputVector_return outputVector() throws RecognitionException {
		MatlabParser.outputVector_return retval = new MatlabParser.outputVector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE29=null;
		Token RSQUARE31=null;
		ParserRuleReturnScope vectorOutputs30 =null;

		Object LSQUARE29_tree=null;
		Object RSQUARE31_tree=null;
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_vectorOutputs=new RewriteRuleSubtreeStream(adaptor,"rule vectorOutputs");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:14: ( LSQUARE ( vectorOutputs )? RSQUARE -> ( vectorOutputs )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:16: LSQUARE ( vectorOutputs )? RSQUARE
			{
			LSQUARE29=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_outputVector726); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE29);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:24: ( vectorOutputs )?
			int alt10=2;
			int LA10_0 = input.LA(1);
			if ( (LA10_0==ID) ) {
				alt10=1;
			}
			switch (alt10) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:25: vectorOutputs
					{
					pushFollow(FOLLOW_vectorOutputs_in_outputVector729);
					vectorOutputs30=vectorOutputs();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_vectorOutputs.add(vectorOutputs30.getTree());
					}
					break;

			}

			RSQUARE31=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_outputVector733); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE31);

			// AST REWRITE
			// elements: vectorOutputs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 95:49: -> ( vectorOutputs )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:95:52: ( vectorOutputs )?
				if ( stream_vectorOutputs.hasNext() ) {
					adaptor.addChild(root_0, stream_vectorOutputs.nextTree());
				}
				stream_vectorOutputs.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "outputVector"


	public static class vectorOutputs_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "vectorOutputs"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:1: vectorOutputs : vectorOutput ({...}? => ( COMMA )? vectorOutput )* -> ( vectorOutput )+ ;
	public final MatlabParser.vectorOutputs_return vectorOutputs() throws RecognitionException {
		MatlabParser.vectorOutputs_return retval = new MatlabParser.vectorOutputs_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA33=null;
		ParserRuleReturnScope vectorOutput32 =null;
		ParserRuleReturnScope vectorOutput34 =null;

		Object COMMA33_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_vectorOutput=new RewriteRuleSubtreeStream(adaptor,"rule vectorOutput");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:15: ( vectorOutput ({...}? => ( COMMA )? vectorOutput )* -> ( vectorOutput )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:17: vectorOutput ({...}? => ( COMMA )? vectorOutput )*
			{
			pushFollow(FOLLOW_vectorOutput_in_vectorOutputs749);
			vectorOutput32=vectorOutput();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_vectorOutput.add(vectorOutput32.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:30: ({...}? => ( COMMA )? vectorOutput )*
			loop12:
			while (true) {
				int alt12=2;
				int LA12_0 = input.LA(1);
				if ( (LA12_0==COMMA||LA12_0==ID) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
					alt12=1;
				}

				switch (alt12) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:31: {...}? => ( COMMA )? vectorOutput
					{
					if ( !((Separator_CommaFollowsOrSpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "vectorOutputs", "Separator_CommaFollowsOrSpacesPrecede()");
					}
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:76: ( COMMA )?
					int alt11=2;
					int LA11_0 = input.LA(1);
					if ( (LA11_0==COMMA) ) {
						alt11=1;
					}
					switch (alt11) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:97:77: COMMA
							{
							COMMA33=(Token)match(input,COMMA,FOLLOW_COMMA_in_vectorOutputs756); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA33);

							}
							break;

					}

					pushFollow(FOLLOW_vectorOutput_in_vectorOutputs760);
					vectorOutput34=vectorOutput();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_vectorOutput.add(vectorOutput34.getTree());
					}
					break;

				default :
					break loop12;
				}
			}

			// AST REWRITE
			// elements: vectorOutput
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 97:100: -> ( vectorOutput )+
			{
				if ( !(stream_vectorOutput.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_vectorOutput.hasNext() ) {
					adaptor.addChild(root_0, stream_vectorOutput.nextTree());
				}
				stream_vectorOutput.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "vectorOutputs"


	public static class vectorOutput_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "vectorOutput"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:1: vectorOutput : name ({...}? => filter )? -> ^( OUTPUT[\"\"] name ( filter )? ) ;
	public final MatlabParser.vectorOutput_return vectorOutput() throws RecognitionException {
		MatlabParser.vectorOutput_return retval = new MatlabParser.vectorOutput_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name35 =null;
		ParserRuleReturnScope filter36 =null;

		RewriteRuleSubtreeStream stream_filter=new RewriteRuleSubtreeStream(adaptor,"rule filter");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:14: ( name ({...}? => filter )? -> ^( OUTPUT[\"\"] name ( filter )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:16: name ({...}? => filter )?
			{
			pushFollow(FOLLOW_name_in_vectorOutput778);
			name35=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name35.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:21: ({...}? => filter )?
			int alt13=2;
			int LA13_0 = input.LA(1);
			if ( (LA13_0==AT) && ((Method_SignatureIsActive()))) {
				alt13=1;
			}
			switch (alt13) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:22: {...}? => filter
					{
					if ( !((Method_SignatureIsActive())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "vectorOutput", "Method_SignatureIsActive()");
					}
					pushFollow(FOLLOW_filter_in_vectorOutput784);
					filter36=filter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_filter.add(filter36.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: filter, name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 99:63: -> ^( OUTPUT[\"\"] name ( filter )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:66: ^( OUTPUT[\"\"] name ( filter )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OUTPUT, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:99:84: ( filter )?
				if ( stream_filter.hasNext() ) {
					adaptor.addChild(root_1, stream_filter.nextTree());
				}
				stream_filter.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "vectorOutput"


	public static class filter_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "filter"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:101:1: filter : AT classReference -> classReference ;
	public final MatlabParser.filter_return filter() throws RecognitionException {
		MatlabParser.filter_return retval = new MatlabParser.filter_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AT37=null;
		ParserRuleReturnScope classReference38 =null;

		Object AT37_tree=null;
		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:101:8: ( AT classReference -> classReference )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:101:10: AT classReference
			{
			AT37=(Token)match(input,AT,FOLLOW_AT_in_filter809); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_AT.add(AT37);

			pushFollow(FOLLOW_classReference_in_filter811);
			classReference38=classReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classReference.add(classReference38.getTree());
			// AST REWRITE
			// elements: classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 101:28: -> classReference
			{
				adaptor.addChild(root_0, stream_classReference.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "filter"


	public static class functionName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:103:1: functionName : xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) ;
	public final MatlabParser.functionName_return functionName() throws RecognitionException {
		MatlabParser.functionName_return retval = new MatlabParser.functionName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xFUNCTIONID39 =null;

		RewriteRuleSubtreeStream stream_xFUNCTIONID=new RewriteRuleSubtreeStream(adaptor,"rule xFUNCTIONID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:103:14: ( xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:103:16: xFUNCTIONID
			{
			pushFollow(FOLLOW_xFUNCTIONID_in_functionName824);
			xFUNCTIONID39=xFUNCTIONID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xFUNCTIONID.add(xFUNCTIONID39.getTree());
			// AST REWRITE
			// elements: xFUNCTIONID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 103:28: -> ^( NAME[\"\"] xFUNCTIONID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:103:31: ^( NAME[\"\"] xFUNCTIONID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xFUNCTIONID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionName"


	public static class inputPortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "inputPortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:1: inputPortion : LPAREN ( parameters )? RPAREN -> ( parameters )? ;
	public final MatlabParser.inputPortion_return inputPortion() throws RecognitionException {
		MatlabParser.inputPortion_return retval = new MatlabParser.inputPortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN40=null;
		Token RPAREN42=null;
		ParserRuleReturnScope parameters41 =null;

		Object LPAREN40_tree=null;
		Object RPAREN42_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_parameters=new RewriteRuleSubtreeStream(adaptor,"rule parameters");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:14: ( LPAREN ( parameters )? RPAREN -> ( parameters )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:16: LPAREN ( parameters )? RPAREN
			{
			LPAREN40=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_inputPortion842); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN40);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:23: ( parameters )?
			int alt14=2;
			int LA14_0 = input.LA(1);
			if ( (LA14_0==ID||LA14_0==NOT) ) {
				alt14=1;
			}
			switch (alt14) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:24: parameters
					{
					pushFollow(FOLLOW_parameters_in_inputPortion845);
					parameters41=parameters();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parameters.add(parameters41.getTree());
					}
					break;

			}

			RPAREN42=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_inputPortion849); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN42);

			// AST REWRITE
			// elements: parameters
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 105:44: -> ( parameters )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:105:47: ( parameters )?
				if ( stream_parameters.hasNext() ) {
					adaptor.addChild(root_0, stream_parameters.nextTree());
				}
				stream_parameters.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "inputPortion"


	public static class parameters_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parameters"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:1: parameters : parameter ( COMMA parameter )* -> ( parameter )+ ;
	public final MatlabParser.parameters_return parameters() throws RecognitionException {
		MatlabParser.parameters_return retval = new MatlabParser.parameters_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA44=null;
		ParserRuleReturnScope parameter43 =null;
		ParserRuleReturnScope parameter45 =null;

		Object COMMA44_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_parameter=new RewriteRuleSubtreeStream(adaptor,"rule parameter");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:12: ( parameter ( COMMA parameter )* -> ( parameter )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:14: parameter ( COMMA parameter )*
			{
			pushFollow(FOLLOW_parameter_in_parameters865);
			parameter43=parameter();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parameter.add(parameter43.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:24: ( COMMA parameter )*
			loop15:
			while (true) {
				int alt15=2;
				int LA15_0 = input.LA(1);
				if ( (LA15_0==COMMA) ) {
					alt15=1;
				}

				switch (alt15) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:107:25: COMMA parameter
					{
					COMMA44=(Token)match(input,COMMA,FOLLOW_COMMA_in_parameters868); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA44);

					pushFollow(FOLLOW_parameter_in_parameters870);
					parameter45=parameter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parameter.add(parameter45.getTree());
					}
					break;

				default :
					break loop15;
				}
			}

			// AST REWRITE
			// elements: parameter
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 107:43: -> ( parameter )+
			{
				if ( !(stream_parameter.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_parameter.hasNext() ) {
					adaptor.addChild(root_0, stream_parameter.nextTree());
				}
				stream_parameter.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameters"


	public static class parameter_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parameter"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:1: parameter : parameterName ({...}? => filter )? -> ^( INPUT[\"\"] parameterName ( filter )? ) ;
	public final MatlabParser.parameter_return parameter() throws RecognitionException {
		MatlabParser.parameter_return retval = new MatlabParser.parameter_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope parameterName46 =null;
		ParserRuleReturnScope filter47 =null;

		RewriteRuleSubtreeStream stream_filter=new RewriteRuleSubtreeStream(adaptor,"rule filter");
		RewriteRuleSubtreeStream stream_parameterName=new RewriteRuleSubtreeStream(adaptor,"rule parameterName");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:11: ( parameterName ({...}? => filter )? -> ^( INPUT[\"\"] parameterName ( filter )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:13: parameterName ({...}? => filter )?
			{
			pushFollow(FOLLOW_parameterName_in_parameter888);
			parameterName46=parameterName();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parameterName.add(parameterName46.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:27: ({...}? => filter )?
			int alt16=2;
			int LA16_0 = input.LA(1);
			if ( (LA16_0==AT) && ((Method_SignatureIsActive()))) {
				alt16=1;
			}
			switch (alt16) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:28: {...}? => filter
					{
					if ( !((Method_SignatureIsActive())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "parameter", "Method_SignatureIsActive()");
					}
					pushFollow(FOLLOW_filter_in_parameter894);
					filter47=filter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_filter.add(filter47.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: parameterName, filter
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 109:69: -> ^( INPUT[\"\"] parameterName ( filter )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:72: ^( INPUT[\"\"] parameterName ( filter )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(INPUT, ""), root_1);
				adaptor.addChild(root_1, stream_parameterName.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:109:98: ( filter )?
				if ( stream_filter.hasNext() ) {
					adaptor.addChild(root_1, stream_filter.nextTree());
				}
				stream_filter.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameter"


	public static class parameterName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parameterName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:111:1: parameterName : xPARAMETERID -> ^( NAME[\"\"] xPARAMETERID ) ;
	public final MatlabParser.parameterName_return parameterName() throws RecognitionException {
		MatlabParser.parameterName_return retval = new MatlabParser.parameterName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xPARAMETERID48 =null;

		RewriteRuleSubtreeStream stream_xPARAMETERID=new RewriteRuleSubtreeStream(adaptor,"rule xPARAMETERID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:111:15: ( xPARAMETERID -> ^( NAME[\"\"] xPARAMETERID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:111:17: xPARAMETERID
			{
			pushFollow(FOLLOW_xPARAMETERID_in_parameterName919);
			xPARAMETERID48=xPARAMETERID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xPARAMETERID.add(xPARAMETERID48.getTree());
			// AST REWRITE
			// elements: xPARAMETERID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 111:30: -> ^( NAME[\"\"] xPARAMETERID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:111:33: ^( NAME[\"\"] xPARAMETERID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xPARAMETERID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameterName"


	public static class openBody_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openBody"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:1: openBody : ( xEOS openItems )? -> ( openItems )? ;
	public final MatlabParser.openBody_return openBody() throws RecognitionException {
		MatlabParser.openBody_return retval = new MatlabParser.openBody_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xEOS49 =null;
		ParserRuleReturnScope openItems50 =null;

		RewriteRuleSubtreeStream stream_openItems=new RewriteRuleSubtreeStream(adaptor,"rule openItems");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:10: ( ( xEOS openItems )? -> ( openItems )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:12: ( xEOS openItems )?
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:12: ( xEOS openItems )?
			int alt17=2;
			int LA17_0 = input.LA(1);
			if ( (LA17_0==COMMA||LA17_0==EOL||LA17_0==SEMICOLON) ) {
				alt17=1;
			}
			switch (alt17) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:13: xEOS openItems
					{
					pushFollow(FOLLOW_xEOS_in_openBody938);
					xEOS49=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS49.getTree());
					pushFollow(FOLLOW_openItems_in_openBody940);
					openItems50=openItems();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_openItems.add(openItems50.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: openItems
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 113:30: -> ( openItems )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:113:33: ( openItems )?
				if ( stream_openItems.hasNext() ) {
					adaptor.addChild(root_0, stream_openItems.nextTree());
				}
				stream_openItems.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openBody"


	public static class openItems_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openItems"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:1: openItems : ( openItem | xEOS )* -> ( openItem )* ;
	public final MatlabParser.openItems_return openItems() throws RecognitionException {
		MatlabParser.openItems_return retval = new MatlabParser.openItems_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope openItem51 =null;
		ParserRuleReturnScope xEOS52 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_openItem=new RewriteRuleSubtreeStream(adaptor,"rule openItem");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:11: ( ( openItem | xEOS )* -> ( openItem )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:13: ( openItem | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:13: ( openItem | xEOS )*
			loop18:
			while (true) {
				int alt18=3;
				int LA18_0 = input.LA(1);
				if ( (LA18_0==ID) && (((Command_IsEnabled())||(True())))) {
					alt18=1;
				}
				else if ( (LA18_0==IMAGINARY||LA18_0==LCURLY||(LA18_0 >= LPAREN && LA18_0 <= LSQUARE)||LA18_0==MINUS||LA18_0==NOT||LA18_0==PLUS||LA18_0==REAL||LA18_0==STRING) && ((True()))) {
					alt18=1;
				}
				else if ( (LA18_0==END) && (((Index_IsActive())&&(True())))) {
					alt18=1;
				}
				else if ( (LA18_0==AT||LA18_0==QUESTION) && ((True()))) {
					alt18=1;
				}
				else if ( (LA18_0==BREAK||LA18_0==COMMAND||LA18_0==CONTINUE||LA18_0==EXCLAMATION||LA18_0==FOR||LA18_0==GLOBAL||LA18_0==IF||(LA18_0 >= PARFOR && LA18_0 <= PERSISTENT)||LA18_0==RETURN||LA18_0==SPMD||LA18_0==SWITCH||LA18_0==TRY||LA18_0==WHILE) ) {
					alt18=1;
				}
				else if ( (LA18_0==COMMA||LA18_0==EOL||LA18_0==SEMICOLON) ) {
					alt18=2;
				}

				switch (alt18) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:14: openItem
					{
					pushFollow(FOLLOW_openItem_in_openItems959);
					openItem51=openItem();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_openItem.add(openItem51.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:25: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_openItems963);
					xEOS52=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS52.getTree());
					}
					break;

				default :
					break loop18;
				}
			}

			// AST REWRITE
			// elements: openItem
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 115:32: -> ( openItem )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:115:35: ( openItem )*
				while ( stream_openItem.hasNext() ) {
					adaptor.addChild(root_0, stream_openItem.nextTree());
				}
				stream_openItem.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openItems"


	public static class openItem_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "openItem"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:117:1: openItem : statement -> statement ;
	public final MatlabParser.openItem_return openItem() throws RecognitionException {
		MatlabParser.openItem_return retval = new MatlabParser.openItem_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope statement53 =null;

		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:117:10: ( statement -> statement )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:117:12: statement
			{
			pushFollow(FOLLOW_statement_in_openItem981);
			statement53=statement();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statement.add(statement53.getTree());
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 117:22: -> statement
			{
				adaptor.addChild(root_0, stream_statement.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "openItem"


	public static class closeFunctionFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeFunctionFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:1: closeFunctionFile : ( EOL )* closeFunctions ( EOL )* EOF -> ^( FUNCTIONFILE[\"\"] closeFunctions ) ;
	public final MatlabParser.closeFunctionFile_return closeFunctionFile() throws RecognitionException {
		MatlabParser.closeFunctionFile_return retval = new MatlabParser.closeFunctionFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL54=null;
		Token EOL56=null;
		Token EOF57=null;
		ParserRuleReturnScope closeFunctions55 =null;

		Object EOL54_tree=null;
		Object EOL56_tree=null;
		Object EOF57_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_closeFunctions=new RewriteRuleSubtreeStream(adaptor,"rule closeFunctions");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:19: ( ( EOL )* closeFunctions ( EOL )* EOF -> ^( FUNCTIONFILE[\"\"] closeFunctions ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:21: ( EOL )* closeFunctions ( EOL )* EOF
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:21: ( EOL )*
			loop19:
			while (true) {
				int alt19=2;
				int LA19_0 = input.LA(1);
				if ( (LA19_0==EOL) ) {
					alt19=1;
				}

				switch (alt19) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:22: EOL
					{
					EOL54=(Token)match(input,EOL,FOLLOW_EOL_in_closeFunctionFile997); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL54);

					}
					break;

				default :
					break loop19;
				}
			}

			pushFollow(FOLLOW_closeFunctions_in_closeFunctionFile1001);
			closeFunctions55=closeFunctions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeFunctions.add(closeFunctions55.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:43: ( EOL )*
			loop20:
			while (true) {
				int alt20=2;
				int LA20_0 = input.LA(1);
				if ( (LA20_0==EOL) ) {
					alt20=1;
				}

				switch (alt20) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:44: EOL
					{
					EOL56=(Token)match(input,EOL,FOLLOW_EOL_in_closeFunctionFile1004); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL56);

					}
					break;

				default :
					break loop20;
				}
			}

			EOF57=(Token)match(input,EOF,FOLLOW_EOF_in_closeFunctionFile1008); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF57);

			// AST REWRITE
			// elements: closeFunctions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 121:54: -> ^( FUNCTIONFILE[\"\"] closeFunctions )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:121:57: ^( FUNCTIONFILE[\"\"] closeFunctions )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNCTIONFILE, ""), root_1);
				adaptor.addChild(root_1, stream_closeFunctions.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeFunctionFile"


	public static class closeFunctions_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeFunctions"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:1: closeFunctions : closeFunction ( ( EOL )* closeFunction )* -> ( closeFunction )+ ;
	public final MatlabParser.closeFunctions_return closeFunctions() throws RecognitionException {
		MatlabParser.closeFunctions_return retval = new MatlabParser.closeFunctions_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL59=null;
		ParserRuleReturnScope closeFunction58 =null;
		ParserRuleReturnScope closeFunction60 =null;

		Object EOL59_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleSubtreeStream stream_closeFunction=new RewriteRuleSubtreeStream(adaptor,"rule closeFunction");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:16: ( closeFunction ( ( EOL )* closeFunction )* -> ( closeFunction )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:18: closeFunction ( ( EOL )* closeFunction )*
			{
			pushFollow(FOLLOW_closeFunction_in_closeFunctions1026);
			closeFunction58=closeFunction();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeFunction.add(closeFunction58.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:32: ( ( EOL )* closeFunction )*
			loop22:
			while (true) {
				int alt22=2;
				alt22 = dfa22.predict(input);
				switch (alt22) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:33: ( EOL )* closeFunction
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:33: ( EOL )*
					loop21:
					while (true) {
						int alt21=2;
						int LA21_0 = input.LA(1);
						if ( (LA21_0==EOL) ) {
							alt21=1;
						}

						switch (alt21) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:123:34: EOL
							{
							EOL59=(Token)match(input,EOL,FOLLOW_EOL_in_closeFunctions1030); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EOL.add(EOL59);

							}
							break;

						default :
							break loop21;
						}
					}

					pushFollow(FOLLOW_closeFunction_in_closeFunctions1034);
					closeFunction60=closeFunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeFunction.add(closeFunction60.getTree());
					}
					break;

				default :
					break loop22;
				}
			}

			// AST REWRITE
			// elements: closeFunction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 123:56: -> ( closeFunction )+
			{
				if ( !(stream_closeFunction.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_closeFunction.hasNext() ) {
					adaptor.addChild(root_0, stream_closeFunction.nextTree());
				}
				stream_closeFunction.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeFunctions"


	public static class closeFunction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeFunction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:1: closeFunction : FUNCTION functionSignature closeBody END -> ^( FUNCTION functionSignature ( closeBody )? ) ;
	public final MatlabParser.closeFunction_return closeFunction() throws RecognitionException {
		MatlabParser.closeFunction_return retval = new MatlabParser.closeFunction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION61=null;
		Token END64=null;
		ParserRuleReturnScope functionSignature62 =null;
		ParserRuleReturnScope closeBody63 =null;

		Object FUNCTION61_tree=null;
		Object END64_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_functionSignature=new RewriteRuleSubtreeStream(adaptor,"rule functionSignature");
		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:15: ( FUNCTION functionSignature closeBody END -> ^( FUNCTION functionSignature ( closeBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:17: FUNCTION functionSignature closeBody END
			{
			FUNCTION61=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_closeFunction1052); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION61);

			pushFollow(FOLLOW_functionSignature_in_closeFunction1054);
			functionSignature62=functionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_functionSignature.add(functionSignature62.getTree());
			pushFollow(FOLLOW_closeBody_in_closeFunction1056);
			closeBody63=closeBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeBody.add(closeBody63.getTree());
			END64=(Token)match(input,END,FOLLOW_END_in_closeFunction1058); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END64);

			// AST REWRITE
			// elements: closeBody, FUNCTION, functionSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 125:58: -> ^( FUNCTION functionSignature ( closeBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:61: ^( FUNCTION functionSignature ( closeBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_FUNCTION.nextNode(), root_1);
				adaptor.addChild(root_1, stream_functionSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:125:90: ( closeBody )?
				if ( stream_closeBody.hasNext() ) {
					adaptor.addChild(root_1, stream_closeBody.nextTree());
				}
				stream_closeBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeFunction"


	public static class closeBody_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeBody"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:1: closeBody : ( xEOS closeItems )? -> ( closeItems )? ;
	public final MatlabParser.closeBody_return closeBody() throws RecognitionException {
		MatlabParser.closeBody_return retval = new MatlabParser.closeBody_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xEOS65 =null;
		ParserRuleReturnScope closeItems66 =null;

		RewriteRuleSubtreeStream stream_closeItems=new RewriteRuleSubtreeStream(adaptor,"rule closeItems");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:11: ( ( xEOS closeItems )? -> ( closeItems )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:13: ( xEOS closeItems )?
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:13: ( xEOS closeItems )?
			int alt23=2;
			int LA23_0 = input.LA(1);
			if ( (LA23_0==COMMA||LA23_0==EOL||LA23_0==SEMICOLON) ) {
				alt23=1;
			}
			switch (alt23) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:14: xEOS closeItems
					{
					pushFollow(FOLLOW_xEOS_in_closeBody1081);
					xEOS65=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS65.getTree());
					pushFollow(FOLLOW_closeItems_in_closeBody1083);
					closeItems66=closeItems();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeItems.add(closeItems66.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: closeItems
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 127:32: -> ( closeItems )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:127:35: ( closeItems )?
				if ( stream_closeItems.hasNext() ) {
					adaptor.addChild(root_0, stream_closeItems.nextTree());
				}
				stream_closeItems.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeBody"


	public static class closeItems_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeItems"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:1: closeItems : ( closeItem | xEOS )* -> ( closeItem )* ;
	public final MatlabParser.closeItems_return closeItems() throws RecognitionException {
		MatlabParser.closeItems_return retval = new MatlabParser.closeItems_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope closeItem67 =null;
		ParserRuleReturnScope xEOS68 =null;

		RewriteRuleSubtreeStream stream_closeItem=new RewriteRuleSubtreeStream(adaptor,"rule closeItem");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:12: ( ( closeItem | xEOS )* -> ( closeItem )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:14: ( closeItem | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:14: ( closeItem | xEOS )*
			loop24:
			while (true) {
				int alt24=3;
				int LA24_0 = input.LA(1);
				if ( (LA24_0==END) ) {
					int LA24_1 = input.LA(2);
					if ( (((Index_IsActive())&&(True()))) ) {
						alt24=1;
					}

				}
				else if ( (LA24_0==FUNCTION) ) {
					alt24=1;
				}
				else if ( (LA24_0==ID) && (((Command_IsEnabled())||(True())))) {
					alt24=1;
				}
				else if ( (LA24_0==AT||LA24_0==IMAGINARY||LA24_0==LCURLY||(LA24_0 >= LPAREN && LA24_0 <= LSQUARE)||LA24_0==MINUS||LA24_0==NOT||LA24_0==PLUS||LA24_0==QUESTION||LA24_0==REAL||LA24_0==STRING) && ((True()))) {
					alt24=1;
				}
				else if ( (LA24_0==BREAK||LA24_0==COMMAND||LA24_0==CONTINUE||LA24_0==EXCLAMATION||LA24_0==FOR||LA24_0==GLOBAL||LA24_0==IF||(LA24_0 >= PARFOR && LA24_0 <= PERSISTENT)||LA24_0==RETURN||LA24_0==SPMD||LA24_0==SWITCH||LA24_0==TRY||LA24_0==WHILE) ) {
					alt24=1;
				}
				else if ( (LA24_0==COMMA||LA24_0==EOL||LA24_0==SEMICOLON) ) {
					alt24=2;
				}

				switch (alt24) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:15: closeItem
					{
					pushFollow(FOLLOW_closeItem_in_closeItems1102);
					closeItem67=closeItem();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeItem.add(closeItem67.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:27: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_closeItems1106);
					xEOS68=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS68.getTree());
					}
					break;

				default :
					break loop24;
				}
			}

			// AST REWRITE
			// elements: closeItem
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 129:34: -> ( closeItem )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:129:37: ( closeItem )*
				while ( stream_closeItem.hasNext() ) {
					adaptor.addChild(root_0, stream_closeItem.nextTree());
				}
				stream_closeItem.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeItems"


	public static class closeItem_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "closeItem"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:131:1: closeItem : ( nestedFunction -> nestedFunction | statement -> statement );
	public final MatlabParser.closeItem_return closeItem() throws RecognitionException {
		MatlabParser.closeItem_return retval = new MatlabParser.closeItem_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope nestedFunction69 =null;
		ParserRuleReturnScope statement70 =null;

		RewriteRuleSubtreeStream stream_nestedFunction=new RewriteRuleSubtreeStream(adaptor,"rule nestedFunction");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:131:11: ( nestedFunction -> nestedFunction | statement -> statement )
			int alt25=2;
			int LA25_0 = input.LA(1);
			if ( (LA25_0==FUNCTION) ) {
				alt25=1;
			}
			else if ( (LA25_0==ID) && (((Command_IsEnabled())||(True())))) {
				alt25=2;
			}
			else if ( (LA25_0==IMAGINARY||LA25_0==LCURLY||(LA25_0 >= LPAREN && LA25_0 <= LSQUARE)||LA25_0==MINUS||LA25_0==NOT||LA25_0==PLUS||LA25_0==REAL||LA25_0==STRING) && ((True()))) {
				alt25=2;
			}
			else if ( (LA25_0==END) && (((Index_IsActive())&&(True())))) {
				alt25=2;
			}
			else if ( (LA25_0==AT||LA25_0==QUESTION) && ((True()))) {
				alt25=2;
			}
			else if ( (LA25_0==BREAK||LA25_0==COMMAND||LA25_0==CONTINUE||LA25_0==EXCLAMATION||LA25_0==FOR||LA25_0==GLOBAL||LA25_0==IF||(LA25_0 >= PARFOR && LA25_0 <= PERSISTENT)||LA25_0==RETURN||LA25_0==SPMD||LA25_0==SWITCH||LA25_0==TRY||LA25_0==WHILE) ) {
				alt25=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 25, 0, input);
				throw nvae;
			}

			switch (alt25) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:131:13: nestedFunction
					{
					pushFollow(FOLLOW_nestedFunction_in_closeItem1124);
					nestedFunction69=nestedFunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_nestedFunction.add(nestedFunction69.getTree());
					// AST REWRITE
					// elements: nestedFunction
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 131:28: -> nestedFunction
					{
						adaptor.addChild(root_0, stream_nestedFunction.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:132:13: statement
					{
					pushFollow(FOLLOW_statement_in_closeItem1142);
					statement70=statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_statement.add(statement70.getTree());
					// AST REWRITE
					// elements: statement
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 132:23: -> statement
					{
						adaptor.addChild(root_0, stream_statement.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "closeItem"


	public static class nestedFunction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nestedFunction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:1: nestedFunction : FUNCTION functionSignature closeBody END -> ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? ) ;
	public final MatlabParser.nestedFunction_return nestedFunction() throws RecognitionException {
		MatlabParser.nestedFunction_return retval = new MatlabParser.nestedFunction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION71=null;
		Token END74=null;
		ParserRuleReturnScope functionSignature72 =null;
		ParserRuleReturnScope closeBody73 =null;

		Object FUNCTION71_tree=null;
		Object END74_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_functionSignature=new RewriteRuleSubtreeStream(adaptor,"rule functionSignature");
		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:16: ( FUNCTION functionSignature closeBody END -> ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:18: FUNCTION functionSignature closeBody END
			{
			FUNCTION71=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_nestedFunction1159); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION71);

			pushFollow(FOLLOW_functionSignature_in_nestedFunction1161);
			functionSignature72=functionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_functionSignature.add(functionSignature72.getTree());
			pushFollow(FOLLOW_closeBody_in_nestedFunction1163);
			closeBody73=closeBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeBody.add(closeBody73.getTree());
			END74=(Token)match(input,END,FOLLOW_END_in_nestedFunction1165); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END74);

			// AST REWRITE
			// elements: closeBody, functionSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 135:59: -> ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:62: ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NESTEDFUNCTION, FUNCTION71), root_1);
				adaptor.addChild(root_1, stream_functionSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:135:108: ( closeBody )?
				if ( stream_closeBody.hasNext() ) {
					adaptor.addChild(root_1, stream_closeBody.nextTree());
				}
				stream_closeBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nestedFunction"


	public static class classFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "classFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:1: classFile : ( EOL )* classDef ( EOL )* ( closeFunctions ( EOL )* )? EOF -> ^( CLASSFILE[\"\"] classDef ( closeFunctions )? ) ;
	public final MatlabParser.classFile_return classFile() throws RecognitionException {
		MatlabParser.classFile_return retval = new MatlabParser.classFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL75=null;
		Token EOL77=null;
		Token EOL79=null;
		Token EOF80=null;
		ParserRuleReturnScope classDef76 =null;
		ParserRuleReturnScope closeFunctions78 =null;

		Object EOL75_tree=null;
		Object EOL77_tree=null;
		Object EOL79_tree=null;
		Object EOF80_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_classDef=new RewriteRuleSubtreeStream(adaptor,"rule classDef");
		RewriteRuleSubtreeStream stream_closeFunctions=new RewriteRuleSubtreeStream(adaptor,"rule closeFunctions");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:11: ( ( EOL )* classDef ( EOL )* ( closeFunctions ( EOL )* )? EOF -> ^( CLASSFILE[\"\"] classDef ( closeFunctions )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:13: ( EOL )* classDef ( EOL )* ( closeFunctions ( EOL )* )? EOF
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:13: ( EOL )*
			loop26:
			while (true) {
				int alt26=2;
				int LA26_0 = input.LA(1);
				if ( (LA26_0==EOL) ) {
					alt26=1;
				}

				switch (alt26) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:14: EOL
					{
					EOL75=(Token)match(input,EOL,FOLLOW_EOL_in_classFile1191); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL75);

					}
					break;

				default :
					break loop26;
				}
			}

			pushFollow(FOLLOW_classDef_in_classFile1195);
			classDef76=classDef();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classDef.add(classDef76.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:29: ( EOL )*
			loop27:
			while (true) {
				int alt27=2;
				int LA27_0 = input.LA(1);
				if ( (LA27_0==EOL) ) {
					alt27=1;
				}

				switch (alt27) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:30: EOL
					{
					EOL77=(Token)match(input,EOL,FOLLOW_EOL_in_classFile1198); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL77);

					}
					break;

				default :
					break loop27;
				}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:36: ( closeFunctions ( EOL )* )?
			int alt29=2;
			int LA29_0 = input.LA(1);
			if ( (LA29_0==FUNCTION) ) {
				alt29=1;
			}
			switch (alt29) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:37: closeFunctions ( EOL )*
					{
					pushFollow(FOLLOW_closeFunctions_in_classFile1203);
					closeFunctions78=closeFunctions();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_closeFunctions.add(closeFunctions78.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:52: ( EOL )*
					loop28:
					while (true) {
						int alt28=2;
						int LA28_0 = input.LA(1);
						if ( (LA28_0==EOL) ) {
							alt28=1;
						}

						switch (alt28) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:53: EOL
							{
							EOL79=(Token)match(input,EOL,FOLLOW_EOL_in_classFile1206); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EOL.add(EOL79);

							}
							break;

						default :
							break loop28;
						}
					}

					}
					break;

			}

			EOF80=(Token)match(input,EOF,FOLLOW_EOF_in_classFile1212); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF80);

			// AST REWRITE
			// elements: classDef, closeFunctions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 139:65: -> ^( CLASSFILE[\"\"] classDef ( closeFunctions )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:68: ^( CLASSFILE[\"\"] classDef ( closeFunctions )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CLASSFILE, ""), root_1);
				adaptor.addChild(root_1, stream_classDef.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:139:93: ( closeFunctions )?
				if ( stream_closeFunctions.hasNext() ) {
					adaptor.addChild(root_1, stream_closeFunctions.nextTree());
				}
				stream_closeFunctions.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "classFile"


	public static class classDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "classDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:1: classDef : CLASSDEF ( annotationPortion )? name ( genealogyPortion )? xEOS sections END -> ^( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? ( sections )? ) ;
	public final MatlabParser.classDef_return classDef() throws RecognitionException {
		MatlabParser.classDef_return retval = new MatlabParser.classDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CLASSDEF81=null;
		Token END87=null;
		ParserRuleReturnScope annotationPortion82 =null;
		ParserRuleReturnScope name83 =null;
		ParserRuleReturnScope genealogyPortion84 =null;
		ParserRuleReturnScope xEOS85 =null;
		ParserRuleReturnScope sections86 =null;

		Object CLASSDEF81_tree=null;
		Object END87_tree=null;
		RewriteRuleTokenStream stream_CLASSDEF=new RewriteRuleTokenStream(adaptor,"token CLASSDEF");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_genealogyPortion=new RewriteRuleSubtreeStream(adaptor,"rule genealogyPortion");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_sections=new RewriteRuleSubtreeStream(adaptor,"rule sections");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:10: ( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? xEOS sections END -> ^( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? ( sections )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:12: CLASSDEF ( annotationPortion )? name ( genealogyPortion )? xEOS sections END
			{
			CLASSDEF81=(Token)match(input,CLASSDEF,FOLLOW_CLASSDEF_in_classDef1235); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CLASSDEF.add(CLASSDEF81);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:21: ( annotationPortion )?
			int alt30=2;
			int LA30_0 = input.LA(1);
			if ( (LA30_0==LPAREN) ) {
				alt30=1;
			}
			switch (alt30) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:22: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_classDef1238);
					annotationPortion82=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion82.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_name_in_classDef1242);
			name83=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name83.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:47: ( genealogyPortion )?
			int alt31=2;
			int LA31_0 = input.LA(1);
			if ( (LA31_0==LT) ) {
				alt31=1;
			}
			switch (alt31) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:48: genealogyPortion
					{
					pushFollow(FOLLOW_genealogyPortion_in_classDef1245);
					genealogyPortion84=genealogyPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_genealogyPortion.add(genealogyPortion84.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_xEOS_in_classDef1249);
			xEOS85=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS85.getTree());
			pushFollow(FOLLOW_sections_in_classDef1251);
			sections86=sections();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_sections.add(sections86.getTree());
			END87=(Token)match(input,END,FOLLOW_END_in_classDef1253); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END87);

			// AST REWRITE
			// elements: CLASSDEF, annotationPortion, sections, name, genealogyPortion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 141:85: -> ^( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? ( sections )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:88: ^( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? ( sections )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_CLASSDEF.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:99: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:125: ( genealogyPortion )?
				if ( stream_genealogyPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_genealogyPortion.nextTree());
				}
				stream_genealogyPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:141:145: ( sections )?
				if ( stream_sections.hasNext() ) {
					adaptor.addChild(root_1, stream_sections.nextTree());
				}
				stream_sections.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "classDef"


	public static class annotationPortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "annotationPortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:143:1: annotationPortion : LPAREN attributes RPAREN -> attributes ;
	public final MatlabParser.annotationPortion_return annotationPortion() throws RecognitionException {
		MatlabParser.annotationPortion_return retval = new MatlabParser.annotationPortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN88=null;
		Token RPAREN90=null;
		ParserRuleReturnScope attributes89 =null;

		Object LPAREN88_tree=null;
		Object RPAREN90_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_attributes=new RewriteRuleSubtreeStream(adaptor,"rule attributes");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:143:19: ( LPAREN attributes RPAREN -> attributes )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:143:21: LPAREN attributes RPAREN
			{
			LPAREN88=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_annotationPortion1285); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN88);

			pushFollow(FOLLOW_attributes_in_annotationPortion1287);
			attributes89=attributes();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_attributes.add(attributes89.getTree());
			RPAREN90=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_annotationPortion1289); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN90);

			// AST REWRITE
			// elements: attributes
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 143:46: -> attributes
			{
				adaptor.addChild(root_0, stream_attributes.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "annotationPortion"


	public static class attributes_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "attributes"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:1: attributes : attribute ( COMMA attribute )* -> ( attribute )+ ;
	public final MatlabParser.attributes_return attributes() throws RecognitionException {
		MatlabParser.attributes_return retval = new MatlabParser.attributes_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA92=null;
		ParserRuleReturnScope attribute91 =null;
		ParserRuleReturnScope attribute93 =null;

		Object COMMA92_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_attribute=new RewriteRuleSubtreeStream(adaptor,"rule attribute");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:12: ( attribute ( COMMA attribute )* -> ( attribute )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:14: attribute ( COMMA attribute )*
			{
			pushFollow(FOLLOW_attribute_in_attributes1302);
			attribute91=attribute();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_attribute.add(attribute91.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:24: ( COMMA attribute )*
			loop32:
			while (true) {
				int alt32=2;
				int LA32_0 = input.LA(1);
				if ( (LA32_0==COMMA) ) {
					alt32=1;
				}

				switch (alt32) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:145:25: COMMA attribute
					{
					COMMA92=(Token)match(input,COMMA,FOLLOW_COMMA_in_attributes1305); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA92);

					pushFollow(FOLLOW_attribute_in_attributes1307);
					attribute93=attribute();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_attribute.add(attribute93.getTree());
					}
					break;

				default :
					break loop32;
				}
			}

			// AST REWRITE
			// elements: attribute
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 145:43: -> ( attribute )+
			{
				if ( !(stream_attribute.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_attribute.hasNext() ) {
					adaptor.addChild(root_0, stream_attribute.nextTree());
				}
				stream_attribute.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "attributes"


	public static class attribute_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "attribute"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:1: attribute : ( NOT name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) ) | name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) ) | name ASSIGN expression -> ^( ATTRIBUTE[\"\"] name expression ) );
	public final MatlabParser.attribute_return attribute() throws RecognitionException {
		MatlabParser.attribute_return retval = new MatlabParser.attribute_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token NOT94=null;
		Token ASSIGN98=null;
		ParserRuleReturnScope name95 =null;
		ParserRuleReturnScope name96 =null;
		ParserRuleReturnScope name97 =null;
		ParserRuleReturnScope expression99 =null;

		Object NOT94_tree=null;
		Object ASSIGN98_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:11: ( NOT name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) ) | name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) ) | name ASSIGN expression -> ^( ATTRIBUTE[\"\"] name expression ) )
			int alt33=3;
			int LA33_0 = input.LA(1);
			if ( (LA33_0==NOT) ) {
				alt33=1;
			}
			else if ( (LA33_0==ID) ) {
				int LA33_2 = input.LA(2);
				if ( (LA33_2==COMMA||LA33_2==RPAREN) ) {
					alt33=2;
				}
				else if ( (LA33_2==ASSIGN) ) {
					alt33=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 33, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 33, 0, input);
				throw nvae;
			}

			switch (alt33) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:13: NOT name
					{
					NOT94=(Token)match(input,NOT,FOLLOW_NOT_in_attribute1325); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT94);

					pushFollow(FOLLOW_name_in_attribute1327);
					name95=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(name95.getTree());
					// AST REWRITE
					// elements: name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 147:22: -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:25: ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ATTRIBUTE, ""), root_1);
						adaptor.addChild(root_1, stream_name.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:46: ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_2);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:56: ^( NAME[\"\"] ^( ID[\"false\"] ) )
						{
						Object root_3 = (Object)adaptor.nil();
						root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_3);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:147:67: ^( ID[\"false\"] )
						{
						Object root_4 = (Object)adaptor.nil();
						root_4 = (Object)adaptor.becomeRoot((Object)adaptor.create(ID, "false"), root_4);
						adaptor.addChild(root_3, root_4);
						}

						adaptor.addChild(root_2, root_3);
						}

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:7: name
					{
					pushFollow(FOLLOW_name_in_attribute1359);
					name96=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(name96.getTree());
					// AST REWRITE
					// elements: name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 148:12: -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:15: ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ATTRIBUTE, ""), root_1);
						adaptor.addChild(root_1, stream_name.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:36: ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_2);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:46: ^( NAME[\"\"] ^( ID[\"true\"] ) )
						{
						Object root_3 = (Object)adaptor.nil();
						root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_3);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:148:57: ^( ID[\"true\"] )
						{
						Object root_4 = (Object)adaptor.nil();
						root_4 = (Object)adaptor.becomeRoot((Object)adaptor.create(ID, "true"), root_4);
						adaptor.addChild(root_3, root_4);
						}

						adaptor.addChild(root_2, root_3);
						}

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:149:13: name ASSIGN expression
					{
					pushFollow(FOLLOW_name_in_attribute1397);
					name97=name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_name.add(name97.getTree());
					ASSIGN98=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_attribute1399); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN98);

					pushFollow(FOLLOW_expression_in_attribute1401);
					expression99=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression99.getTree());
					// AST REWRITE
					// elements: expression, name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 149:36: -> ^( ATTRIBUTE[\"\"] name expression )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:149:39: ^( ATTRIBUTE[\"\"] name expression )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ATTRIBUTE, ""), root_1);
						adaptor.addChild(root_1, stream_name.nextTree());
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "attribute"


	public static class genealogyPortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "genealogyPortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:152:1: genealogyPortion : LT baseClasses -> baseClasses ;
	public final MatlabParser.genealogyPortion_return genealogyPortion() throws RecognitionException {
		MatlabParser.genealogyPortion_return retval = new MatlabParser.genealogyPortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LT100=null;
		ParserRuleReturnScope baseClasses101 =null;

		Object LT100_tree=null;
		RewriteRuleTokenStream stream_LT=new RewriteRuleTokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_baseClasses=new RewriteRuleSubtreeStream(adaptor,"rule baseClasses");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:152:18: ( LT baseClasses -> baseClasses )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:152:20: LT baseClasses
			{
			LT100=(Token)match(input,LT,FOLLOW_LT_in_genealogyPortion1425); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LT.add(LT100);

			pushFollow(FOLLOW_baseClasses_in_genealogyPortion1427);
			baseClasses101=baseClasses();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_baseClasses.add(baseClasses101.getTree());
			// AST REWRITE
			// elements: baseClasses
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 152:35: -> baseClasses
			{
				adaptor.addChild(root_0, stream_baseClasses.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "genealogyPortion"


	public static class baseClasses_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "baseClasses"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:1: baseClasses : classReference ( AND classReference )* -> ( classReference )+ ;
	public final MatlabParser.baseClasses_return baseClasses() throws RecognitionException {
		MatlabParser.baseClasses_return retval = new MatlabParser.baseClasses_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AND103=null;
		ParserRuleReturnScope classReference102 =null;
		ParserRuleReturnScope classReference104 =null;

		Object AND103_tree=null;
		RewriteRuleTokenStream stream_AND=new RewriteRuleTokenStream(adaptor,"token AND");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:13: ( classReference ( AND classReference )* -> ( classReference )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:15: classReference ( AND classReference )*
			{
			pushFollow(FOLLOW_classReference_in_baseClasses1440);
			classReference102=classReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classReference.add(classReference102.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:30: ( AND classReference )*
			loop34:
			while (true) {
				int alt34=2;
				int LA34_0 = input.LA(1);
				if ( (LA34_0==AND) ) {
					alt34=1;
				}

				switch (alt34) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:154:31: AND classReference
					{
					AND103=(Token)match(input,AND,FOLLOW_AND_in_baseClasses1443); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AND.add(AND103);

					pushFollow(FOLLOW_classReference_in_baseClasses1445);
					classReference104=classReference();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_classReference.add(classReference104.getTree());
					}
					break;

				default :
					break loop34;
				}
			}

			// AST REWRITE
			// elements: classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 154:52: -> ( classReference )+
			{
				if ( !(stream_classReference.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_classReference.hasNext() ) {
					adaptor.addChild(root_0, stream_classReference.nextTree());
				}
				stream_classReference.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "baseClasses"


	public static class classReference_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "classReference"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:156:1: classReference : fullClassName -> ^( CLASSREF[\"\"] fullClassName ) ;
	public final MatlabParser.classReference_return classReference() throws RecognitionException {
		MatlabParser.classReference_return retval = new MatlabParser.classReference_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope fullClassName105 =null;

		RewriteRuleSubtreeStream stream_fullClassName=new RewriteRuleSubtreeStream(adaptor,"rule fullClassName");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:156:16: ( fullClassName -> ^( CLASSREF[\"\"] fullClassName ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:156:18: fullClassName
			{
			pushFollow(FOLLOW_fullClassName_in_classReference1463);
			fullClassName105=fullClassName();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_fullClassName.add(fullClassName105.getTree());
			// AST REWRITE
			// elements: fullClassName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 156:32: -> ^( CLASSREF[\"\"] fullClassName )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:156:35: ^( CLASSREF[\"\"] fullClassName )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CLASSREF, ""), root_1);
				adaptor.addChild(root_1, stream_fullClassName.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "classReference"


	public static class fullClassName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "fullClassName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:1: fullClassName : xID ({...}? => DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) ;
	public final MatlabParser.fullClassName_return fullClassName() throws RecognitionException {
		MatlabParser.fullClassName_return retval = new MatlabParser.fullClassName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT107=null;
		ParserRuleReturnScope xID106 =null;
		ParserRuleReturnScope xANYID108 =null;

		Object DOT107_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_xANYID=new RewriteRuleSubtreeStream(adaptor,"rule xANYID");
		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:15: ( xID ({...}? => DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:17: xID ({...}? => DOT xANYID )*
			{
			pushFollow(FOLLOW_xID_in_fullClassName1481);
			xID106=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID106.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:21: ({...}? => DOT xANYID )*
			loop35:
			while (true) {
				int alt35=2;
				int LA35_0 = input.LA(1);
				if ( (LA35_0==DOT) && (((Chain_MayAddDotName())||(Chain_MayAddDotExpression())||(true)))) {
					int LA35_11 = input.LA(2);
					if ( (LA35_11==ID) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_13 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==BREAK) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_14 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==CASE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_15 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==CATCH) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_16 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==CLASSDEF) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_17 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==CONTINUE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_18 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==ELSE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_19 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==ELSEIF) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_20 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==END) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_21 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==FOR) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_22 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==FUNCTION) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_23 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==GLOBAL) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_24 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==IF) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_25 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==OTHERWISE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_26 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==PARFOR) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_27 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==PERSISTENT) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_28 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==RETURN) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_29 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==SPMD) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_30 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==SWITCH) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_31 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==TRY) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_32 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}
					else if ( (LA35_11==WHILE) && (((Chain_MayAddDotName())||(true)))) {
						int LA35_33 = input.LA(3);
						if ( ((true)) ) {
							alt35=1;
						}

					}

				}

				switch (alt35) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:22: {...}? => DOT xANYID
					{
					if ( !((true)) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "fullClassName", "true");
					}
					DOT107=(Token)match(input,DOT,FOLLOW_DOT_in_fullClassName1487); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DOT.add(DOT107);

					pushFollow(FOLLOW_xANYID_in_fullClassName1489);
					xANYID108=xANYID();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xANYID.add(xANYID108.getTree());
					}
					break;

				default :
					break loop35;
				}
			}

			// AST REWRITE
			// elements: xID, xANYID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 158:45: -> ^( NAME[\"\"] xID ( xANYID )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:48: ^( NAME[\"\"] xID ( xANYID )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:158:63: ( xANYID )*
				while ( stream_xANYID.hasNext() ) {
					adaptor.addChild(root_1, stream_xANYID.nextTree());
				}
				stream_xANYID.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "fullClassName"


	public static class sections_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sections"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:1: sections : ( section | xEOS )* -> ( section )* ;
	public final MatlabParser.sections_return sections() throws RecognitionException {
		MatlabParser.sections_return retval = new MatlabParser.sections_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope section109 =null;
		ParserRuleReturnScope xEOS110 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_section=new RewriteRuleSubtreeStream(adaptor,"rule section");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:10: ( ( section | xEOS )* -> ( section )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:12: ( section | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:12: ( section | xEOS )*
			loop36:
			while (true) {
				int alt36=3;
				int LA36_0 = input.LA(1);
				if ( (LA36_0==ID) && (((Keyword_EnumerationIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_EventsIdFollows())||(Keyword_MethodsIdFollows())))) {
					alt36=1;
				}
				else if ( (LA36_0==COMMA||LA36_0==EOL||LA36_0==SEMICOLON) ) {
					alt36=2;
				}

				switch (alt36) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:13: section
					{
					pushFollow(FOLLOW_section_in_sections1515);
					section109=section();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_section.add(section109.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:23: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_sections1519);
					xEOS110=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS110.getTree());
					}
					break;

				default :
					break loop36;
				}
			}

			// AST REWRITE
			// elements: section
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 160:30: -> ( section )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:160:33: ( section )*
				while ( stream_section.hasNext() ) {
					adaptor.addChild(root_0, stream_section.nextTree());
				}
				stream_section.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sections"


	public static class section_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "section"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:162:1: section : ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection );
	public final MatlabParser.section_return section() throws RecognitionException {
		MatlabParser.section_return retval = new MatlabParser.section_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope eventSection111 =null;
		ParserRuleReturnScope propertySection112 =null;
		ParserRuleReturnScope methodSection113 =null;
		ParserRuleReturnScope enumerationSection114 =null;

		RewriteRuleSubtreeStream stream_propertySection=new RewriteRuleSubtreeStream(adaptor,"rule propertySection");
		RewriteRuleSubtreeStream stream_methodSection=new RewriteRuleSubtreeStream(adaptor,"rule methodSection");
		RewriteRuleSubtreeStream stream_eventSection=new RewriteRuleSubtreeStream(adaptor,"rule eventSection");
		RewriteRuleSubtreeStream stream_enumerationSection=new RewriteRuleSubtreeStream(adaptor,"rule enumerationSection");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:162:9: ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection )
			int alt37=4;
			int LA37_0 = input.LA(1);
			if ( (LA37_0==ID) && (((Keyword_EnumerationIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_EventsIdFollows())||(Keyword_MethodsIdFollows())))) {
				int LA37_1 = input.LA(2);
				if ( ((Keyword_EventsIdFollows())) ) {
					alt37=1;
				}
				else if ( ((Keyword_PropertiesIdFollows())) ) {
					alt37=2;
				}
				else if ( ((Keyword_MethodsIdFollows())) ) {
					alt37=3;
				}
				else if ( ((Keyword_EnumerationIdFollows())) ) {
					alt37=4;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 37, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt37) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:162:11: eventSection
					{
					pushFollow(FOLLOW_eventSection_in_section1537);
					eventSection111=eventSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_eventSection.add(eventSection111.getTree());
					// AST REWRITE
					// elements: eventSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 162:24: -> eventSection
					{
						adaptor.addChild(root_0, stream_eventSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:163:5: propertySection
					{
					pushFollow(FOLLOW_propertySection_in_section1547);
					propertySection112=propertySection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_propertySection.add(propertySection112.getTree());
					// AST REWRITE
					// elements: propertySection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 163:21: -> propertySection
					{
						adaptor.addChild(root_0, stream_propertySection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:164:5: methodSection
					{
					pushFollow(FOLLOW_methodSection_in_section1557);
					methodSection113=methodSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodSection.add(methodSection113.getTree());
					// AST REWRITE
					// elements: methodSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 164:19: -> methodSection
					{
						adaptor.addChild(root_0, stream_methodSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:165:5: enumerationSection
					{
					pushFollow(FOLLOW_enumerationSection_in_section1567);
					enumerationSection114=enumerationSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_enumerationSection.add(enumerationSection114.getTree());
					// AST REWRITE
					// elements: enumerationSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 165:24: -> enumerationSection
					{
						adaptor.addChild(root_0, stream_enumerationSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "section"


	public static class eventSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "eventSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:1: eventSection : xEVENTS ( annotationPortion )? events END -> ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? ) ;
	public final MatlabParser.eventSection_return eventSection() throws RecognitionException {
		MatlabParser.eventSection_return retval = new MatlabParser.eventSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END118=null;
		ParserRuleReturnScope xEVENTS115 =null;
		ParserRuleReturnScope annotationPortion116 =null;
		ParserRuleReturnScope events117 =null;

		Object END118_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xEVENTS=new RewriteRuleSubtreeStream(adaptor,"rule xEVENTS");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_events=new RewriteRuleSubtreeStream(adaptor,"rule events");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:14: ( xEVENTS ( annotationPortion )? events END -> ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:16: xEVENTS ( annotationPortion )? events END
			{
			pushFollow(FOLLOW_xEVENTS_in_eventSection1584);
			xEVENTS115=xEVENTS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEVENTS.add(xEVENTS115.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:24: ( annotationPortion )?
			int alt38=2;
			int LA38_0 = input.LA(1);
			if ( (LA38_0==LPAREN) ) {
				alt38=1;
			}
			switch (alt38) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:25: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_eventSection1587);
					annotationPortion116=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion116.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_events_in_eventSection1591);
			events117=events();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_events.add(events117.getTree());
			END118=(Token)match(input,END,FOLLOW_END_in_eventSection1593); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END118);

			// AST REWRITE
			// elements: events, annotationPortion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 170:56: -> ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:59: ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENTSECTION, (xEVENTS115!=null?(xEVENTS115.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:90: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:170:111: ( events )?
				if ( stream_events.hasNext() ) {
					adaptor.addChild(root_1, stream_events.nextTree());
				}
				stream_events.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "eventSection"


	public static class events_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "events"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:1: events : ( event | xEOS )* -> ( event )* ;
	public final MatlabParser.events_return events() throws RecognitionException {
		MatlabParser.events_return retval = new MatlabParser.events_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope event119 =null;
		ParserRuleReturnScope xEOS120 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_event=new RewriteRuleSubtreeStream(adaptor,"rule event");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:8: ( ( event | xEOS )* -> ( event )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:10: ( event | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:10: ( event | xEOS )*
			loop39:
			while (true) {
				int alt39=3;
				int LA39_0 = input.LA(1);
				if ( (LA39_0==ID) ) {
					alt39=1;
				}
				else if ( (LA39_0==COMMA||LA39_0==EOL||LA39_0==SEMICOLON) ) {
					alt39=2;
				}

				switch (alt39) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:11: event
					{
					pushFollow(FOLLOW_event_in_events1620);
					event119=event();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_event.add(event119.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:19: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_events1624);
					xEOS120=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS120.getTree());
					}
					break;

				default :
					break loop39;
				}
			}

			// AST REWRITE
			// elements: event
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 172:26: -> ( event )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:172:29: ( event )*
				while ( stream_event.hasNext() ) {
					adaptor.addChild(root_0, stream_event.nextTree());
				}
				stream_event.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "events"


	public static class event_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "event"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:174:1: event : name xEOS -> ^( EVENT[\"\"] name ) ;
	public final MatlabParser.event_return event() throws RecognitionException {
		MatlabParser.event_return retval = new MatlabParser.event_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name121 =null;
		ParserRuleReturnScope xEOS122 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:174:7: ( name xEOS -> ^( EVENT[\"\"] name ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:174:9: name xEOS
			{
			pushFollow(FOLLOW_name_in_event1642);
			name121=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name121.getTree());
			pushFollow(FOLLOW_xEOS_in_event1644);
			xEOS122=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS122.getTree());
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 174:19: -> ^( EVENT[\"\"] name )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:174:22: ^( EVENT[\"\"] name )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENT, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "event"


	public static class propertySection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "propertySection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:1: propertySection : xPROPERTIES ( annotationPortion )? properties END -> ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? ) ;
	public final MatlabParser.propertySection_return propertySection() throws RecognitionException {
		MatlabParser.propertySection_return retval = new MatlabParser.propertySection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END126=null;
		ParserRuleReturnScope xPROPERTIES123 =null;
		ParserRuleReturnScope annotationPortion124 =null;
		ParserRuleReturnScope properties125 =null;

		Object END126_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xPROPERTIES=new RewriteRuleSubtreeStream(adaptor,"rule xPROPERTIES");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_properties=new RewriteRuleSubtreeStream(adaptor,"rule properties");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:17: ( xPROPERTIES ( annotationPortion )? properties END -> ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:19: xPROPERTIES ( annotationPortion )? properties END
			{
			pushFollow(FOLLOW_xPROPERTIES_in_propertySection1664);
			xPROPERTIES123=xPROPERTIES();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xPROPERTIES.add(xPROPERTIES123.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:31: ( annotationPortion )?
			int alt40=2;
			int LA40_0 = input.LA(1);
			if ( (LA40_0==LPAREN) ) {
				alt40=1;
			}
			switch (alt40) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:32: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_propertySection1667);
					annotationPortion124=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion124.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_properties_in_propertySection1671);
			properties125=properties();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_properties.add(properties125.getTree());
			END126=(Token)match(input,END,FOLLOW_END_in_propertySection1673); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END126);

			// AST REWRITE
			// elements: properties, annotationPortion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 178:67: -> ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:70: ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PROPERTYSECTION, (xPROPERTIES123!=null?(xPROPERTIES123.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:108: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:178:129: ( properties )?
				if ( stream_properties.hasNext() ) {
					adaptor.addChild(root_1, stream_properties.nextTree());
				}
				stream_properties.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "propertySection"


	public static class properties_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "properties"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:1: properties : ( property | xEOS )* -> ( property )* ;
	public final MatlabParser.properties_return properties() throws RecognitionException {
		MatlabParser.properties_return retval = new MatlabParser.properties_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope property127 =null;
		ParserRuleReturnScope xEOS128 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_property=new RewriteRuleSubtreeStream(adaptor,"rule property");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:12: ( ( property | xEOS )* -> ( property )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:14: ( property | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:14: ( property | xEOS )*
			loop41:
			while (true) {
				int alt41=3;
				int LA41_0 = input.LA(1);
				if ( (LA41_0==ID) ) {
					alt41=1;
				}
				else if ( (LA41_0==COMMA||LA41_0==EOL||LA41_0==SEMICOLON) ) {
					alt41=2;
				}

				switch (alt41) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:15: property
					{
					pushFollow(FOLLOW_property_in_properties1700);
					property127=property();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_property.add(property127.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:26: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_properties1704);
					xEOS128=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS128.getTree());
					}
					break;

				default :
					break loop41;
				}
			}

			// AST REWRITE
			// elements: property
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 180:33: -> ( property )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:180:36: ( property )*
				while ( stream_property.hasNext() ) {
					adaptor.addChild(root_0, stream_property.nextTree());
				}
				stream_property.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "properties"


	public static class property_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "property"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:1: property : name ( filter )? ( ASSIGN expression )? -> ^( PROPERTY[\"\"] name ( filter )? ( expression )? ) ;
	public final MatlabParser.property_return property() throws RecognitionException {
		MatlabParser.property_return retval = new MatlabParser.property_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASSIGN131=null;
		ParserRuleReturnScope name129 =null;
		ParserRuleReturnScope filter130 =null;
		ParserRuleReturnScope expression132 =null;

		Object ASSIGN131_tree=null;
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_filter=new RewriteRuleSubtreeStream(adaptor,"rule filter");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:10: ( name ( filter )? ( ASSIGN expression )? -> ^( PROPERTY[\"\"] name ( filter )? ( expression )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:12: name ( filter )? ( ASSIGN expression )?
			{
			pushFollow(FOLLOW_name_in_property1722);
			name129=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name129.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:17: ( filter )?
			int alt42=2;
			int LA42_0 = input.LA(1);
			if ( (LA42_0==AT) ) {
				alt42=1;
			}
			switch (alt42) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:18: filter
					{
					pushFollow(FOLLOW_filter_in_property1725);
					filter130=filter();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_filter.add(filter130.getTree());
					}
					break;

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:27: ( ASSIGN expression )?
			int alt43=2;
			int LA43_0 = input.LA(1);
			if ( (LA43_0==ASSIGN) ) {
				alt43=1;
			}
			switch (alt43) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:28: ASSIGN expression
					{
					ASSIGN131=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_property1730); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN131);

					pushFollow(FOLLOW_expression_in_property1732);
					expression132=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression132.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: filter, expression, name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 182:48: -> ^( PROPERTY[\"\"] name ( filter )? ( expression )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:51: ^( PROPERTY[\"\"] name ( filter )? ( expression )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PROPERTY, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:71: ( filter )?
				if ( stream_filter.hasNext() ) {
					adaptor.addChild(root_1, stream_filter.nextTree());
				}
				stream_filter.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:182:81: ( expression )?
				if ( stream_expression.hasNext() ) {
					adaptor.addChild(root_1, stream_expression.nextTree());
				}
				stream_expression.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "property"


	public static class methodSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:1: methodSection : xMETHODS ( annotationPortion )? methods END -> ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? ) ;
	public final MatlabParser.methodSection_return methodSection() throws RecognitionException {
		MatlabParser.methodSection_return retval = new MatlabParser.methodSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END136=null;
		ParserRuleReturnScope xMETHODS133 =null;
		ParserRuleReturnScope annotationPortion134 =null;
		ParserRuleReturnScope methods135 =null;

		Object END136_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xMETHODS=new RewriteRuleSubtreeStream(adaptor,"rule xMETHODS");
		RewriteRuleSubtreeStream stream_methods=new RewriteRuleSubtreeStream(adaptor,"rule methods");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:15: ( xMETHODS ( annotationPortion )? methods END -> ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:17: xMETHODS ( annotationPortion )? methods END
			{
			pushFollow(FOLLOW_xMETHODS_in_methodSection1764);
			xMETHODS133=xMETHODS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xMETHODS.add(xMETHODS133.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:26: ( annotationPortion )?
			int alt44=2;
			int LA44_0 = input.LA(1);
			if ( (LA44_0==LPAREN) ) {
				alt44=1;
			}
			switch (alt44) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:27: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_methodSection1767);
					annotationPortion134=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion134.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_methods_in_methodSection1771);
			methods135=methods();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_methods.add(methods135.getTree());
			END136=(Token)match(input,END,FOLLOW_END_in_methodSection1773); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END136);

			// AST REWRITE
			// elements: annotationPortion, methods
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 186:59: -> ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:62: ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(METHODSECTION, (xMETHODS133!=null?(xMETHODS133.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:95: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:186:116: ( methods )?
				if ( stream_methods.hasNext() ) {
					adaptor.addChild(root_1, stream_methods.nextTree());
				}
				stream_methods.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methodSection"


	public static class methods_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methods"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:1: methods : ( method | xEOS )* -> ( method )* ;
	public final MatlabParser.methods_return methods() throws RecognitionException {
		MatlabParser.methods_return retval = new MatlabParser.methods_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope method137 =null;
		ParserRuleReturnScope xEOS138 =null;

		RewriteRuleSubtreeStream stream_method=new RewriteRuleSubtreeStream(adaptor,"rule method");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:9: ( ( method | xEOS )* -> ( method )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:11: ( method | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:11: ( method | xEOS )*
			loop45:
			while (true) {
				int alt45=3;
				int LA45_0 = input.LA(1);
				if ( (LA45_0==FUNCTION||LA45_0==ID||LA45_0==LSQUARE) ) {
					alt45=1;
				}
				else if ( (LA45_0==COMMA||LA45_0==EOL||LA45_0==SEMICOLON) ) {
					alt45=2;
				}

				switch (alt45) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:12: method
					{
					pushFollow(FOLLOW_method_in_methods1800);
					method137=method();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_method.add(method137.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:21: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_methods1804);
					xEOS138=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS138.getTree());
					}
					break;

				default :
					break loop45;
				}
			}

			// AST REWRITE
			// elements: method
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 188:28: -> ( method )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:188:31: ( method )*
				while ( stream_method.hasNext() ) {
					adaptor.addChild(root_0, stream_method.nextTree());
				}
				stream_method.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methods"


	public static class method_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "method"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:190:1: method : ( regularMethod -> regularMethod | externalMethod -> externalMethod );
	public final MatlabParser.method_return method() throws RecognitionException {
		MatlabParser.method_return retval = new MatlabParser.method_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope regularMethod139 =null;
		ParserRuleReturnScope externalMethod140 =null;

		RewriteRuleSubtreeStream stream_externalMethod=new RewriteRuleSubtreeStream(adaptor,"rule externalMethod");
		RewriteRuleSubtreeStream stream_regularMethod=new RewriteRuleSubtreeStream(adaptor,"rule regularMethod");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:190:8: ( regularMethod -> regularMethod | externalMethod -> externalMethod )
			int alt46=2;
			int LA46_0 = input.LA(1);
			if ( (LA46_0==FUNCTION) ) {
				alt46=1;
			}
			else if ( (LA46_0==ID||LA46_0==LSQUARE) ) {
				alt46=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 46, 0, input);
				throw nvae;
			}

			switch (alt46) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:190:10: regularMethod
					{
					pushFollow(FOLLOW_regularMethod_in_method1822);
					regularMethod139=regularMethod();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_regularMethod.add(regularMethod139.getTree());
					// AST REWRITE
					// elements: regularMethod
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 190:24: -> regularMethod
					{
						adaptor.addChild(root_0, stream_regularMethod.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:191:7: externalMethod
					{
					pushFollow(FOLLOW_externalMethod_in_method1834);
					externalMethod140=externalMethod();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_externalMethod.add(externalMethod140.getTree());
					// AST REWRITE
					// elements: externalMethod
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 191:22: -> externalMethod
					{
						adaptor.addChild(root_0, stream_externalMethod.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "method"


	public static class regularMethod_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "regularMethod"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:1: regularMethod : FUNCTION methodSignature closeBody END -> ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? ) ;
	public final MatlabParser.regularMethod_return regularMethod() throws RecognitionException {
		MatlabParser.regularMethod_return retval = new MatlabParser.regularMethod_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION141=null;
		Token END144=null;
		ParserRuleReturnScope methodSignature142 =null;
		ParserRuleReturnScope closeBody143 =null;

		Object FUNCTION141_tree=null;
		Object END144_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_methodSignature=new RewriteRuleSubtreeStream(adaptor,"rule methodSignature");
		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:15: ( FUNCTION methodSignature closeBody END -> ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:17: FUNCTION methodSignature closeBody END
			{
			FUNCTION141=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_regularMethod1851); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION141);

			pushFollow(FOLLOW_methodSignature_in_regularMethod1853);
			methodSignature142=methodSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_methodSignature.add(methodSignature142.getTree());
			pushFollow(FOLLOW_closeBody_in_regularMethod1855);
			closeBody143=closeBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeBody.add(closeBody143.getTree());
			END144=(Token)match(input,END,FOLLOW_END_in_regularMethod1857); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END144);

			// AST REWRITE
			// elements: methodSignature, closeBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 194:56: -> ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:59: ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(REGULARMETHOD, FUNCTION141), root_1);
				adaptor.addChild(root_1, stream_methodSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:194:102: ( closeBody )?
				if ( stream_closeBody.hasNext() ) {
					adaptor.addChild(root_1, stream_closeBody.nextTree());
				}
				stream_closeBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "regularMethod"


	public static class methodSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:196:1: methodSignature : ( ( outputPortion )? methodName1 ( inputPortion )? -> ( outputPortion )? methodName1 ( inputPortion )? | outputPortion methodName2 ( inputPortion )? -> ( outputPortion )? methodName2 ( inputPortion )? | methodName3 ( inputPortion )? -> methodName3 ( inputPortion )? );
	public final MatlabParser.methodSignature_return methodSignature() throws RecognitionException {
		MatlabParser.methodSignature_return retval = new MatlabParser.methodSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope outputPortion145 =null;
		ParserRuleReturnScope methodName1146 =null;
		ParserRuleReturnScope inputPortion147 =null;
		ParserRuleReturnScope outputPortion148 =null;
		ParserRuleReturnScope methodName2149 =null;
		ParserRuleReturnScope inputPortion150 =null;
		ParserRuleReturnScope methodName3151 =null;
		ParserRuleReturnScope inputPortion152 =null;

		RewriteRuleSubtreeStream stream_methodName3=new RewriteRuleSubtreeStream(adaptor,"rule methodName3");
		RewriteRuleSubtreeStream stream_methodName2=new RewriteRuleSubtreeStream(adaptor,"rule methodName2");
		RewriteRuleSubtreeStream stream_methodName1=new RewriteRuleSubtreeStream(adaptor,"rule methodName1");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");
		RewriteRuleSubtreeStream stream_outputPortion=new RewriteRuleSubtreeStream(adaptor,"rule outputPortion");

		Method_EnterSignature();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:197:34: ( ( outputPortion )? methodName1 ( inputPortion )? -> ( outputPortion )? methodName1 ( inputPortion )? | outputPortion methodName2 ( inputPortion )? -> ( outputPortion )? methodName2 ( inputPortion )? | methodName3 ( inputPortion )? -> methodName3 ( inputPortion )? )
			int alt51=3;
			alt51 = dfa51.predict(input);
			switch (alt51) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:3: ( outputPortion )? methodName1 ( inputPortion )?
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:3: ( outputPortion )?
					int alt47=2;
					int LA47_0 = input.LA(1);
					if ( (LA47_0==ID) ) {
						int LA47_1 = input.LA(2);
						if ( (LA47_1==ASSIGN) ) {
							alt47=1;
						}
					}
					else if ( (LA47_0==LSQUARE) ) {
						alt47=1;
					}
					switch (alt47) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:4: outputPortion
							{
							pushFollow(FOLLOW_outputPortion_in_methodSignature1888);
							outputPortion145=outputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_outputPortion.add(outputPortion145.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_methodName1_in_methodSignature1892);
					methodName1146=methodName1();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodName1.add(methodName1146.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:32: ( inputPortion )?
					int alt48=2;
					int LA48_0 = input.LA(1);
					if ( (LA48_0==LPAREN) ) {
						alt48=1;
					}
					switch (alt48) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:33: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_methodSignature1895);
							inputPortion147=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion147.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: outputPortion, methodName1, inputPortion
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 198:48: -> ( outputPortion )? methodName1 ( inputPortion )?
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:51: ( outputPortion )?
						if ( stream_outputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_outputPortion.nextTree());
						}
						stream_outputPortion.reset();

						adaptor.addChild(root_0, stream_methodName1.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:198:80: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:3: outputPortion methodName2 ( inputPortion )?
					{
					pushFollow(FOLLOW_outputPortion_in_methodSignature1915);
					outputPortion148=outputPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_outputPortion.add(outputPortion148.getTree());
					pushFollow(FOLLOW_methodName2_in_methodSignature1917);
					methodName2149=methodName2();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodName2.add(methodName2149.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:29: ( inputPortion )?
					int alt49=2;
					int LA49_0 = input.LA(1);
					if ( (LA49_0==LPAREN) ) {
						alt49=1;
					}
					switch (alt49) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:30: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_methodSignature1920);
							inputPortion150=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion150.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: outputPortion, inputPortion, methodName2
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 199:45: -> ( outputPortion )? methodName2 ( inputPortion )?
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:48: ( outputPortion )?
						if ( stream_outputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_outputPortion.nextTree());
						}
						stream_outputPortion.reset();

						adaptor.addChild(root_0, stream_methodName2.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:199:77: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:200:3: methodName3 ( inputPortion )?
					{
					pushFollow(FOLLOW_methodName3_in_methodSignature1940);
					methodName3151=methodName3();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodName3.add(methodName3151.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:200:15: ( inputPortion )?
					int alt50=2;
					int LA50_0 = input.LA(1);
					if ( (LA50_0==LPAREN) ) {
						alt50=1;
					}
					switch (alt50) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:200:16: inputPortion
							{
							pushFollow(FOLLOW_inputPortion_in_methodSignature1943);
							inputPortion152=inputPortion();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion152.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: inputPortion, methodName3
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 200:31: -> methodName3 ( inputPortion )?
					{
						adaptor.addChild(root_0, stream_methodName3.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:200:46: ( inputPortion )?
						if ( stream_inputPortion.hasNext() ) {
							adaptor.addChild(root_0, stream_inputPortion.nextTree());
						}
						stream_inputPortion.reset();

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Method_ExitSignature();
		}
		return retval;
	}
	// $ANTLR end "methodSignature"


	public static class methodName1_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodName1"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:204:1: methodName1 : xID DOT xFUNCTIONID -> ^( NAME[\"\"] xID xFUNCTIONID ) ;
	public final MatlabParser.methodName1_return methodName1() throws RecognitionException {
		MatlabParser.methodName1_return retval = new MatlabParser.methodName1_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT154=null;
		ParserRuleReturnScope xID153 =null;
		ParserRuleReturnScope xFUNCTIONID155 =null;

		Object DOT154_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");
		RewriteRuleSubtreeStream stream_xFUNCTIONID=new RewriteRuleSubtreeStream(adaptor,"rule xFUNCTIONID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:204:13: ( xID DOT xFUNCTIONID -> ^( NAME[\"\"] xID xFUNCTIONID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:204:15: xID DOT xFUNCTIONID
			{
			pushFollow(FOLLOW_xID_in_methodName11967);
			xID153=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID153.getTree());
			DOT154=(Token)match(input,DOT,FOLLOW_DOT_in_methodName11969); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOT.add(DOT154);

			pushFollow(FOLLOW_xFUNCTIONID_in_methodName11971);
			xFUNCTIONID155=xFUNCTIONID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xFUNCTIONID.add(xFUNCTIONID155.getTree());
			// AST REWRITE
			// elements: xID, xFUNCTIONID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 204:35: -> ^( NAME[\"\"] xID xFUNCTIONID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:204:38: ^( NAME[\"\"] xID xFUNCTIONID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				adaptor.addChild(root_1, stream_xFUNCTIONID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methodName1"


	public static class methodName2_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodName2"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:206:1: methodName2 : xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) ;
	public final MatlabParser.methodName2_return methodName2() throws RecognitionException {
		MatlabParser.methodName2_return retval = new MatlabParser.methodName2_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xFUNCTIONID156 =null;

		RewriteRuleSubtreeStream stream_xFUNCTIONID=new RewriteRuleSubtreeStream(adaptor,"rule xFUNCTIONID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:206:13: ( xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:206:15: xFUNCTIONID
			{
			pushFollow(FOLLOW_xFUNCTIONID_in_methodName21991);
			xFUNCTIONID156=xFUNCTIONID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xFUNCTIONID.add(xFUNCTIONID156.getTree());
			// AST REWRITE
			// elements: xFUNCTIONID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 206:27: -> ^( NAME[\"\"] xFUNCTIONID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:206:30: ^( NAME[\"\"] xFUNCTIONID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xFUNCTIONID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methodName2"


	public static class methodName3_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "methodName3"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:208:1: methodName3 : xID -> ^( NAME[\"\"] xID ) ;
	public final MatlabParser.methodName3_return methodName3() throws RecognitionException {
		MatlabParser.methodName3_return retval = new MatlabParser.methodName3_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xID157 =null;

		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:208:13: ( xID -> ^( NAME[\"\"] xID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:208:15: xID
			{
			pushFollow(FOLLOW_xID_in_methodName32009);
			xID157=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID157.getTree());
			// AST REWRITE
			// elements: xID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 208:19: -> ^( NAME[\"\"] xID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:208:22: ^( NAME[\"\"] xID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "methodName3"


	public static class externalMethod_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "externalMethod"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:210:1: externalMethod : methodSignature xEOS -> ^( EXTERNALMETHOD[\"\"] methodSignature ) ;
	public final MatlabParser.externalMethod_return externalMethod() throws RecognitionException {
		MatlabParser.externalMethod_return retval = new MatlabParser.externalMethod_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope methodSignature158 =null;
		ParserRuleReturnScope xEOS159 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_methodSignature=new RewriteRuleSubtreeStream(adaptor,"rule methodSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:210:16: ( methodSignature xEOS -> ^( EXTERNALMETHOD[\"\"] methodSignature ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:210:18: methodSignature xEOS
			{
			pushFollow(FOLLOW_methodSignature_in_externalMethod2027);
			methodSignature158=methodSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_methodSignature.add(methodSignature158.getTree());
			pushFollow(FOLLOW_xEOS_in_externalMethod2029);
			xEOS159=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS159.getTree());
			// AST REWRITE
			// elements: methodSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 210:39: -> ^( EXTERNALMETHOD[\"\"] methodSignature )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:210:42: ^( EXTERNALMETHOD[\"\"] methodSignature )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXTERNALMETHOD, ""), root_1);
				adaptor.addChild(root_1, stream_methodSignature.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "externalMethod"


	public static class enumerationSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "enumerationSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:1: enumerationSection : xENUMERATION ( annotationPortion )? enumerations END -> ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? ) ;
	public final MatlabParser.enumerationSection_return enumerationSection() throws RecognitionException {
		MatlabParser.enumerationSection_return retval = new MatlabParser.enumerationSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END163=null;
		ParserRuleReturnScope xENUMERATION160 =null;
		ParserRuleReturnScope annotationPortion161 =null;
		ParserRuleReturnScope enumerations162 =null;

		Object END163_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_enumerations=new RewriteRuleSubtreeStream(adaptor,"rule enumerations");
		RewriteRuleSubtreeStream stream_xENUMERATION=new RewriteRuleSubtreeStream(adaptor,"rule xENUMERATION");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:20: ( xENUMERATION ( annotationPortion )? enumerations END -> ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:22: xENUMERATION ( annotationPortion )? enumerations END
			{
			pushFollow(FOLLOW_xENUMERATION_in_enumerationSection2049);
			xENUMERATION160=xENUMERATION();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xENUMERATION.add(xENUMERATION160.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:35: ( annotationPortion )?
			int alt52=2;
			int LA52_0 = input.LA(1);
			if ( (LA52_0==LPAREN) ) {
				alt52=1;
			}
			switch (alt52) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:36: annotationPortion
					{
					pushFollow(FOLLOW_annotationPortion_in_enumerationSection2052);
					annotationPortion161=annotationPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_annotationPortion.add(annotationPortion161.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_enumerations_in_enumerationSection2056);
			enumerations162=enumerations();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_enumerations.add(enumerations162.getTree());
			END163=(Token)match(input,END,FOLLOW_END_in_enumerationSection2058); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END163);

			// AST REWRITE
			// elements: enumerations, annotationPortion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 214:73: -> ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:76: ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ENUMERATIONSECTION, (xENUMERATION160!=null?(xENUMERATION160.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:118: ( annotationPortion )?
				if ( stream_annotationPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_annotationPortion.nextTree());
				}
				stream_annotationPortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:214:139: ( enumerations )?
				if ( stream_enumerations.hasNext() ) {
					adaptor.addChild(root_1, stream_enumerations.nextTree());
				}
				stream_enumerations.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumerationSection"


	public static class enumerations_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "enumerations"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:1: enumerations : ( enumeration | xEOS )* -> ( enumeration )* ;
	public final MatlabParser.enumerations_return enumerations() throws RecognitionException {
		MatlabParser.enumerations_return retval = new MatlabParser.enumerations_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope enumeration164 =null;
		ParserRuleReturnScope xEOS165 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_enumeration=new RewriteRuleSubtreeStream(adaptor,"rule enumeration");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:14: ( ( enumeration | xEOS )* -> ( enumeration )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:16: ( enumeration | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:16: ( enumeration | xEOS )*
			loop53:
			while (true) {
				int alt53=3;
				int LA53_0 = input.LA(1);
				if ( (LA53_0==ID) ) {
					alt53=1;
				}
				else if ( (LA53_0==COMMA||LA53_0==EOL||LA53_0==SEMICOLON) ) {
					alt53=2;
				}

				switch (alt53) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:17: enumeration
					{
					pushFollow(FOLLOW_enumeration_in_enumerations2085);
					enumeration164=enumeration();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_enumeration.add(enumeration164.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:31: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_enumerations2089);
					xEOS165=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS165.getTree());
					}
					break;

				default :
					break loop53;
				}
			}

			// AST REWRITE
			// elements: enumeration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 216:38: -> ( enumeration )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:216:41: ( enumeration )*
				while ( stream_enumeration.hasNext() ) {
					adaptor.addChild(root_0, stream_enumeration.nextTree());
				}
				stream_enumeration.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumerations"


	public static class enumeration_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "enumeration"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:1: enumeration : name ( call )? -> ^( ENUMERATION[\"\"] name ( call )? ) ;
	public final MatlabParser.enumeration_return enumeration() throws RecognitionException {
		MatlabParser.enumeration_return retval = new MatlabParser.enumeration_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name166 =null;
		ParserRuleReturnScope call167 =null;

		RewriteRuleSubtreeStream stream_call=new RewriteRuleSubtreeStream(adaptor,"rule call");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:13: ( name ( call )? -> ^( ENUMERATION[\"\"] name ( call )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:15: name ( call )?
			{
			pushFollow(FOLLOW_name_in_enumeration2107);
			name166=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name166.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:20: ( call )?
			int alt54=2;
			int LA54_0 = input.LA(1);
			if ( (LA54_0==LPAREN) ) {
				alt54=1;
			}
			switch (alt54) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:21: call
					{
					pushFollow(FOLLOW_call_in_enumeration2110);
					call167=call();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_call.add(call167.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: name, call
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 218:28: -> ^( ENUMERATION[\"\"] name ( call )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:31: ^( ENUMERATION[\"\"] name ( call )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ENUMERATION, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:218:54: ( call )?
				if ( stream_call.hasNext() ) {
					adaptor.addChild(root_1, stream_call.nextTree());
				}
				stream_call.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enumeration"


	public static class call_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "call"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:220:1: call : LPAREN ( expressions )? RPAREN -> ( expressions )? ;
	public final MatlabParser.call_return call() throws RecognitionException {
		MatlabParser.call_return retval = new MatlabParser.call_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN168=null;
		Token RPAREN170=null;
		ParserRuleReturnScope expressions169 =null;

		Object LPAREN168_tree=null;
		Object RPAREN170_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expressions=new RewriteRuleSubtreeStream(adaptor,"rule expressions");

		Balance_EnterParenthesis(); Index_EnterParenthesis();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:221:63: ( LPAREN ( expressions )? RPAREN -> ( expressions )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:222:1: LPAREN ( expressions )? RPAREN
			{
			LPAREN168=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_call2140); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN168);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:222:8: ( expressions )?
			int alt55=2;
			int LA55_0 = input.LA(1);
			if ( (LA55_0==ID||LA55_0==IMAGINARY||LA55_0==LCURLY||(LA55_0 >= LPAREN && LA55_0 <= LSQUARE)||LA55_0==MINUS||LA55_0==NOT||LA55_0==PLUS||LA55_0==REAL||LA55_0==STRING) ) {
				alt55=1;
			}
			else if ( (LA55_0==END) && ((Index_IsActive()))) {
				alt55=1;
			}
			else if ( (LA55_0==AT||LA55_0==QUESTION) ) {
				alt55=1;
			}
			switch (alt55) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:222:9: expressions
					{
					pushFollow(FOLLOW_expressions_in_call2143);
					expressions169=expressions();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expressions.add(expressions169.getTree());
					}
					break;

			}

			RPAREN170=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_call2147); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN170);

			// AST REWRITE
			// elements: expressions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 222:30: -> ( expressions )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:222:33: ( expressions )?
				if ( stream_expressions.hasNext() ) {
					adaptor.addChild(root_0, stream_expressions.nextTree());
				}
				stream_expressions.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Index_ExitParenthesis(); Balance_ExitParenthesis();
		}
		return retval;
	}
	// $ANTLR end "call"


	public static class expressions_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expressions"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:1: expressions : expression ( COMMA expression )* -> ( expression )+ ;
	public final MatlabParser.expressions_return expressions() throws RecognitionException {
		MatlabParser.expressions_return retval = new MatlabParser.expressions_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA172=null;
		ParserRuleReturnScope expression171 =null;
		ParserRuleReturnScope expression173 =null;

		Object COMMA172_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:13: ( expression ( COMMA expression )* -> ( expression )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:15: expression ( COMMA expression )*
			{
			pushFollow(FOLLOW_expression_in_expressions2167);
			expression171=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression171.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:26: ( COMMA expression )*
			loop56:
			while (true) {
				int alt56=2;
				int LA56_0 = input.LA(1);
				if ( (LA56_0==COMMA) ) {
					alt56=1;
				}

				switch (alt56) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:225:27: COMMA expression
					{
					COMMA172=(Token)match(input,COMMA,FOLLOW_COMMA_in_expressions2170); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA172);

					pushFollow(FOLLOW_expression_in_expressions2172);
					expression173=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression173.getTree());
					}
					break;

				default :
					break loop56;
				}
			}

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 225:46: -> ( expression )+
			{
				if ( !(stream_expression.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.hasNext() ) {
					adaptor.addChild(root_0, stream_expression.nextTree());
				}
				stream_expression.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expressions"


	public static class statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "statement"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:1: statement : ( ( assignment )=> assignment -> assignment | ( action )=> action -> action | ( simpleCommand )=> simpleCommand -> simpleCommand | ( abortCommand )=> abortCommand -> abortCommand | standardCommand -> standardCommand | bang -> bang | breakDef -> breakDef | continueDef -> continueDef | forDef -> forDef | global -> global | ifDef -> ifDef | parfor -> parfor | persistent -> persistent | returnDef -> returnDef | spmd -> spmd | switchDef -> switchDef | tryDef -> tryDef | whileDef -> whileDef );
	public final MatlabParser.statement_return statement() throws RecognitionException {
		MatlabParser.statement_return retval = new MatlabParser.statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope assignment174 =null;
		ParserRuleReturnScope action175 =null;
		ParserRuleReturnScope simpleCommand176 =null;
		ParserRuleReturnScope abortCommand177 =null;
		ParserRuleReturnScope standardCommand178 =null;
		ParserRuleReturnScope bang179 =null;
		ParserRuleReturnScope breakDef180 =null;
		ParserRuleReturnScope continueDef181 =null;
		ParserRuleReturnScope forDef182 =null;
		ParserRuleReturnScope global183 =null;
		ParserRuleReturnScope ifDef184 =null;
		ParserRuleReturnScope parfor185 =null;
		ParserRuleReturnScope persistent186 =null;
		ParserRuleReturnScope returnDef187 =null;
		ParserRuleReturnScope spmd188 =null;
		ParserRuleReturnScope switchDef189 =null;
		ParserRuleReturnScope tryDef190 =null;
		ParserRuleReturnScope whileDef191 =null;

		RewriteRuleSubtreeStream stream_spmd=new RewriteRuleSubtreeStream(adaptor,"rule spmd");
		RewriteRuleSubtreeStream stream_continueDef=new RewriteRuleSubtreeStream(adaptor,"rule continueDef");
		RewriteRuleSubtreeStream stream_forDef=new RewriteRuleSubtreeStream(adaptor,"rule forDef");
		RewriteRuleSubtreeStream stream_parfor=new RewriteRuleSubtreeStream(adaptor,"rule parfor");
		RewriteRuleSubtreeStream stream_assignment=new RewriteRuleSubtreeStream(adaptor,"rule assignment");
		RewriteRuleSubtreeStream stream_global=new RewriteRuleSubtreeStream(adaptor,"rule global");
		RewriteRuleSubtreeStream stream_abortCommand=new RewriteRuleSubtreeStream(adaptor,"rule abortCommand");
		RewriteRuleSubtreeStream stream_standardCommand=new RewriteRuleSubtreeStream(adaptor,"rule standardCommand");
		RewriteRuleSubtreeStream stream_whileDef=new RewriteRuleSubtreeStream(adaptor,"rule whileDef");
		RewriteRuleSubtreeStream stream_bang=new RewriteRuleSubtreeStream(adaptor,"rule bang");
		RewriteRuleSubtreeStream stream_returnDef=new RewriteRuleSubtreeStream(adaptor,"rule returnDef");
		RewriteRuleSubtreeStream stream_simpleCommand=new RewriteRuleSubtreeStream(adaptor,"rule simpleCommand");
		RewriteRuleSubtreeStream stream_action=new RewriteRuleSubtreeStream(adaptor,"rule action");
		RewriteRuleSubtreeStream stream_tryDef=new RewriteRuleSubtreeStream(adaptor,"rule tryDef");
		RewriteRuleSubtreeStream stream_persistent=new RewriteRuleSubtreeStream(adaptor,"rule persistent");
		RewriteRuleSubtreeStream stream_switchDef=new RewriteRuleSubtreeStream(adaptor,"rule switchDef");
		RewriteRuleSubtreeStream stream_breakDef=new RewriteRuleSubtreeStream(adaptor,"rule breakDef");
		RewriteRuleSubtreeStream stream_ifDef=new RewriteRuleSubtreeStream(adaptor,"rule ifDef");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:11: ( ( assignment )=> assignment -> assignment | ( action )=> action -> action | ( simpleCommand )=> simpleCommand -> simpleCommand | ( abortCommand )=> abortCommand -> abortCommand | standardCommand -> standardCommand | bang -> bang | breakDef -> breakDef | continueDef -> continueDef | forDef -> forDef | global -> global | ifDef -> ifDef | parfor -> parfor | persistent -> persistent | returnDef -> returnDef | spmd -> spmd | switchDef -> switchDef | tryDef -> tryDef | whileDef -> whileDef )
			int alt57=18;
			int LA57_0 = input.LA(1);
			if ( (LA57_0==ID) ) {
				int LA57_1 = input.LA(2);
				if ( ((synpred2_MatlabParser()&&(True()))) ) {
					alt57=1;
				}
				else if ( ((synpred3_MatlabParser()&&(True()))) ) {
					alt57=2;
				}
				else if ( ((synpred4_MatlabParser()&&(Command_IsEnabled()))) ) {
					alt57=3;
				}
				else if ( ((synpred5_MatlabParser()&&(Command_IsEnabled()))) ) {
					alt57=4;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 57, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA57_0==LSQUARE) ) {
				int LA57_2 = input.LA(2);
				if ( ((synpred2_MatlabParser()&&(True()))) ) {
					alt57=1;
				}
				else if ( ((synpred3_MatlabParser()&&(True()))) ) {
					alt57=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 57, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA57_0==PLUS) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==MINUS) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==NOT) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==REAL) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==IMAGINARY) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==STRING) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==LCURLY) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==LPAREN) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==END) && ((((Index_IsActive())&&synpred3_MatlabParser())&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==AT) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==QUESTION) && ((synpred3_MatlabParser()&&(True())))) {
				alt57=2;
			}
			else if ( (LA57_0==COMMAND) ) {
				alt57=5;
			}
			else if ( (LA57_0==EXCLAMATION) ) {
				alt57=6;
			}
			else if ( (LA57_0==BREAK) ) {
				alt57=7;
			}
			else if ( (LA57_0==CONTINUE) ) {
				alt57=8;
			}
			else if ( (LA57_0==FOR) ) {
				alt57=9;
			}
			else if ( (LA57_0==GLOBAL) ) {
				alt57=10;
			}
			else if ( (LA57_0==IF) ) {
				alt57=11;
			}
			else if ( (LA57_0==PARFOR) ) {
				alt57=12;
			}
			else if ( (LA57_0==PERSISTENT) ) {
				alt57=13;
			}
			else if ( (LA57_0==RETURN) ) {
				alt57=14;
			}
			else if ( (LA57_0==SPMD) ) {
				alt57=15;
			}
			else if ( (LA57_0==SWITCH) ) {
				alt57=16;
			}
			else if ( (LA57_0==TRY) ) {
				alt57=17;
			}
			else if ( (LA57_0==WHILE) ) {
				alt57=18;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 57, 0, input);
				throw nvae;
			}

			switch (alt57) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:13: ( assignment )=> assignment
					{
					pushFollow(FOLLOW_assignment_in_statement2197);
					assignment174=assignment();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_assignment.add(assignment174.getTree());
					// AST REWRITE
					// elements: assignment
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 229:39: -> assignment
					{
						adaptor.addChild(root_0, stream_assignment.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:230:13: ( action )=> action
					{
					pushFollow(FOLLOW_action_in_statement2220);
					action175=action();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_action.add(action175.getTree());
					// AST REWRITE
					// elements: action
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 230:31: -> action
					{
						adaptor.addChild(root_0, stream_action.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:231:7: ( simpleCommand )=> simpleCommand
					{
					pushFollow(FOLLOW_simpleCommand_in_statement2237);
					simpleCommand176=simpleCommand();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_simpleCommand.add(simpleCommand176.getTree());
					// AST REWRITE
					// elements: simpleCommand
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 231:39: -> simpleCommand
					{
						adaptor.addChild(root_0, stream_simpleCommand.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:232:7: ( abortCommand )=> abortCommand
					{
					pushFollow(FOLLOW_abortCommand_in_statement2254);
					abortCommand177=abortCommand();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_abortCommand.add(abortCommand177.getTree());
					// AST REWRITE
					// elements: abortCommand
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 232:37: -> abortCommand
					{
						adaptor.addChild(root_0, stream_abortCommand.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:233:7: standardCommand
					{
					pushFollow(FOLLOW_standardCommand_in_statement2266);
					standardCommand178=standardCommand();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_standardCommand.add(standardCommand178.getTree());
					// AST REWRITE
					// elements: standardCommand
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 233:23: -> standardCommand
					{
						adaptor.addChild(root_0, stream_standardCommand.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:234:7: bang
					{
					pushFollow(FOLLOW_bang_in_statement2278);
					bang179=bang();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_bang.add(bang179.getTree());
					// AST REWRITE
					// elements: bang
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 234:12: -> bang
					{
						adaptor.addChild(root_0, stream_bang.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:235:13: breakDef
					{
					pushFollow(FOLLOW_breakDef_in_statement2296);
					breakDef180=breakDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_breakDef.add(breakDef180.getTree());
					// AST REWRITE
					// elements: breakDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 235:22: -> breakDef
					{
						adaptor.addChild(root_0, stream_breakDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:236:13: continueDef
					{
					pushFollow(FOLLOW_continueDef_in_statement2314);
					continueDef181=continueDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_continueDef.add(continueDef181.getTree());
					// AST REWRITE
					// elements: continueDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 236:25: -> continueDef
					{
						adaptor.addChild(root_0, stream_continueDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:237:13: forDef
					{
					pushFollow(FOLLOW_forDef_in_statement2332);
					forDef182=forDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_forDef.add(forDef182.getTree());
					// AST REWRITE
					// elements: forDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 237:20: -> forDef
					{
						adaptor.addChild(root_0, stream_forDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:238:13: global
					{
					pushFollow(FOLLOW_global_in_statement2350);
					global183=global();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_global.add(global183.getTree());
					// AST REWRITE
					// elements: global
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 238:20: -> global
					{
						adaptor.addChild(root_0, stream_global.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:239:13: ifDef
					{
					pushFollow(FOLLOW_ifDef_in_statement2368);
					ifDef184=ifDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_ifDef.add(ifDef184.getTree());
					// AST REWRITE
					// elements: ifDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 239:19: -> ifDef
					{
						adaptor.addChild(root_0, stream_ifDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 12 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:240:13: parfor
					{
					pushFollow(FOLLOW_parfor_in_statement2386);
					parfor185=parfor();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parfor.add(parfor185.getTree());
					// AST REWRITE
					// elements: parfor
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 240:20: -> parfor
					{
						adaptor.addChild(root_0, stream_parfor.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 13 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:241:13: persistent
					{
					pushFollow(FOLLOW_persistent_in_statement2404);
					persistent186=persistent();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_persistent.add(persistent186.getTree());
					// AST REWRITE
					// elements: persistent
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 241:24: -> persistent
					{
						adaptor.addChild(root_0, stream_persistent.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 14 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:242:13: returnDef
					{
					pushFollow(FOLLOW_returnDef_in_statement2422);
					returnDef187=returnDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_returnDef.add(returnDef187.getTree());
					// AST REWRITE
					// elements: returnDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 242:23: -> returnDef
					{
						adaptor.addChild(root_0, stream_returnDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 15 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:243:7: spmd
					{
					pushFollow(FOLLOW_spmd_in_statement2434);
					spmd188=spmd();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_spmd.add(spmd188.getTree());
					// AST REWRITE
					// elements: spmd
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 243:12: -> spmd
					{
						adaptor.addChild(root_0, stream_spmd.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 16 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:244:13: switchDef
					{
					pushFollow(FOLLOW_switchDef_in_statement2452);
					switchDef189=switchDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_switchDef.add(switchDef189.getTree());
					// AST REWRITE
					// elements: switchDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 244:23: -> switchDef
					{
						adaptor.addChild(root_0, stream_switchDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 17 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:245:13: tryDef
					{
					pushFollow(FOLLOW_tryDef_in_statement2470);
					tryDef190=tryDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_tryDef.add(tryDef190.getTree());
					// AST REWRITE
					// elements: tryDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 245:20: -> tryDef
					{
						adaptor.addChild(root_0, stream_tryDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 18 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:246:13: whileDef
					{
					pushFollow(FOLLOW_whileDef_in_statement2488);
					whileDef191=whileDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_whileDef.add(whileDef191.getTree());
					// AST REWRITE
					// elements: whileDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 246:22: -> whileDef
					{
						adaptor.addChild(root_0, stream_whileDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "statement"


	public static class assignment_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "assignment"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:251:1: assignment :{...}? => assignmentCore -> assignmentCore ;
	public final MatlabParser.assignment_return assignment() throws RecognitionException {
		MatlabParser.assignment_return retval = new MatlabParser.assignment_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope assignmentCore192 =null;

		RewriteRuleSubtreeStream stream_assignmentCore=new RewriteRuleSubtreeStream(adaptor,"rule assignmentCore");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:251:12: ({...}? => assignmentCore -> assignmentCore )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:251:14: {...}? => assignmentCore
			{
			if ( !((True())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "assignment", "True()");
			}
			pushFollow(FOLLOW_assignmentCore_in_assignment2516);
			assignmentCore192=assignmentCore();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_assignmentCore.add(assignmentCore192.getTree());
			// AST REWRITE
			// elements: assignmentCore
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 251:41: -> assignmentCore
			{
				adaptor.addChild(root_0, stream_assignmentCore.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assignment"


	public static class assignmentCore_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "assignmentCore"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:253:1: assignmentCore : ( chain ASSIGN expression xEOS -> ^( ASSIGN chain expression xEOS ) | storage ASSIGN expression xEOS -> ^( ASSIGN storage expression xEOS ) );
	public final MatlabParser.assignmentCore_return assignmentCore() throws RecognitionException {
		MatlabParser.assignmentCore_return retval = new MatlabParser.assignmentCore_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASSIGN194=null;
		Token ASSIGN198=null;
		ParserRuleReturnScope chain193 =null;
		ParserRuleReturnScope expression195 =null;
		ParserRuleReturnScope xEOS196 =null;
		ParserRuleReturnScope storage197 =null;
		ParserRuleReturnScope expression199 =null;
		ParserRuleReturnScope xEOS200 =null;

		Object ASSIGN194_tree=null;
		Object ASSIGN198_tree=null;
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_chain=new RewriteRuleSubtreeStream(adaptor,"rule chain");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_storage=new RewriteRuleSubtreeStream(adaptor,"rule storage");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:253:16: ( chain ASSIGN expression xEOS -> ^( ASSIGN chain expression xEOS ) | storage ASSIGN expression xEOS -> ^( ASSIGN storage expression xEOS ) )
			int alt58=2;
			int LA58_0 = input.LA(1);
			if ( (LA58_0==ID) ) {
				alt58=1;
			}
			else if ( (LA58_0==LSQUARE) ) {
				alt58=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 58, 0, input);
				throw nvae;
			}

			switch (alt58) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:253:18: chain ASSIGN expression xEOS
					{
					pushFollow(FOLLOW_chain_in_assignmentCore2529);
					chain193=chain();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_chain.add(chain193.getTree());
					ASSIGN194=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentCore2531); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN194);

					pushFollow(FOLLOW_expression_in_assignmentCore2533);
					expression195=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression195.getTree());
					pushFollow(FOLLOW_xEOS_in_assignmentCore2535);
					xEOS196=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS196.getTree());
					// AST REWRITE
					// elements: xEOS, expression, chain, ASSIGN
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 253:47: -> ^( ASSIGN chain expression xEOS )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:253:50: ^( ASSIGN chain expression xEOS )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_ASSIGN.nextNode(), root_1);
						adaptor.addChild(root_1, stream_chain.nextTree());
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_1, stream_xEOS.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:254:9: storage ASSIGN expression xEOS
					{
					pushFollow(FOLLOW_storage_in_assignmentCore2557);
					storage197=storage();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_storage.add(storage197.getTree());
					ASSIGN198=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentCore2559); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN198);

					pushFollow(FOLLOW_expression_in_assignmentCore2561);
					expression199=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression199.getTree());
					pushFollow(FOLLOW_xEOS_in_assignmentCore2563);
					xEOS200=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS200.getTree());
					// AST REWRITE
					// elements: expression, xEOS, ASSIGN, storage
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 254:40: -> ^( ASSIGN storage expression xEOS )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:254:43: ^( ASSIGN storage expression xEOS )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_ASSIGN.nextNode(), root_1);
						adaptor.addChild(root_1, stream_storage.nextTree());
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_1, stream_xEOS.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "assignmentCore"


	public static class storage_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "storage"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:257:1: storage : LSQUARE ( COMMA )? slots ( COMMA )? RSQUARE -> ^( STORAGE[\"\"] slots ) ;
	public final MatlabParser.storage_return storage() throws RecognitionException {
		MatlabParser.storage_return retval = new MatlabParser.storage_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE201=null;
		Token COMMA202=null;
		Token COMMA204=null;
		Token RSQUARE205=null;
		ParserRuleReturnScope slots203 =null;

		Object LSQUARE201_tree=null;
		Object COMMA202_tree=null;
		Object COMMA204_tree=null;
		Object RSQUARE205_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_slots=new RewriteRuleSubtreeStream(adaptor,"rule slots");

		Balance_EnterStorageSquareBrace();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:258:44: ( LSQUARE ( COMMA )? slots ( COMMA )? RSQUARE -> ^( STORAGE[\"\"] slots ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:1: LSQUARE ( COMMA )? slots ( COMMA )? RSQUARE
			{
			LSQUARE201=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_storage2595); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE201);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:9: ( COMMA )?
			int alt59=2;
			int LA59_0 = input.LA(1);
			if ( (LA59_0==COMMA) ) {
				alt59=1;
			}
			switch (alt59) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:10: COMMA
					{
					COMMA202=(Token)match(input,COMMA,FOLLOW_COMMA_in_storage2598); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA202);

					}
					break;

			}

			pushFollow(FOLLOW_slots_in_storage2602);
			slots203=slots();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_slots.add(slots203.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:24: ( COMMA )?
			int alt60=2;
			int LA60_0 = input.LA(1);
			if ( (LA60_0==COMMA) ) {
				alt60=1;
			}
			switch (alt60) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:25: COMMA
					{
					COMMA204=(Token)match(input,COMMA,FOLLOW_COMMA_in_storage2605); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA204);

					}
					break;

			}

			RSQUARE205=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_storage2609); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE205);

			// AST REWRITE
			// elements: slots
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 259:41: -> ^( STORAGE[\"\"] slots )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:259:44: ^( STORAGE[\"\"] slots )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(STORAGE, ""), root_1);
				adaptor.addChild(root_1, stream_slots.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitStorageSquareBrace();
		}
		return retval;
	}
	// $ANTLR end "storage"


	public static class slots_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "slots"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:1: slots : slot ({...}? => ( COMMA )? slot )* -> ( slot )+ ;
	public final MatlabParser.slots_return slots() throws RecognitionException {
		MatlabParser.slots_return retval = new MatlabParser.slots_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA207=null;
		ParserRuleReturnScope slot206 =null;
		ParserRuleReturnScope slot208 =null;

		Object COMMA207_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_slot=new RewriteRuleSubtreeStream(adaptor,"rule slot");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:7: ( slot ({...}? => ( COMMA )? slot )* -> ( slot )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:9: slot ({...}? => ( COMMA )? slot )*
			{
			pushFollow(FOLLOW_slot_in_slots2631);
			slot206=slot();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_slot.add(slot206.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:14: ({...}? => ( COMMA )? slot )*
			loop62:
			while (true) {
				int alt62=2;
				int LA62_0 = input.LA(1);
				if ( (LA62_0==COMMA) ) {
					int LA62_1 = input.LA(2);
					if ( (LA62_1==ID||LA62_1==NOT||LA62_1==QUESTION) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
						alt62=1;
					}

				}
				else if ( (LA62_0==ID||LA62_0==NOT||LA62_0==QUESTION) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
					alt62=1;
				}

				switch (alt62) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:15: {...}? => ( COMMA )? slot
					{
					if ( !((Separator_CommaFollowsOrSpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "slots", "Separator_CommaFollowsOrSpacesPrecede()");
					}
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:60: ( COMMA )?
					int alt61=2;
					int LA61_0 = input.LA(1);
					if ( (LA61_0==COMMA) ) {
						alt61=1;
					}
					switch (alt61) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:262:61: COMMA
							{
							COMMA207=(Token)match(input,COMMA,FOLLOW_COMMA_in_slots2638); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA207);

							}
							break;

					}

					pushFollow(FOLLOW_slot_in_slots2642);
					slot208=slot();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_slot.add(slot208.getTree());
					}
					break;

				default :
					break loop62;
				}
			}

			// AST REWRITE
			// elements: slot
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 262:76: -> ( slot )+
			{
				if ( !(stream_slot.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_slot.hasNext() ) {
					adaptor.addChild(root_0, stream_slot.nextTree());
				}
				stream_slot.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "slots"


	public static class slot_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "slot"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:264:1: slot : ( chain -> chain | metaclass -> metaclass | NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) );
	public final MatlabParser.slot_return slot() throws RecognitionException {
		MatlabParser.slot_return retval = new MatlabParser.slot_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token NOT211=null;
		ParserRuleReturnScope chain209 =null;
		ParserRuleReturnScope metaclass210 =null;

		Object NOT211_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_chain=new RewriteRuleSubtreeStream(adaptor,"rule chain");
		RewriteRuleSubtreeStream stream_metaclass=new RewriteRuleSubtreeStream(adaptor,"rule metaclass");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:264:6: ( chain -> chain | metaclass -> metaclass | NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) )
			int alt63=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt63=1;
				}
				break;
			case QUESTION:
				{
				alt63=2;
				}
				break;
			case NOT:
				{
				alt63=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 63, 0, input);
				throw nvae;
			}
			switch (alt63) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:264:8: chain
					{
					pushFollow(FOLLOW_chain_in_slot2660);
					chain209=chain();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_chain.add(chain209.getTree());
					// AST REWRITE
					// elements: chain
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 264:14: -> chain
					{
						adaptor.addChild(root_0, stream_chain.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:265:5: metaclass
					{
					pushFollow(FOLLOW_metaclass_in_slot2670);
					metaclass210=metaclass();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_metaclass.add(metaclass210.getTree());
					// AST REWRITE
					// elements: metaclass
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 265:15: -> metaclass
					{
						adaptor.addChild(root_0, stream_metaclass.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:266:5: NOT
					{
					NOT211=(Token)match(input,NOT,FOLLOW_NOT_in_slot2680); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT211);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 266:9: -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:266:12: ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_1);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:266:22: ^( NAME[\"\"] ID[$NOT] )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_2);
						adaptor.addChild(root_2, (Object)adaptor.create(ID, NOT211));
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "slot"


	public static class action_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "action"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:271:1: action :{...}? => expression xEOS -> ^( ACTION[\"\"] expression xEOS ) ;
	public final MatlabParser.action_return action() throws RecognitionException {
		MatlabParser.action_return retval = new MatlabParser.action_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression212 =null;
		ParserRuleReturnScope xEOS213 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:271:8: ({...}? => expression xEOS -> ^( ACTION[\"\"] expression xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:271:10: {...}? => expression xEOS
			{
			if ( !((True())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "action", "True()");
			}
			pushFollow(FOLLOW_expression_in_action2711);
			expression212=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression212.getTree());
			pushFollow(FOLLOW_xEOS_in_action2713);
			xEOS213=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS213.getTree());
			// AST REWRITE
			// elements: xEOS, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 271:38: -> ^( ACTION[\"\"] expression xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:271:41: ^( ACTION[\"\"] expression xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ACTION, ""), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "action"


	public static class simpleCommand_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simpleCommand"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:1: simpleCommand :{...}? => var simpleTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS ) ;
	public final MatlabParser.simpleCommand_return simpleCommand() throws RecognitionException {
		MatlabParser.simpleCommand_return retval = new MatlabParser.simpleCommand_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope var214 =null;
		ParserRuleReturnScope simpleTexts215 =null;
		ParserRuleReturnScope xEOS216 =null;

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_simpleTexts=new RewriteRuleSubtreeStream(adaptor,"rule simpleTexts");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:15: ({...}? => var simpleTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:17: {...}? => var simpleTexts xEOS
			{
			if ( !((Command_IsEnabled())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "simpleCommand", "Command_IsEnabled()");
			}
			pushFollow(FOLLOW_var_in_simpleCommand2738);
			var214=var();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_var.add(var214.getTree());
			pushFollow(FOLLOW_simpleTexts_in_simpleCommand2740);
			simpleTexts215=simpleTexts();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_simpleTexts.add(simpleTexts215.getTree());
			pushFollow(FOLLOW_xEOS_in_simpleCommand2742);
			xEOS216=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS216.getTree());
			// AST REWRITE
			// elements: var, xEOS, simpleTexts
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 275:63: -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:66: ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ACTION, ""), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:275:79: ^( PARENTHESIS[\"\"] var simpleTexts )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(PARENTHESIS, ""), root_2);
				adaptor.addChild(root_2, stream_var.nextTree());
				adaptor.addChild(root_2, stream_simpleTexts.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simpleCommand"


	public static class simpleTexts_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simpleTexts"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:1: simpleTexts : simpleText ({...}? => simpleText )* -> ( simpleText )+ ;
	public final MatlabParser.simpleTexts_return simpleTexts() throws RecognitionException {
		MatlabParser.simpleTexts_return retval = new MatlabParser.simpleTexts_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope simpleText217 =null;
		ParserRuleReturnScope simpleText218 =null;

		RewriteRuleSubtreeStream stream_simpleText=new RewriteRuleSubtreeStream(adaptor,"rule simpleText");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:13: ( simpleText ({...}? => simpleText )* -> ( simpleText )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:15: simpleText ({...}? => simpleText )*
			{
			pushFollow(FOLLOW_simpleText_in_simpleTexts2769);
			simpleText217=simpleText();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_simpleText.add(simpleText217.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:26: ({...}? => simpleText )*
			loop64:
			while (true) {
				int alt64=2;
				int LA64_0 = input.LA(1);
				if ( ((LA64_0 >= AND && LA64_0 <= COLON)||(LA64_0 >= COMMAND && LA64_0 <= CONTINUE)||(LA64_0 >= DEFAULTBLOCK && LA64_0 <= END)||(LA64_0 >= EQ && LA64_0 <= IMG)||(LA64_0 >= LDIV && LA64_0 <= LINECOMMENT3)||(LA64_0 >= LT && LA64_0 <= QUESTION)||(LA64_0 >= RDIV && LA64_0 <= RETURN)||(LA64_0 >= SHORTAND && LA64_0 <= TIMES)||(LA64_0 >= TRY && LA64_0 <= VCAT)) && ((Separator_SpacesPrecede()))) {
					alt64=1;
				}

				switch (alt64) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:277:27: {...}? => simpleText
					{
					if ( !((Separator_SpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "simpleTexts", "Separator_SpacesPrecede()");
					}
					pushFollow(FOLLOW_simpleText_in_simpleTexts2775);
					simpleText218=simpleText();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_simpleText.add(simpleText218.getTree());
					}
					break;

				default :
					break loop64;
				}
			}

			// AST REWRITE
			// elements: simpleText
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 277:71: -> ( simpleText )+
			{
				if ( !(stream_simpleText.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_simpleText.hasNext() ) {
					adaptor.addChild(root_0, stream_simpleText.nextTree());
				}
				stream_simpleText.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simpleTexts"


	public static class simpleText_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simpleText"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:279:1: simpleText : (x1= simpleBlock ) ( options {greedy=true; } :{...}? =>x2= simpleBlock )* -> STRING[$x1.start, text] ;
	public final MatlabParser.simpleText_return simpleText() throws RecognitionException {
		MatlabParser.simpleText_return retval = new MatlabParser.simpleText_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_simpleBlock=new RewriteRuleSubtreeStream(adaptor,"rule simpleBlock");

		String text = null;
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:280:29: ( (x1= simpleBlock ) ( options {greedy=true; } :{...}? =>x2= simpleBlock )* -> STRING[$x1.start, text] )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:2: (x1= simpleBlock ) ( options {greedy=true; } :{...}? =>x2= simpleBlock )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:2: (x1= simpleBlock )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:2: x1= simpleBlock
			{
			pushFollow(FOLLOW_simpleBlock_in_simpleText2801);
			x1=simpleBlock();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_simpleBlock.add(x1.getTree());
			if ( state.backtracking==0 ) {text = (x1!=null?((MatlabParser.simpleBlock_return)x1).blockText:null);}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:42: ( options {greedy=true; } :{...}? =>x2= simpleBlock )*
			loop65:
			while (true) {
				int alt65=2;
				int LA65_0 = input.LA(1);
				if ( (LA65_0==STRING) ) {
					int LA65_1 = input.LA(2);
					if ( ((!Separator_SpacesPrecede())) ) {
						alt65=1;
					}

				}
				else if ( ((LA65_0 >= AND && LA65_0 <= COLON)||(LA65_0 >= COMMAND && LA65_0 <= CONTINUE)||(LA65_0 >= DEFAULTBLOCK && LA65_0 <= END)||(LA65_0 >= EQ && LA65_0 <= IMG)||(LA65_0 >= LDIV && LA65_0 <= LINECOMMENT3)||(LA65_0 >= LT && LA65_0 <= QUESTION)||(LA65_0 >= RDIV && LA65_0 <= RETURN)||(LA65_0 >= SHORTAND && LA65_0 <= START)||(LA65_0 >= STRINGBLOCK && LA65_0 <= TIMES)||(LA65_0 >= TRY && LA65_0 <= VCAT)) ) {
					int LA65_2 = input.LA(2);
					if ( ((!Separator_SpacesPrecede())) ) {
						alt65=1;
					}

				}

				switch (alt65) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:281:67: {...}? =>x2= simpleBlock
					{
					if ( !((!Separator_SpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "simpleText", "!Separator_SpacesPrecede()");
					}
					pushFollow(FOLLOW_simpleBlock_in_simpleText2820);
					x2=simpleBlock();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_simpleBlock.add(x2.getTree());
					if ( state.backtracking==0 ) {text += (x2!=null?((MatlabParser.simpleBlock_return)x2).blockText:null);}
					}
					break;

				default :
					break loop65;
				}
			}

			if ( state.backtracking==0 ) {text = Text_QuoteString(text);}
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 281:174: -> STRING[$x1.start, text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STRING, (x1!=null?(x1.start):null), text));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simpleText"


	public static class simpleBlock_return extends ParserRuleReturnScope {
		public String blockText = null;
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simpleBlock"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:283:1: simpleBlock returns [String blockText = null] : (x1= STRING |x2=~ ( COMMA | SEMICOLON | EOL | STRING | CTRANS | TRANS | QUOTATION | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY ) );
	public final MatlabParser.simpleBlock_return simpleBlock() throws RecognitionException {
		MatlabParser.simpleBlock_return retval = new MatlabParser.simpleBlock_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token x1=null;
		Token x2=null;

		Object x1_tree=null;
		Object x2_tree=null;

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:283:47: (x1= STRING |x2=~ ( COMMA | SEMICOLON | EOL | STRING | CTRANS | TRANS | QUOTATION | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY ) )
			int alt66=2;
			int LA66_0 = input.LA(1);
			if ( (LA66_0==STRING) ) {
				alt66=1;
			}
			else if ( ((LA66_0 >= AND && LA66_0 <= COLON)||(LA66_0 >= COMMAND && LA66_0 <= CONTINUE)||(LA66_0 >= DEFAULTBLOCK && LA66_0 <= END)||(LA66_0 >= EQ && LA66_0 <= IMG)||(LA66_0 >= LDIV && LA66_0 <= LINECOMMENT3)||(LA66_0 >= LT && LA66_0 <= QUESTION)||(LA66_0 >= RDIV && LA66_0 <= RETURN)||(LA66_0 >= SHORTAND && LA66_0 <= START)||(LA66_0 >= STRINGBLOCK && LA66_0 <= TIMES)||(LA66_0 >= TRY && LA66_0 <= VCAT)) ) {
				alt66=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 66, 0, input);
				throw nvae;
			}

			switch (alt66) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:284:3: x1= STRING
					{
					root_0 = (Object)adaptor.nil();


					x1=(Token)match(input,STRING,FOLLOW_STRING_in_simpleBlock2848); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					x1_tree = (Object)adaptor.create(x1);
					adaptor.addChild(root_0, x1_tree);
					}

					if ( state.backtracking==0 ) {retval.blockText = Text_UnquoteString((x1!=null?x1.getText():null));}
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:285:3: x2=~ ( COMMA | SEMICOLON | EOL | STRING | CTRANS | TRANS | QUOTATION | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY )
					{
					root_0 = (Object)adaptor.nil();


					x2=input.LT(1);
					if ( (input.LA(1) >= AND && input.LA(1) <= COLON)||(input.LA(1) >= COMMAND && input.LA(1) <= CONTINUE)||(input.LA(1) >= DEFAULTBLOCK && input.LA(1) <= END)||(input.LA(1) >= EQ && input.LA(1) <= IMG)||(input.LA(1) >= LDIV && input.LA(1) <= LINECOMMENT3)||(input.LA(1) >= LT && input.LA(1) <= QUESTION)||(input.LA(1) >= RDIV && input.LA(1) <= RETURN)||(input.LA(1) >= SHORTAND && input.LA(1) <= START)||(input.LA(1) >= STRINGBLOCK && input.LA(1) <= TIMES)||(input.LA(1) >= TRY && input.LA(1) <= VCAT) ) {
						input.consume();
						if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(x2));
						state.errorRecovery=false;
						state.failed=false;
					}
					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						throw mse;
					}
					if ( state.backtracking==0 ) {retval.blockText = (x2!=null?x2.getText():null);}
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simpleBlock"


	public static class abortCommand_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "abortCommand"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:290:1: abortCommand :{...}? => var -> ABORT ;
	public final MatlabParser.abortCommand_return abortCommand() throws RecognitionException {
		MatlabParser.abortCommand_return retval = new MatlabParser.abortCommand_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope var219 =null;

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:290:14: ({...}? => var -> ABORT )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:290:16: {...}? => var
			{
			if ( !((Command_IsEnabled())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "abortCommand", "Command_IsEnabled()");
			}
			if ( state.backtracking==0 ) {Command_Mark();}
			pushFollow(FOLLOW_var_in_abortCommand2926);
			var219=var();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_var.add(var219.getTree());
			if ( state.backtracking==0 ) {Command_Abort();}
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 290:82: -> ABORT
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ABORT, "ABORT"));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "abortCommand"


	public static class standardCommand_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standardCommand"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:1: standardCommand : COMMAND standardTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS ) ;
	public final MatlabParser.standardCommand_return standardCommand() throws RecognitionException {
		MatlabParser.standardCommand_return retval = new MatlabParser.standardCommand_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMAND220=null;
		ParserRuleReturnScope standardTexts221 =null;
		ParserRuleReturnScope xEOS222 =null;

		Object COMMAND220_tree=null;
		RewriteRuleTokenStream stream_COMMAND=new RewriteRuleTokenStream(adaptor,"token COMMAND");
		RewriteRuleSubtreeStream stream_standardTexts=new RewriteRuleSubtreeStream(adaptor,"rule standardTexts");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:17: ( COMMAND standardTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:19: COMMAND standardTexts xEOS
			{
			COMMAND220=(Token)match(input,COMMAND,FOLLOW_COMMAND_in_standardCommand2943); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMAND.add(COMMAND220);

			pushFollow(FOLLOW_standardTexts_in_standardCommand2945);
			standardTexts221=standardTexts();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_standardTexts.add(standardTexts221.getTree());
			pushFollow(FOLLOW_xEOS_in_standardCommand2947);
			xEOS222=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS222.getTree());
			// AST REWRITE
			// elements: xEOS, standardTexts
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 294:46: -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:49: ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ACTION, ""), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:62: ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(PARENTHESIS, ""), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:80: ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) )
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_3);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:294:90: ^( NAME[\"\"] ID[$COMMAND] )
				{
				Object root_4 = (Object)adaptor.nil();
				root_4 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_4);
				adaptor.addChild(root_4, (Object)adaptor.create(ID, COMMAND220));
				adaptor.addChild(root_3, root_4);
				}

				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_2, stream_standardTexts.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standardCommand"


	public static class standardTexts_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standardTexts"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:1: standardTexts : standardText ({...}? => standardText )* -> ( standardText )+ ;
	public final MatlabParser.standardTexts_return standardTexts() throws RecognitionException {
		MatlabParser.standardTexts_return retval = new MatlabParser.standardTexts_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope standardText223 =null;
		ParserRuleReturnScope standardText224 =null;

		RewriteRuleSubtreeStream stream_standardText=new RewriteRuleSubtreeStream(adaptor,"rule standardText");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:15: ( standardText ({...}? => standardText )* -> ( standardText )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:17: standardText ({...}? => standardText )*
			{
			pushFollow(FOLLOW_standardText_in_standardTexts2985);
			standardText223=standardText();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_standardText.add(standardText223.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:30: ({...}? => standardText )*
			loop67:
			while (true) {
				int alt67=2;
				int LA67_0 = input.LA(1);
				if ( (LA67_0==DEFAULTBLOCK||LA67_0==STRINGBLOCK) && ((Separator_SpacesPrecede()))) {
					alt67=1;
				}

				switch (alt67) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:296:31: {...}? => standardText
					{
					if ( !((Separator_SpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "standardTexts", "Separator_SpacesPrecede()");
					}
					pushFollow(FOLLOW_standardText_in_standardTexts2991);
					standardText224=standardText();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_standardText.add(standardText224.getTree());
					}
					break;

				default :
					break loop67;
				}
			}

			// AST REWRITE
			// elements: standardText
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 296:77: -> ( standardText )+
			{
				if ( !(stream_standardText.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_standardText.hasNext() ) {
					adaptor.addChild(root_0, stream_standardText.nextTree());
				}
				stream_standardText.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standardTexts"


	public static class standardText_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standardText"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:298:1: standardText : (x1= standardBlock ) ( options {greedy=true; } :{...}? =>x2= standardBlock )* -> STRING[$x1.start, text] ;
	public final MatlabParser.standardText_return standardText() throws RecognitionException {
		MatlabParser.standardText_return retval = new MatlabParser.standardText_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_standardBlock=new RewriteRuleSubtreeStream(adaptor,"rule standardBlock");

		String text = null;
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:299:29: ( (x1= standardBlock ) ( options {greedy=true; } :{...}? =>x2= standardBlock )* -> STRING[$x1.start, text] )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:2: (x1= standardBlock ) ( options {greedy=true; } :{...}? =>x2= standardBlock )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:2: (x1= standardBlock )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:2: x1= standardBlock
			{
			pushFollow(FOLLOW_standardBlock_in_standardText3017);
			x1=standardBlock();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_standardBlock.add(x1.getTree());
			if ( state.backtracking==0 ) {text = (x1!=null?((MatlabParser.standardBlock_return)x1).blockText:null);}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:44: ( options {greedy=true; } :{...}? =>x2= standardBlock )*
			loop68:
			while (true) {
				int alt68=2;
				int LA68_0 = input.LA(1);
				if ( (LA68_0==STRINGBLOCK) ) {
					int LA68_1 = input.LA(2);
					if ( ((!Separator_SpacesPrecede())) ) {
						alt68=1;
					}

				}
				else if ( (LA68_0==DEFAULTBLOCK) ) {
					int LA68_2 = input.LA(2);
					if ( ((!Separator_SpacesPrecede())) ) {
						alt68=1;
					}

				}

				switch (alt68) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:300:69: {...}? =>x2= standardBlock
					{
					if ( !((!Separator_SpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "standardText", "!Separator_SpacesPrecede()");
					}
					pushFollow(FOLLOW_standardBlock_in_standardText3036);
					x2=standardBlock();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_standardBlock.add(x2.getTree());
					if ( state.backtracking==0 ) {text += (x2!=null?((MatlabParser.standardBlock_return)x2).blockText:null);}
					}
					break;

				default :
					break loop68;
				}
			}

			if ( state.backtracking==0 ) {text = Text_QuoteString(text);}
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 300:178: -> STRING[$x1.start, text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STRING, (x1!=null?(x1.start):null), text));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standardText"


	public static class standardBlock_return extends ParserRuleReturnScope {
		public String blockText = null;
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standardBlock"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:302:1: standardBlock returns [String blockText = null] : (x1= STRINGBLOCK |x2= DEFAULTBLOCK );
	public final MatlabParser.standardBlock_return standardBlock() throws RecognitionException {
		MatlabParser.standardBlock_return retval = new MatlabParser.standardBlock_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token x1=null;
		Token x2=null;

		Object x1_tree=null;
		Object x2_tree=null;

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:302:49: (x1= STRINGBLOCK |x2= DEFAULTBLOCK )
			int alt69=2;
			int LA69_0 = input.LA(1);
			if ( (LA69_0==STRINGBLOCK) ) {
				alt69=1;
			}
			else if ( (LA69_0==DEFAULTBLOCK) ) {
				alt69=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 69, 0, input);
				throw nvae;
			}

			switch (alt69) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:303:4: x1= STRINGBLOCK
					{
					root_0 = (Object)adaptor.nil();


					x1=(Token)match(input,STRINGBLOCK,FOLLOW_STRINGBLOCK_in_standardBlock3065); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					x1_tree = (Object)adaptor.create(x1);
					adaptor.addChild(root_0, x1_tree);
					}

					if ( state.backtracking==0 ) {retval.blockText = Text_UnquoteString((x1!=null?x1.getText():null));}
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:304:4: x2= DEFAULTBLOCK
					{
					root_0 = (Object)adaptor.nil();


					x2=(Token)match(input,DEFAULTBLOCK,FOLLOW_DEFAULTBLOCK_in_standardBlock3074); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					x2_tree = (Object)adaptor.create(x2);
					adaptor.addChild(root_0, x2_tree);
					}

					if ( state.backtracking==0 ) {retval.blockText = (x2!=null?x2.getText():null);}
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standardBlock"


	public static class bang_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "bang"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:309:1: bang : EXCLAMATION LINE xEOL -> ^( EXCLAMATION STRING[$LINE, line] xEOL ) ;
	public final MatlabParser.bang_return bang() throws RecognitionException {
		MatlabParser.bang_return retval = new MatlabParser.bang_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EXCLAMATION225=null;
		Token LINE226=null;
		ParserRuleReturnScope xEOL227 =null;

		Object EXCLAMATION225_tree=null;
		Object LINE226_tree=null;
		RewriteRuleTokenStream stream_EXCLAMATION=new RewriteRuleTokenStream(adaptor,"token EXCLAMATION");
		RewriteRuleTokenStream stream_LINE=new RewriteRuleTokenStream(adaptor,"token LINE");
		RewriteRuleSubtreeStream stream_xEOL=new RewriteRuleSubtreeStream(adaptor,"rule xEOL");

		String line = null;
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:310:29: ( EXCLAMATION LINE xEOL -> ^( EXCLAMATION STRING[$LINE, line] xEOL ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:311:1: EXCLAMATION LINE xEOL
			{
			EXCLAMATION225=(Token)match(input,EXCLAMATION,FOLLOW_EXCLAMATION_in_bang3093); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EXCLAMATION.add(EXCLAMATION225);

			LINE226=(Token)match(input,LINE,FOLLOW_LINE_in_bang3095); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LINE.add(LINE226);

			if ( state.backtracking==0 ) {line = Text_QuoteString((LINE226!=null?LINE226.getText():null));}
			pushFollow(FOLLOW_xEOL_in_bang3099);
			xEOL227=xEOL();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOL.add(xEOL227.getTree());
			// AST REWRITE
			// elements: xEOL, EXCLAMATION
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 311:62: -> ^( EXCLAMATION STRING[$LINE, line] xEOL )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:311:65: ^( EXCLAMATION STRING[$LINE, line] xEOL )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_EXCLAMATION.nextNode(), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(STRING, LINE226, line));
				adaptor.addChild(root_1, stream_xEOL.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "bang"


	public static class breakDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "breakDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:315:1: breakDef : BREAK xEOS -> ^( BREAK xEOS ) ;
	public final MatlabParser.breakDef_return breakDef() throws RecognitionException {
		MatlabParser.breakDef_return retval = new MatlabParser.breakDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token BREAK228=null;
		ParserRuleReturnScope xEOS229 =null;

		Object BREAK228_tree=null;
		RewriteRuleTokenStream stream_BREAK=new RewriteRuleTokenStream(adaptor,"token BREAK");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:315:10: ( BREAK xEOS -> ^( BREAK xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:315:12: BREAK xEOS
			{
			BREAK228=(Token)match(input,BREAK,FOLLOW_BREAK_in_breakDef3121); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_BREAK.add(BREAK228);

			pushFollow(FOLLOW_xEOS_in_breakDef3123);
			xEOS229=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS229.getTree());
			// AST REWRITE
			// elements: BREAK, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 315:23: -> ^( BREAK xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:315:26: ^( BREAK xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_BREAK.nextNode(), root_1);
				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "breakDef"


	public static class continueDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "continueDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:319:1: continueDef : CONTINUE xEOS -> ^( CONTINUE xEOS ) ;
	public final MatlabParser.continueDef_return continueDef() throws RecognitionException {
		MatlabParser.continueDef_return retval = new MatlabParser.continueDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CONTINUE230=null;
		ParserRuleReturnScope xEOS231 =null;

		Object CONTINUE230_tree=null;
		RewriteRuleTokenStream stream_CONTINUE=new RewriteRuleTokenStream(adaptor,"token CONTINUE");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:319:13: ( CONTINUE xEOS -> ^( CONTINUE xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:319:15: CONTINUE xEOS
			{
			CONTINUE230=(Token)match(input,CONTINUE,FOLLOW_CONTINUE_in_continueDef3142); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CONTINUE.add(CONTINUE230);

			pushFollow(FOLLOW_xEOS_in_continueDef3144);
			xEOS231=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS231.getTree());
			// AST REWRITE
			// elements: CONTINUE, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 319:29: -> ^( CONTINUE xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:319:32: ^( CONTINUE xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_CONTINUE.nextNode(), root_1);
				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "continueDef"


	public static class forDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "forDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:1: forDef : FOR forHead statements END xEOS -> ^( FOR forHead ( statements )? xEOS ) ;
	public final MatlabParser.forDef_return forDef() throws RecognitionException {
		MatlabParser.forDef_return retval = new MatlabParser.forDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FOR232=null;
		Token END235=null;
		ParserRuleReturnScope forHead233 =null;
		ParserRuleReturnScope statements234 =null;
		ParserRuleReturnScope xEOS236 =null;

		Object FOR232_tree=null;
		Object END235_tree=null;
		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,"token FOR");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_forHead=new RewriteRuleSubtreeStream(adaptor,"rule forHead");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:8: ( FOR forHead statements END xEOS -> ^( FOR forHead ( statements )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:10: FOR forHead statements END xEOS
			{
			FOR232=(Token)match(input,FOR,FOLLOW_FOR_in_forDef3163); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FOR.add(FOR232);

			pushFollow(FOLLOW_forHead_in_forDef3165);
			forHead233=forHead();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_forHead.add(forHead233.getTree());
			pushFollow(FOLLOW_statements_in_forDef3167);
			statements234=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements234.getTree());
			END235=(Token)match(input,END,FOLLOW_END_in_forDef3169); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END235);

			pushFollow(FOLLOW_xEOS_in_forDef3171);
			xEOS236=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS236.getTree());
			// AST REWRITE
			// elements: forHead, xEOS, FOR, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 323:42: -> ^( FOR forHead ( statements )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:45: ^( FOR forHead ( statements )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_FOR.nextNode(), root_1);
				adaptor.addChild(root_1, stream_forHead.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:323:59: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "forDef"


	public static class forHead_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "forHead"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:325:1: forHead : ( var ASSIGN expression -> var expression | LPAREN var ASSIGN expression RPAREN -> var expression );
	public final MatlabParser.forHead_return forHead() throws RecognitionException {
		MatlabParser.forHead_return retval = new MatlabParser.forHead_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASSIGN238=null;
		Token LPAREN240=null;
		Token ASSIGN242=null;
		Token RPAREN244=null;
		ParserRuleReturnScope var237 =null;
		ParserRuleReturnScope expression239 =null;
		ParserRuleReturnScope var241 =null;
		ParserRuleReturnScope expression243 =null;

		Object ASSIGN238_tree=null;
		Object LPAREN240_tree=null;
		Object ASSIGN242_tree=null;
		Object RPAREN244_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:325:9: ( var ASSIGN expression -> var expression | LPAREN var ASSIGN expression RPAREN -> var expression )
			int alt70=2;
			int LA70_0 = input.LA(1);
			if ( (LA70_0==ID) ) {
				alt70=1;
			}
			else if ( (LA70_0==LPAREN) ) {
				alt70=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 70, 0, input);
				throw nvae;
			}

			switch (alt70) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:325:11: var ASSIGN expression
					{
					pushFollow(FOLLOW_var_in_forHead3195);
					var237=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var237.getTree());
					ASSIGN238=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_forHead3197); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN238);

					pushFollow(FOLLOW_expression_in_forHead3199);
					expression239=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression239.getTree());
					// AST REWRITE
					// elements: expression, var
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 325:33: -> var expression
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:326:5: LPAREN var ASSIGN expression RPAREN
					{
					LPAREN240=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_forHead3211); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN240);

					pushFollow(FOLLOW_var_in_forHead3213);
					var241=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var241.getTree());
					ASSIGN242=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_forHead3215); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN242);

					pushFollow(FOLLOW_expression_in_forHead3217);
					expression243=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression243.getTree());
					RPAREN244=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_forHead3219); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN244);

					// AST REWRITE
					// elements: var, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 326:41: -> var expression
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "forHead"


	public static class global_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "global"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:1: global : GLOBAL ( var )+ xEOS -> ^( GLOBAL ( var )+ xEOS ) ;
	public final MatlabParser.global_return global() throws RecognitionException {
		MatlabParser.global_return retval = new MatlabParser.global_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token GLOBAL245=null;
		ParserRuleReturnScope var246 =null;
		ParserRuleReturnScope xEOS247 =null;

		Object GLOBAL245_tree=null;
		RewriteRuleTokenStream stream_GLOBAL=new RewriteRuleTokenStream(adaptor,"token GLOBAL");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:8: ( GLOBAL ( var )+ xEOS -> ^( GLOBAL ( var )+ xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:10: GLOBAL ( var )+ xEOS
			{
			GLOBAL245=(Token)match(input,GLOBAL,FOLLOW_GLOBAL_in_global3238); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_GLOBAL.add(GLOBAL245);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:17: ( var )+
			int cnt71=0;
			loop71:
			while (true) {
				int alt71=2;
				int LA71_0 = input.LA(1);
				if ( (LA71_0==ID) ) {
					alt71=1;
				}

				switch (alt71) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:18: var
					{
					pushFollow(FOLLOW_var_in_global3241);
					var246=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var246.getTree());
					}
					break;

				default :
					if ( cnt71 >= 1 ) break loop71;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(71, input);
					throw eee;
				}
				cnt71++;
			}

			pushFollow(FOLLOW_xEOS_in_global3245);
			xEOS247=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS247.getTree());
			// AST REWRITE
			// elements: var, GLOBAL, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 331:29: -> ^( GLOBAL ( var )+ xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:331:32: ^( GLOBAL ( var )+ xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_GLOBAL.nextNode(), root_1);
				if ( !(stream_var.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_var.hasNext() ) {
					adaptor.addChild(root_1, stream_var.nextTree());
				}
				stream_var.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "global"


	public static class ifDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ifDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:1: ifDef : ifPart ( elseIfPart )* ( elsePart )? END xEOS -> ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS ) ;
	public final MatlabParser.ifDef_return ifDef() throws RecognitionException {
		MatlabParser.ifDef_return retval = new MatlabParser.ifDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END251=null;
		ParserRuleReturnScope ifPart248 =null;
		ParserRuleReturnScope elseIfPart249 =null;
		ParserRuleReturnScope elsePart250 =null;
		ParserRuleReturnScope xEOS252 =null;

		Object END251_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_ifPart=new RewriteRuleSubtreeStream(adaptor,"rule ifPart");
		RewriteRuleSubtreeStream stream_elseIfPart=new RewriteRuleSubtreeStream(adaptor,"rule elseIfPart");
		RewriteRuleSubtreeStream stream_elsePart=new RewriteRuleSubtreeStream(adaptor,"rule elsePart");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:7: ( ifPart ( elseIfPart )* ( elsePart )? END xEOS -> ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:9: ifPart ( elseIfPart )* ( elsePart )? END xEOS
			{
			pushFollow(FOLLOW_ifPart_in_ifDef3269);
			ifPart248=ifPart();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_ifPart.add(ifPart248.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:16: ( elseIfPart )*
			loop72:
			while (true) {
				int alt72=2;
				int LA72_0 = input.LA(1);
				if ( (LA72_0==ELSEIF) ) {
					alt72=1;
				}

				switch (alt72) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:17: elseIfPart
					{
					pushFollow(FOLLOW_elseIfPart_in_ifDef3272);
					elseIfPart249=elseIfPart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_elseIfPart.add(elseIfPart249.getTree());
					}
					break;

				default :
					break loop72;
				}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:30: ( elsePart )?
			int alt73=2;
			int LA73_0 = input.LA(1);
			if ( (LA73_0==ELSE) ) {
				alt73=1;
			}
			switch (alt73) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:31: elsePart
					{
					pushFollow(FOLLOW_elsePart_in_ifDef3277);
					elsePart250=elsePart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_elsePart.add(elsePart250.getTree());
					}
					break;

			}

			END251=(Token)match(input,END,FOLLOW_END_in_ifDef3281); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END251);

			pushFollow(FOLLOW_xEOS_in_ifDef3283);
			xEOS252=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS252.getTree());
			// AST REWRITE
			// elements: xEOS, ifPart, elsePart, elseIfPart
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 335:51: -> ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:54: ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IFELSE, (ifPart248!=null?(ifPart248.start):null)), root_1);
				adaptor.addChild(root_1, stream_ifPart.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:85: ( elseIfPart )*
				while ( stream_elseIfPart.hasNext() ) {
					adaptor.addChild(root_1, stream_elseIfPart.nextTree());
				}
				stream_elseIfPart.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:335:99: ( elsePart )?
				if ( stream_elsePart.hasNext() ) {
					adaptor.addChild(root_1, stream_elsePart.nextTree());
				}
				stream_elsePart.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ifDef"


	public static class ifPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ifPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:1: ifPart : IF expression statements -> ^( IF expression ( statements )? ) ;
	public final MatlabParser.ifPart_return ifPart() throws RecognitionException {
		MatlabParser.ifPart_return retval = new MatlabParser.ifPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token IF253=null;
		ParserRuleReturnScope expression254 =null;
		ParserRuleReturnScope statements255 =null;

		Object IF253_tree=null;
		RewriteRuleTokenStream stream_IF=new RewriteRuleTokenStream(adaptor,"token IF");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:8: ( IF expression statements -> ^( IF expression ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:10: IF expression statements
			{
			IF253=(Token)match(input,IF,FOLLOW_IF_in_ifPart3313); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_IF.add(IF253);

			pushFollow(FOLLOW_expression_in_ifPart3315);
			expression254=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression254.getTree());
			pushFollow(FOLLOW_statements_in_ifPart3317);
			statements255=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements255.getTree());
			// AST REWRITE
			// elements: IF, expression, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 337:35: -> ^( IF expression ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:38: ^( IF expression ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_IF.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:337:54: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ifPart"


	public static class elseIfPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "elseIfPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:1: elseIfPart : ELSEIF expression statements -> ^( ELSEIF expression ( statements )? ) ;
	public final MatlabParser.elseIfPart_return elseIfPart() throws RecognitionException {
		MatlabParser.elseIfPart_return retval = new MatlabParser.elseIfPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ELSEIF256=null;
		ParserRuleReturnScope expression257 =null;
		ParserRuleReturnScope statements258 =null;

		Object ELSEIF256_tree=null;
		RewriteRuleTokenStream stream_ELSEIF=new RewriteRuleTokenStream(adaptor,"token ELSEIF");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:12: ( ELSEIF expression statements -> ^( ELSEIF expression ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:14: ELSEIF expression statements
			{
			ELSEIF256=(Token)match(input,ELSEIF,FOLLOW_ELSEIF_in_elseIfPart3339); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ELSEIF.add(ELSEIF256);

			pushFollow(FOLLOW_expression_in_elseIfPart3341);
			expression257=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression257.getTree());
			pushFollow(FOLLOW_statements_in_elseIfPart3343);
			statements258=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements258.getTree());
			// AST REWRITE
			// elements: expression, statements, ELSEIF
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 339:43: -> ^( ELSEIF expression ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:46: ^( ELSEIF expression ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_ELSEIF.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:339:66: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "elseIfPart"


	public static class elsePart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "elsePart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:1: elsePart : ELSE statements -> ^( ELSE ( statements )? ) ;
	public final MatlabParser.elsePart_return elsePart() throws RecognitionException {
		MatlabParser.elsePart_return retval = new MatlabParser.elsePart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ELSE259=null;
		ParserRuleReturnScope statements260 =null;

		Object ELSE259_tree=null;
		RewriteRuleTokenStream stream_ELSE=new RewriteRuleTokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:10: ( ELSE statements -> ^( ELSE ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:12: ELSE statements
			{
			ELSE259=(Token)match(input,ELSE,FOLLOW_ELSE_in_elsePart3365); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ELSE.add(ELSE259);

			pushFollow(FOLLOW_statements_in_elsePart3367);
			statements260=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements260.getTree());
			// AST REWRITE
			// elements: ELSE, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 341:28: -> ^( ELSE ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:31: ^( ELSE ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_ELSE.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:341:38: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "elsePart"


	public static class parfor_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parfor"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:1: parfor : PARFOR parforHead statements END xEOS -> ^( PARFOR parforHead ( statements )? xEOS ) ;
	public final MatlabParser.parfor_return parfor() throws RecognitionException {
		MatlabParser.parfor_return retval = new MatlabParser.parfor_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PARFOR261=null;
		Token END264=null;
		ParserRuleReturnScope parforHead262 =null;
		ParserRuleReturnScope statements263 =null;
		ParserRuleReturnScope xEOS265 =null;

		Object PARFOR261_tree=null;
		Object END264_tree=null;
		RewriteRuleTokenStream stream_PARFOR=new RewriteRuleTokenStream(adaptor,"token PARFOR");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_parforHead=new RewriteRuleSubtreeStream(adaptor,"rule parforHead");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:8: ( PARFOR parforHead statements END xEOS -> ^( PARFOR parforHead ( statements )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:10: PARFOR parforHead statements END xEOS
			{
			PARFOR261=(Token)match(input,PARFOR,FOLLOW_PARFOR_in_parfor3389); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PARFOR.add(PARFOR261);

			pushFollow(FOLLOW_parforHead_in_parfor3391);
			parforHead262=parforHead();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_parforHead.add(parforHead262.getTree());
			pushFollow(FOLLOW_statements_in_parfor3393);
			statements263=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements263.getTree());
			END264=(Token)match(input,END,FOLLOW_END_in_parfor3395); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END264);

			pushFollow(FOLLOW_xEOS_in_parfor3397);
			xEOS265=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS265.getTree());
			// AST REWRITE
			// elements: PARFOR, parforHead, xEOS, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 345:48: -> ^( PARFOR parforHead ( statements )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:51: ^( PARFOR parforHead ( statements )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_PARFOR.nextNode(), root_1);
				adaptor.addChild(root_1, stream_parforHead.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:345:71: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parfor"


	public static class parforHead_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parforHead"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:1: parforHead : ( ( LPAREN var ASSIGN expression COMMA )=> LPAREN var ASSIGN expression COMMA expression RPAREN -> var ( expression )+ | LPAREN var ASSIGN expression RPAREN -> var expression | var ASSIGN expression -> var expression );
	public final MatlabParser.parforHead_return parforHead() throws RecognitionException {
		MatlabParser.parforHead_return retval = new MatlabParser.parforHead_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN266=null;
		Token ASSIGN268=null;
		Token COMMA270=null;
		Token RPAREN272=null;
		Token LPAREN273=null;
		Token ASSIGN275=null;
		Token RPAREN277=null;
		Token ASSIGN279=null;
		ParserRuleReturnScope var267 =null;
		ParserRuleReturnScope expression269 =null;
		ParserRuleReturnScope expression271 =null;
		ParserRuleReturnScope var274 =null;
		ParserRuleReturnScope expression276 =null;
		ParserRuleReturnScope var278 =null;
		ParserRuleReturnScope expression280 =null;

		Object LPAREN266_tree=null;
		Object ASSIGN268_tree=null;
		Object COMMA270_tree=null;
		Object RPAREN272_tree=null;
		Object LPAREN273_tree=null;
		Object ASSIGN275_tree=null;
		Object RPAREN277_tree=null;
		Object ASSIGN279_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:12: ( ( LPAREN var ASSIGN expression COMMA )=> LPAREN var ASSIGN expression COMMA expression RPAREN -> var ( expression )+ | LPAREN var ASSIGN expression RPAREN -> var expression | var ASSIGN expression -> var expression )
			int alt74=3;
			int LA74_0 = input.LA(1);
			if ( (LA74_0==LPAREN) ) {
				int LA74_1 = input.LA(2);
				if ( (synpred6_MatlabParser()) ) {
					alt74=1;
				}
				else if ( (true) ) {
					alt74=2;
				}

			}
			else if ( (LA74_0==ID) ) {
				alt74=3;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 74, 0, input);
				throw nvae;
			}

			switch (alt74) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:14: ( LPAREN var ASSIGN expression COMMA )=> LPAREN var ASSIGN expression COMMA expression RPAREN
					{
					LPAREN266=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parforHead3434); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN266);

					pushFollow(FOLLOW_var_in_parforHead3436);
					var267=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var267.getTree());
					ASSIGN268=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_parforHead3438); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN268);

					pushFollow(FOLLOW_expression_in_parforHead3440);
					expression269=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression269.getTree());
					COMMA270=(Token)match(input,COMMA,FOLLOW_COMMA_in_parforHead3442); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA270);

					pushFollow(FOLLOW_expression_in_parforHead3444);
					expression271=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression271.getTree());
					RPAREN272=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parforHead3446); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN272);

					// AST REWRITE
					// elements: var, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 347:106: -> var ( expression )+
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						if ( !(stream_expression.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_expression.hasNext() ) {
							adaptor.addChild(root_0, stream_expression.nextTree());
						}
						stream_expression.reset();

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:348:8: LPAREN var ASSIGN expression RPAREN
					{
					LPAREN273=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parforHead3464); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN273);

					pushFollow(FOLLOW_var_in_parforHead3466);
					var274=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var274.getTree());
					ASSIGN275=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_parforHead3468); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN275);

					pushFollow(FOLLOW_expression_in_parforHead3470);
					expression276=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression276.getTree());
					RPAREN277=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parforHead3472); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN277);

					// AST REWRITE
					// elements: var, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 348:44: -> var expression
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:349:8: var ASSIGN expression
					{
					pushFollow(FOLLOW_var_in_parforHead3487);
					var278=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var278.getTree());
					ASSIGN279=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_parforHead3489); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN279);

					pushFollow(FOLLOW_expression_in_parforHead3491);
					expression280=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression280.getTree());
					// AST REWRITE
					// elements: expression, var
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 349:30: -> var expression
					{
						adaptor.addChild(root_0, stream_var.nextTree());
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parforHead"


	public static class persistent_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "persistent"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:1: persistent : PERSISTENT ( var )+ xEOS -> ^( PERSISTENT ( var )+ xEOS ) ;
	public final MatlabParser.persistent_return persistent() throws RecognitionException {
		MatlabParser.persistent_return retval = new MatlabParser.persistent_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PERSISTENT281=null;
		ParserRuleReturnScope var282 =null;
		ParserRuleReturnScope xEOS283 =null;

		Object PERSISTENT281_tree=null;
		RewriteRuleTokenStream stream_PERSISTENT=new RewriteRuleTokenStream(adaptor,"token PERSISTENT");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:12: ( PERSISTENT ( var )+ xEOS -> ^( PERSISTENT ( var )+ xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:14: PERSISTENT ( var )+ xEOS
			{
			PERSISTENT281=(Token)match(input,PERSISTENT,FOLLOW_PERSISTENT_in_persistent3513); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PERSISTENT.add(PERSISTENT281);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:25: ( var )+
			int cnt75=0;
			loop75:
			while (true) {
				int alt75=2;
				int LA75_0 = input.LA(1);
				if ( (LA75_0==ID) ) {
					alt75=1;
				}

				switch (alt75) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:26: var
					{
					pushFollow(FOLLOW_var_in_persistent3516);
					var282=var();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_var.add(var282.getTree());
					}
					break;

				default :
					if ( cnt75 >= 1 ) break loop75;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(75, input);
					throw eee;
				}
				cnt75++;
			}

			pushFollow(FOLLOW_xEOS_in_persistent3520);
			xEOS283=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS283.getTree());
			// AST REWRITE
			// elements: var, xEOS, PERSISTENT
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 354:37: -> ^( PERSISTENT ( var )+ xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:354:40: ^( PERSISTENT ( var )+ xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_PERSISTENT.nextNode(), root_1);
				if ( !(stream_var.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_var.hasNext() ) {
					adaptor.addChild(root_1, stream_var.nextTree());
				}
				stream_var.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "persistent"


	public static class returnDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "returnDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:358:1: returnDef : RETURN xEOS -> ^( RETURN xEOS ) ;
	public final MatlabParser.returnDef_return returnDef() throws RecognitionException {
		MatlabParser.returnDef_return retval = new MatlabParser.returnDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token RETURN284=null;
		ParserRuleReturnScope xEOS285 =null;

		Object RETURN284_tree=null;
		RewriteRuleTokenStream stream_RETURN=new RewriteRuleTokenStream(adaptor,"token RETURN");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:358:11: ( RETURN xEOS -> ^( RETURN xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:358:13: RETURN xEOS
			{
			RETURN284=(Token)match(input,RETURN,FOLLOW_RETURN_in_returnDef3544); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RETURN.add(RETURN284);

			pushFollow(FOLLOW_xEOS_in_returnDef3546);
			xEOS285=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS285.getTree());
			// AST REWRITE
			// elements: xEOS, RETURN
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 358:25: -> ^( RETURN xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:358:28: ^( RETURN xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_RETURN.nextNode(), root_1);
				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "returnDef"


	public static class spmd_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "spmd"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:1: spmd : SPMD ( options {greedy=true; } : spmdHead )? statements END xEOS -> ^( SPMD ( spmdHead )? ( statements )? xEOS ) ;
	public final MatlabParser.spmd_return spmd() throws RecognitionException {
		MatlabParser.spmd_return retval = new MatlabParser.spmd_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SPMD286=null;
		Token END289=null;
		ParserRuleReturnScope spmdHead287 =null;
		ParserRuleReturnScope statements288 =null;
		ParserRuleReturnScope xEOS290 =null;

		Object SPMD286_tree=null;
		Object END289_tree=null;
		RewriteRuleTokenStream stream_SPMD=new RewriteRuleTokenStream(adaptor,"token SPMD");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_spmdHead=new RewriteRuleSubtreeStream(adaptor,"rule spmdHead");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:6: ( SPMD ( options {greedy=true; } : spmdHead )? statements END xEOS -> ^( SPMD ( spmdHead )? ( statements )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:8: SPMD ( options {greedy=true; } : spmdHead )? statements END xEOS
			{
			SPMD286=(Token)match(input,SPMD,FOLLOW_SPMD_in_spmd3565); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SPMD.add(SPMD286);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:13: ( options {greedy=true; } : spmdHead )?
			int alt76=2;
			int LA76_0 = input.LA(1);
			if ( (LA76_0==LPAREN) ) {
				int LA76_1 = input.LA(2);
				if ( (!(((True())))) ) {
					alt76=1;
				}
			}
			switch (alt76) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:38: spmdHead
					{
					pushFollow(FOLLOW_spmdHead_in_spmd3576);
					spmdHead287=spmdHead();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_spmdHead.add(spmdHead287.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_statements_in_spmd3580);
			statements288=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements288.getTree());
			END289=(Token)match(input,END,FOLLOW_END_in_spmd3582); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END289);

			pushFollow(FOLLOW_xEOS_in_spmd3584);
			xEOS290=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS290.getTree());
			// AST REWRITE
			// elements: SPMD, spmdHead, statements, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 362:69: -> ^( SPMD ( spmdHead )? ( statements )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:72: ^( SPMD ( spmdHead )? ( statements )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_SPMD.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:79: ( spmdHead )?
				if ( stream_spmdHead.hasNext() ) {
					adaptor.addChild(root_1, stream_spmdHead.nextTree());
				}
				stream_spmdHead.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:362:91: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "spmd"


	public static class spmdHead_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "spmdHead"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:1: spmdHead : LPAREN expression ( COMMA expression )? RPAREN -> ( expression )+ ;
	public final MatlabParser.spmdHead_return spmdHead() throws RecognitionException {
		MatlabParser.spmdHead_return retval = new MatlabParser.spmdHead_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN291=null;
		Token COMMA293=null;
		Token RPAREN295=null;
		ParserRuleReturnScope expression292 =null;
		ParserRuleReturnScope expression294 =null;

		Object LPAREN291_tree=null;
		Object COMMA293_tree=null;
		Object RPAREN295_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:10: ( LPAREN expression ( COMMA expression )? RPAREN -> ( expression )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:12: LPAREN expression ( COMMA expression )? RPAREN
			{
			LPAREN291=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_spmdHead3611); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN291);

			pushFollow(FOLLOW_expression_in_spmdHead3613);
			expression292=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression292.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:30: ( COMMA expression )?
			int alt77=2;
			int LA77_0 = input.LA(1);
			if ( (LA77_0==COMMA) ) {
				alt77=1;
			}
			switch (alt77) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:364:31: COMMA expression
					{
					COMMA293=(Token)match(input,COMMA,FOLLOW_COMMA_in_spmdHead3616); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA293);

					pushFollow(FOLLOW_expression_in_spmdHead3618);
					expression294=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression294.getTree());
					}
					break;

			}

			RPAREN295=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_spmdHead3622); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN295);

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 364:57: -> ( expression )+
			{
				if ( !(stream_expression.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.hasNext() ) {
					adaptor.addChild(root_0, stream_expression.nextTree());
				}
				stream_expression.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "spmdHead"


	public static class switchDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "switchDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:1: switchDef : switchPart ( casePart )* ( otherwisePart )? END xEOS -> ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS ) ;
	public final MatlabParser.switchDef_return switchDef() throws RecognitionException {
		MatlabParser.switchDef_return retval = new MatlabParser.switchDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END299=null;
		ParserRuleReturnScope switchPart296 =null;
		ParserRuleReturnScope casePart297 =null;
		ParserRuleReturnScope otherwisePart298 =null;
		ParserRuleReturnScope xEOS300 =null;

		Object END299_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_casePart=new RewriteRuleSubtreeStream(adaptor,"rule casePart");
		RewriteRuleSubtreeStream stream_otherwisePart=new RewriteRuleSubtreeStream(adaptor,"rule otherwisePart");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_switchPart=new RewriteRuleSubtreeStream(adaptor,"rule switchPart");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:11: ( switchPart ( casePart )* ( otherwisePart )? END xEOS -> ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:13: switchPart ( casePart )* ( otherwisePart )? END xEOS
			{
			pushFollow(FOLLOW_switchPart_in_switchDef3640);
			switchPart296=switchPart();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_switchPart.add(switchPart296.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:24: ( casePart )*
			loop78:
			while (true) {
				int alt78=2;
				int LA78_0 = input.LA(1);
				if ( (LA78_0==CASE) ) {
					alt78=1;
				}

				switch (alt78) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:25: casePart
					{
					pushFollow(FOLLOW_casePart_in_switchDef3643);
					casePart297=casePart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_casePart.add(casePart297.getTree());
					}
					break;

				default :
					break loop78;
				}
			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:36: ( otherwisePart )?
			int alt79=2;
			int LA79_0 = input.LA(1);
			if ( (LA79_0==OTHERWISE) ) {
				alt79=1;
			}
			switch (alt79) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:37: otherwisePart
					{
					pushFollow(FOLLOW_otherwisePart_in_switchDef3648);
					otherwisePart298=otherwisePart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_otherwisePart.add(otherwisePart298.getTree());
					}
					break;

			}

			END299=(Token)match(input,END,FOLLOW_END_in_switchDef3652); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END299);

			pushFollow(FOLLOW_xEOS_in_switchDef3654);
			xEOS300=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS300.getTree());
			// AST REWRITE
			// elements: xEOS, switchPart, casePart, otherwisePart
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 368:62: -> ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:65: ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SWITCHCASE, (switchPart296!=null?(switchPart296.start):null)), root_1);
				adaptor.addChild(root_1, stream_switchPart.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:108: ( casePart )*
				while ( stream_casePart.hasNext() ) {
					adaptor.addChild(root_1, stream_casePart.nextTree());
				}
				stream_casePart.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:368:120: ( otherwisePart )?
				if ( stream_otherwisePart.hasNext() ) {
					adaptor.addChild(root_1, stream_otherwisePart.nextTree());
				}
				stream_otherwisePart.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "switchDef"


	public static class switchPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "switchPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:1: switchPart : SWITCH expression ( xEOS )* -> ^( SWITCH expression ) ;
	public final MatlabParser.switchPart_return switchPart() throws RecognitionException {
		MatlabParser.switchPart_return retval = new MatlabParser.switchPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SWITCH301=null;
		ParserRuleReturnScope expression302 =null;
		ParserRuleReturnScope xEOS303 =null;

		Object SWITCH301_tree=null;
		RewriteRuleTokenStream stream_SWITCH=new RewriteRuleTokenStream(adaptor,"token SWITCH");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:12: ( SWITCH expression ( xEOS )* -> ^( SWITCH expression ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:14: SWITCH expression ( xEOS )*
			{
			SWITCH301=(Token)match(input,SWITCH,FOLLOW_SWITCH_in_switchPart3684); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_SWITCH.add(SWITCH301);

			pushFollow(FOLLOW_expression_in_switchPart3686);
			expression302=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression302.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:32: ( xEOS )*
			loop80:
			while (true) {
				int alt80=2;
				int LA80_0 = input.LA(1);
				if ( (LA80_0==COMMA||LA80_0==EOL||LA80_0==SEMICOLON) ) {
					alt80=1;
				}

				switch (alt80) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:33: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_switchPart3689);
					xEOS303=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS303.getTree());
					}
					break;

				default :
					break loop80;
				}
			}

			// AST REWRITE
			// elements: expression, SWITCH
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 370:40: -> ^( SWITCH expression )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:370:43: ^( SWITCH expression )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_SWITCH.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "switchPart"


	public static class casePart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "casePart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:1: casePart : CASE expression xEOS statements -> ^( CASE expression ( statements )? ) ;
	public final MatlabParser.casePart_return casePart() throws RecognitionException {
		MatlabParser.casePart_return retval = new MatlabParser.casePart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CASE304=null;
		ParserRuleReturnScope expression305 =null;
		ParserRuleReturnScope xEOS306 =null;
		ParserRuleReturnScope statements307 =null;

		Object CASE304_tree=null;
		RewriteRuleTokenStream stream_CASE=new RewriteRuleTokenStream(adaptor,"token CASE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:10: ( CASE expression xEOS statements -> ^( CASE expression ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:12: CASE expression xEOS statements
			{
			CASE304=(Token)match(input,CASE,FOLLOW_CASE_in_casePart3708); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CASE.add(CASE304);

			pushFollow(FOLLOW_expression_in_casePart3710);
			expression305=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression305.getTree());
			pushFollow(FOLLOW_xEOS_in_casePart3712);
			xEOS306=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS306.getTree());
			pushFollow(FOLLOW_statements_in_casePart3714);
			statements307=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements307.getTree());
			// AST REWRITE
			// elements: statements, CASE, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 372:44: -> ^( CASE expression ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:47: ^( CASE expression ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_CASE.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:372:65: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "casePart"


	public static class otherwisePart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "otherwisePart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:1: otherwisePart : OTHERWISE statements -> ^( OTHERWISE ( statements )? ) ;
	public final MatlabParser.otherwisePart_return otherwisePart() throws RecognitionException {
		MatlabParser.otherwisePart_return retval = new MatlabParser.otherwisePart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token OTHERWISE308=null;
		ParserRuleReturnScope statements309 =null;

		Object OTHERWISE308_tree=null;
		RewriteRuleTokenStream stream_OTHERWISE=new RewriteRuleTokenStream(adaptor,"token OTHERWISE");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:15: ( OTHERWISE statements -> ^( OTHERWISE ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:17: OTHERWISE statements
			{
			OTHERWISE308=(Token)match(input,OTHERWISE,FOLLOW_OTHERWISE_in_otherwisePart3736); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_OTHERWISE.add(OTHERWISE308);

			pushFollow(FOLLOW_statements_in_otherwisePart3738);
			statements309=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements309.getTree());
			// AST REWRITE
			// elements: OTHERWISE, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 374:38: -> ^( OTHERWISE ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:41: ^( OTHERWISE ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_OTHERWISE.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:374:53: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "otherwisePart"


	public static class tryDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "tryDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:1: tryDef : tryPart ( catchPart )? END xEOS -> ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS ) ;
	public final MatlabParser.tryDef_return tryDef() throws RecognitionException {
		MatlabParser.tryDef_return retval = new MatlabParser.tryDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END312=null;
		ParserRuleReturnScope tryPart310 =null;
		ParserRuleReturnScope catchPart311 =null;
		ParserRuleReturnScope xEOS313 =null;

		Object END312_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_tryPart=new RewriteRuleSubtreeStream(adaptor,"rule tryPart");
		RewriteRuleSubtreeStream stream_catchPart=new RewriteRuleSubtreeStream(adaptor,"rule catchPart");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:8: ( tryPart ( catchPart )? END xEOS -> ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:10: tryPart ( catchPart )? END xEOS
			{
			pushFollow(FOLLOW_tryPart_in_tryDef3760);
			tryPart310=tryPart();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_tryPart.add(tryPart310.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:18: ( catchPart )?
			int alt81=2;
			int LA81_0 = input.LA(1);
			if ( (LA81_0==CATCH) ) {
				alt81=1;
			}
			switch (alt81) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:19: catchPart
					{
					pushFollow(FOLLOW_catchPart_in_tryDef3763);
					catchPart311=catchPart();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_catchPart.add(catchPart311.getTree());
					}
					break;

			}

			END312=(Token)match(input,END,FOLLOW_END_in_tryDef3767); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END312);

			pushFollow(FOLLOW_xEOS_in_tryDef3769);
			xEOS313=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS313.getTree());
			// AST REWRITE
			// elements: xEOS, tryPart, catchPart
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 378:40: -> ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:43: ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TRYCATCH, (tryPart310!=null?(tryPart310.start):null)), root_1);
				adaptor.addChild(root_1, stream_tryPart.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:378:78: ( catchPart )?
				if ( stream_catchPart.hasNext() ) {
					adaptor.addChild(root_1, stream_catchPart.nextTree());
				}
				stream_catchPart.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "tryDef"


	public static class tryPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "tryPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:1: tryPart : TRY statements -> ^( TRY ( statements )? ) ;
	public final MatlabParser.tryPart_return tryPart() throws RecognitionException {
		MatlabParser.tryPart_return retval = new MatlabParser.tryPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TRY314=null;
		ParserRuleReturnScope statements315 =null;

		Object TRY314_tree=null;
		RewriteRuleTokenStream stream_TRY=new RewriteRuleTokenStream(adaptor,"token TRY");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:9: ( TRY statements -> ^( TRY ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:11: TRY statements
			{
			TRY314=(Token)match(input,TRY,FOLLOW_TRY_in_tryPart3794); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TRY.add(TRY314);

			pushFollow(FOLLOW_statements_in_tryPart3796);
			statements315=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements315.getTree());
			// AST REWRITE
			// elements: TRY, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 380:26: -> ^( TRY ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:29: ^( TRY ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_TRY.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:380:35: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "tryPart"


	public static class catchPart_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "catchPart"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:1: catchPart : CATCH ( options {greedy=true; } :{...}? => capturePortion )? statements -> ^( CATCH ( capturePortion )? ( statements )? ) ;
	public final MatlabParser.catchPart_return catchPart() throws RecognitionException {
		MatlabParser.catchPart_return retval = new MatlabParser.catchPart_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CATCH316=null;
		ParserRuleReturnScope capturePortion317 =null;
		ParserRuleReturnScope statements318 =null;

		Object CATCH316_tree=null;
		RewriteRuleTokenStream stream_CATCH=new RewriteRuleTokenStream(adaptor,"token CATCH");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_capturePortion=new RewriteRuleSubtreeStream(adaptor,"rule capturePortion");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:11: ( CATCH ( options {greedy=true; } :{...}? => capturePortion )? statements -> ^( CATCH ( capturePortion )? ( statements )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:13: CATCH ( options {greedy=true; } :{...}? => capturePortion )? statements
			{
			CATCH316=(Token)match(input,CATCH,FOLLOW_CATCH_in_catchPart3816); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CATCH.add(CATCH316);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:19: ( options {greedy=true; } :{...}? => capturePortion )?
			int alt82=2;
			int LA82_0 = input.LA(1);
			if ( (LA82_0==ID) && (((Command_IsEnabled())||(True())))) {
				int LA82_1 = input.LA(2);
				if ( (LA82_1==SEMICOLON) && (((Command_IsEnabled())||(True())))) {
					int LA82_6 = input.LA(3);
					if ( ((True())) ) {
						alt82=1;
					}
				}
				else if ( (LA82_1==COMMA) && (((Command_IsEnabled())||(True())))) {
					int LA82_7 = input.LA(3);
					if ( ((True())) ) {
						alt82=1;
					}
				}
				else if ( (LA82_1==EOL) && (((Command_IsEnabled())||(True())))) {
					int LA82_8 = input.LA(3);
					if ( ((True())) ) {
						alt82=1;
					}
				}
			}
			switch (alt82) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:44: {...}? => capturePortion
					{
					if ( !((True())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "catchPart", "True()");
					}
					pushFollow(FOLLOW_capturePortion_in_catchPart3830);
					capturePortion317=capturePortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_capturePortion.add(capturePortion317.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_statements_in_catchPart3834);
			statements318=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements318.getTree());
			// AST REWRITE
			// elements: capturePortion, statements, CATCH
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 382:84: -> ^( CATCH ( capturePortion )? ( statements )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:87: ^( CATCH ( capturePortion )? ( statements )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_CATCH.nextNode(), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:95: ( capturePortion )?
				if ( stream_capturePortion.hasNext() ) {
					adaptor.addChild(root_1, stream_capturePortion.nextTree());
				}
				stream_capturePortion.reset();

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:382:113: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "catchPart"


	public static class capturePortion_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "capturePortion"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:384:1: capturePortion : var xEOS -> var ;
	public final MatlabParser.capturePortion_return capturePortion() throws RecognitionException {
		MatlabParser.capturePortion_return retval = new MatlabParser.capturePortion_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope var319 =null;
		ParserRuleReturnScope xEOS320 =null;

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:384:16: ( var xEOS -> var )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:384:18: var xEOS
			{
			pushFollow(FOLLOW_var_in_capturePortion3859);
			var319=var();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_var.add(var319.getTree());
			pushFollow(FOLLOW_xEOS_in_capturePortion3861);
			xEOS320=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS320.getTree());
			// AST REWRITE
			// elements: var
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 384:27: -> var
			{
				adaptor.addChild(root_0, stream_var.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "capturePortion"


	public static class whileDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "whileDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:1: whileDef : WHILE expression statements END xEOS -> ^( WHILE expression ( statements )? xEOS ) ;
	public final MatlabParser.whileDef_return whileDef() throws RecognitionException {
		MatlabParser.whileDef_return retval = new MatlabParser.whileDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token WHILE321=null;
		Token END324=null;
		ParserRuleReturnScope expression322 =null;
		ParserRuleReturnScope statements323 =null;
		ParserRuleReturnScope xEOS325 =null;

		Object WHILE321_tree=null;
		Object END324_tree=null;
		RewriteRuleTokenStream stream_WHILE=new RewriteRuleTokenStream(adaptor,"token WHILE");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:10: ( WHILE expression statements END xEOS -> ^( WHILE expression ( statements )? xEOS ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:12: WHILE expression statements END xEOS
			{
			WHILE321=(Token)match(input,WHILE,FOLLOW_WHILE_in_whileDef3876); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_WHILE.add(WHILE321);

			pushFollow(FOLLOW_expression_in_whileDef3878);
			expression322=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression322.getTree());
			pushFollow(FOLLOW_statements_in_whileDef3880);
			statements323=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_statements.add(statements323.getTree());
			END324=(Token)match(input,END,FOLLOW_END_in_whileDef3882); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END324);

			pushFollow(FOLLOW_xEOS_in_whileDef3884);
			xEOS325=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS325.getTree());
			// AST REWRITE
			// elements: WHILE, expression, xEOS, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 388:49: -> ^( WHILE expression ( statements )? xEOS )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:52: ^( WHILE expression ( statements )? xEOS )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_WHILE.nextNode(), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:388:71: ( statements )?
				if ( stream_statements.hasNext() ) {
					adaptor.addChild(root_1, stream_statements.nextTree());
				}
				stream_statements.reset();

				adaptor.addChild(root_1, stream_xEOS.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "whileDef"


	public static class expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:392:1: expression : expression11 -> expression11 ;
	public final MatlabParser.expression_return expression() throws RecognitionException {
		MatlabParser.expression_return retval = new MatlabParser.expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression11326 =null;

		RewriteRuleSubtreeStream stream_expression11=new RewriteRuleSubtreeStream(adaptor,"rule expression11");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:392:12: ( expression11 -> expression11 )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:392:14: expression11
			{
			pushFollow(FOLLOW_expression11_in_expression3910);
			expression11326=expression11();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression11.add(expression11326.getTree());
			// AST REWRITE
			// elements: expression11
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 392:27: -> expression11
			{
				adaptor.addChild(root_0, stream_expression11.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression"


	public static class expression11_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression11"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:1: expression11 : (x1= expression10 -> $x1) ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )* ;
	public final MatlabParser.expression11_return expression11() throws RecognitionException {
		MatlabParser.expression11_return retval = new MatlabParser.expression11_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SHORTOR327=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object SHORTOR327_tree=null;
		RewriteRuleTokenStream stream_SHORTOR=new RewriteRuleTokenStream(adaptor,"token SHORTOR");
		RewriteRuleSubtreeStream stream_expression10=new RewriteRuleSubtreeStream(adaptor,"rule expression10");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:14: ( (x1= expression10 -> $x1) ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:16: (x1= expression10 -> $x1) ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:16: (x1= expression10 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:17: x1= expression10
			{
			pushFollow(FOLLOW_expression10_in_expression113926);
			x1=expression10();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression10.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 394:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:41: ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )*
			loop83:
			while (true) {
				int alt83=2;
				int LA83_0 = input.LA(1);
				if ( (LA83_0==SHORTOR) ) {
					alt83=1;
				}

				switch (alt83) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:66: SHORTOR x2= expression10
					{
					SHORTOR327=(Token)match(input,SHORTOR,FOLLOW_SHORTOR_in_expression113943); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SHORTOR.add(SHORTOR327);

					pushFollow(FOLLOW_expression10_in_expression113947);
					x2=expression10();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression10.add(x2.getTree());
					// AST REWRITE
					// elements: expression11, x2, SHORTOR
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 394:90: -> ^( SHORTOR $expression11 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:394:93: ^( SHORTOR $expression11 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_SHORTOR.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop83;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression11"


	public static class expression10_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression10"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:1: expression10 : (x1= expression09 -> $x1) ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )* ;
	public final MatlabParser.expression10_return expression10() throws RecognitionException {
		MatlabParser.expression10_return retval = new MatlabParser.expression10_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SHORTAND328=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object SHORTAND328_tree=null;
		RewriteRuleTokenStream stream_SHORTAND=new RewriteRuleTokenStream(adaptor,"token SHORTAND");
		RewriteRuleSubtreeStream stream_expression09=new RewriteRuleSubtreeStream(adaptor,"rule expression09");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:14: ( (x1= expression09 -> $x1) ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:16: (x1= expression09 -> $x1) ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:16: (x1= expression09 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:17: x1= expression09
			{
			pushFollow(FOLLOW_expression09_in_expression103973);
			x1=expression09();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression09.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 396:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:41: ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )*
			loop84:
			while (true) {
				int alt84=2;
				int LA84_0 = input.LA(1);
				if ( (LA84_0==SHORTAND) ) {
					alt84=1;
				}

				switch (alt84) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:66: SHORTAND x2= expression09
					{
					SHORTAND328=(Token)match(input,SHORTAND,FOLLOW_SHORTAND_in_expression103990); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SHORTAND.add(SHORTAND328);

					pushFollow(FOLLOW_expression09_in_expression103994);
					x2=expression09();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression09.add(x2.getTree());
					// AST REWRITE
					// elements: x2, SHORTAND, expression10
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 396:91: -> ^( SHORTAND $expression10 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:396:94: ^( SHORTAND $expression10 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_SHORTAND.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop84;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression10"


	public static class expression09_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression09"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:1: expression09 : (x1= expression08 -> $x1) ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )* ;
	public final MatlabParser.expression09_return expression09() throws RecognitionException {
		MatlabParser.expression09_return retval = new MatlabParser.expression09_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token OR329=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object OR329_tree=null;
		RewriteRuleTokenStream stream_OR=new RewriteRuleTokenStream(adaptor,"token OR");
		RewriteRuleSubtreeStream stream_expression08=new RewriteRuleSubtreeStream(adaptor,"rule expression08");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:14: ( (x1= expression08 -> $x1) ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:16: (x1= expression08 -> $x1) ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:16: (x1= expression08 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:17: x1= expression08
			{
			pushFollow(FOLLOW_expression08_in_expression094020);
			x1=expression08();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression08.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 398:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:41: ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )*
			loop85:
			while (true) {
				int alt85=2;
				int LA85_0 = input.LA(1);
				if ( (LA85_0==OR) ) {
					alt85=1;
				}

				switch (alt85) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:66: OR x2= expression08
					{
					OR329=(Token)match(input,OR,FOLLOW_OR_in_expression094037); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OR.add(OR329);

					pushFollow(FOLLOW_expression08_in_expression094041);
					x2=expression08();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression08.add(x2.getTree());
					// AST REWRITE
					// elements: OR, expression09, x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 398:85: -> ^( OR $expression09 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:398:88: ^( OR $expression09 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_OR.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop85;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression09"


	public static class expression08_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression08"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:1: expression08 : (x1= expression07 -> $x1) ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )* ;
	public final MatlabParser.expression08_return expression08() throws RecognitionException {
		MatlabParser.expression08_return retval = new MatlabParser.expression08_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AND330=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object AND330_tree=null;
		RewriteRuleTokenStream stream_AND=new RewriteRuleTokenStream(adaptor,"token AND");
		RewriteRuleSubtreeStream stream_expression07=new RewriteRuleSubtreeStream(adaptor,"rule expression07");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:14: ( (x1= expression07 -> $x1) ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:16: (x1= expression07 -> $x1) ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:16: (x1= expression07 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:17: x1= expression07
			{
			pushFollow(FOLLOW_expression07_in_expression084067);
			x1=expression07();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression07.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 400:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:41: ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )*
			loop86:
			while (true) {
				int alt86=2;
				int LA86_0 = input.LA(1);
				if ( (LA86_0==AND) ) {
					alt86=1;
				}

				switch (alt86) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:66: AND x2= expression07
					{
					AND330=(Token)match(input,AND,FOLLOW_AND_in_expression084084); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AND.add(AND330);

					pushFollow(FOLLOW_expression07_in_expression084088);
					x2=expression07();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression07.add(x2.getTree());
					// AST REWRITE
					// elements: AND, x2, expression08
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 400:86: -> ^( AND $expression08 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:400:89: ^( AND $expression08 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_AND.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop86;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression08"


	public static class expression07_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression07"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:1: expression07 : (x1= expression06 -> $x1) ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )* ;
	public final MatlabParser.expression07_return expression07() throws RecognitionException {
		MatlabParser.expression07_return retval = new MatlabParser.expression07_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator06=new RewriteRuleSubtreeStream(adaptor,"rule operator06");
		RewriteRuleSubtreeStream stream_expression06=new RewriteRuleSubtreeStream(adaptor,"rule expression06");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:14: ( (x1= expression06 -> $x1) ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:16: (x1= expression06 -> $x1) ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:16: (x1= expression06 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:17: x1= expression06
			{
			pushFollow(FOLLOW_expression06_in_expression074114);
			x1=expression06();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression06.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 402:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:41: ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )*
			loop87:
			while (true) {
				int alt87=2;
				switch ( input.LA(1) ) {
				case LT:
					{
					alt87=1;
					}
					break;
				case LTEQ:
					{
					alt87=1;
					}
					break;
				case GT:
					{
					alt87=1;
					}
					break;
				case GTEQ:
					{
					alt87=1;
					}
					break;
				case EQ:
					{
					alt87=1;
					}
					break;
				case NOTEQ:
					{
					alt87=1;
					}
					break;
				}
				switch (alt87) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:66: op= operator06 x2= expression06
					{
					pushFollow(FOLLOW_operator06_in_expression074133);
					op=operator06();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator06.add(op.getTree());
					pushFollow(FOLLOW_expression06_in_expression074137);
					x2=expression06();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression06.add(x2.getTree());
					// AST REWRITE
					// elements: expression07, x2, op
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 402:96: -> ^( $op $expression07 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:402:99: ^( $op $expression07 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop87;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression07"


	public static class operator06_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator06"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:404:1: operator06 : ( LT -> LT | LTEQ -> LTEQ | GT -> GT | GTEQ -> GTEQ | EQ -> EQ | NOTEQ -> NOTEQ );
	public final MatlabParser.operator06_return operator06() throws RecognitionException {
		MatlabParser.operator06_return retval = new MatlabParser.operator06_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LT331=null;
		Token LTEQ332=null;
		Token GT333=null;
		Token GTEQ334=null;
		Token EQ335=null;
		Token NOTEQ336=null;

		Object LT331_tree=null;
		Object LTEQ332_tree=null;
		Object GT333_tree=null;
		Object GTEQ334_tree=null;
		Object EQ335_tree=null;
		Object NOTEQ336_tree=null;
		RewriteRuleTokenStream stream_LTEQ=new RewriteRuleTokenStream(adaptor,"token LTEQ");
		RewriteRuleTokenStream stream_LT=new RewriteRuleTokenStream(adaptor,"token LT");
		RewriteRuleTokenStream stream_GTEQ=new RewriteRuleTokenStream(adaptor,"token GTEQ");
		RewriteRuleTokenStream stream_EQ=new RewriteRuleTokenStream(adaptor,"token EQ");
		RewriteRuleTokenStream stream_GT=new RewriteRuleTokenStream(adaptor,"token GT");
		RewriteRuleTokenStream stream_NOTEQ=new RewriteRuleTokenStream(adaptor,"token NOTEQ");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:404:12: ( LT -> LT | LTEQ -> LTEQ | GT -> GT | GTEQ -> GTEQ | EQ -> EQ | NOTEQ -> NOTEQ )
			int alt88=6;
			switch ( input.LA(1) ) {
			case LT:
				{
				alt88=1;
				}
				break;
			case LTEQ:
				{
				alt88=2;
				}
				break;
			case GT:
				{
				alt88=3;
				}
				break;
			case GTEQ:
				{
				alt88=4;
				}
				break;
			case EQ:
				{
				alt88=5;
				}
				break;
			case NOTEQ:
				{
				alt88=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 88, 0, input);
				throw nvae;
			}
			switch (alt88) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:404:14: LT
					{
					LT331=(Token)match(input,LT,FOLLOW_LT_in_operator064161); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LT.add(LT331);

					// AST REWRITE
					// elements: LT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 404:17: -> LT
					{
						adaptor.addChild(root_0, stream_LT.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:405:8: LTEQ
					{
					LTEQ332=(Token)match(input,LTEQ,FOLLOW_LTEQ_in_operator064174); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LTEQ.add(LTEQ332);

					// AST REWRITE
					// elements: LTEQ
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 405:13: -> LTEQ
					{
						adaptor.addChild(root_0, stream_LTEQ.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:406:8: GT
					{
					GT333=(Token)match(input,GT,FOLLOW_GT_in_operator064187); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_GT.add(GT333);

					// AST REWRITE
					// elements: GT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 406:11: -> GT
					{
						adaptor.addChild(root_0, stream_GT.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:407:8: GTEQ
					{
					GTEQ334=(Token)match(input,GTEQ,FOLLOW_GTEQ_in_operator064200); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_GTEQ.add(GTEQ334);

					// AST REWRITE
					// elements: GTEQ
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 407:13: -> GTEQ
					{
						adaptor.addChild(root_0, stream_GTEQ.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:408:8: EQ
					{
					EQ335=(Token)match(input,EQ,FOLLOW_EQ_in_operator064213); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EQ.add(EQ335);

					// AST REWRITE
					// elements: EQ
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 408:11: -> EQ
					{
						adaptor.addChild(root_0, stream_EQ.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:409:8: NOTEQ
					{
					NOTEQ336=(Token)match(input,NOTEQ,FOLLOW_NOTEQ_in_operator064226); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOTEQ.add(NOTEQ336);

					// AST REWRITE
					// elements: NOTEQ
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 409:14: -> NOTEQ
					{
						adaptor.addChild(root_0, stream_NOTEQ.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator06"


	public static class expression06_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression06"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:1: expression06 : (x1= expression05 -> $x1) ( options {greedy=true; } : ( options {greedy=true; } : COLON x2= expression05 )+ -> ^( COLON ( expression05 )+ ) )? ;
	public final MatlabParser.expression06_return expression06() throws RecognitionException {
		MatlabParser.expression06_return retval = new MatlabParser.expression06_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COLON337=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object COLON337_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expression05=new RewriteRuleSubtreeStream(adaptor,"rule expression05");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:14: ( (x1= expression05 -> $x1) ( options {greedy=true; } : ( options {greedy=true; } : COLON x2= expression05 )+ -> ^( COLON ( expression05 )+ ) )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:16: (x1= expression05 -> $x1) ( options {greedy=true; } : ( options {greedy=true; } : COLON x2= expression05 )+ -> ^( COLON ( expression05 )+ ) )?
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:16: (x1= expression05 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:17: x1= expression05
			{
			pushFollow(FOLLOW_expression05_in_expression064247);
			x1=expression05();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression05.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 412:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:41: ( options {greedy=true; } : ( options {greedy=true; } : COLON x2= expression05 )+ -> ^( COLON ( expression05 )+ ) )?
			int alt90=2;
			int LA90_0 = input.LA(1);
			if ( (LA90_0==COLON) ) {
				alt90=1;
			}
			switch (alt90) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:66: ( options {greedy=true; } : COLON x2= expression05 )+
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:66: ( options {greedy=true; } : COLON x2= expression05 )+
					int cnt89=0;
					loop89:
					while (true) {
						int alt89=2;
						int LA89_0 = input.LA(1);
						if ( (LA89_0==COLON) ) {
							alt89=1;
						}

						switch (alt89) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:91: COLON x2= expression05
							{
							COLON337=(Token)match(input,COLON,FOLLOW_COLON_in_expression064273); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COLON.add(COLON337);

							pushFollow(FOLLOW_expression05_in_expression064277);
							x2=expression05();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_expression05.add(x2.getTree());
							}
							break;

						default :
							if ( cnt89 >= 1 ) break loop89;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(89, input);
							throw eee;
						}
						cnt89++;
					}

					// AST REWRITE
					// elements: expression05, COLON
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 412:115: -> ^( COLON ( expression05 )+ )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:412:118: ^( COLON ( expression05 )+ )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_COLON.nextNode(), root_1);
						if ( !(stream_expression05.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_expression05.hasNext() ) {
							adaptor.addChild(root_1, stream_expression05.nextTree());
						}
						stream_expression05.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression06"


	public static class expression05_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression05"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:1: expression05 : (x1= expression04 -> $x1) ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )* ;
	public final MatlabParser.expression05_return expression05() throws RecognitionException {
		MatlabParser.expression05_return retval = new MatlabParser.expression05_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator04=new RewriteRuleSubtreeStream(adaptor,"rule operator04");
		RewriteRuleSubtreeStream stream_expression04=new RewriteRuleSubtreeStream(adaptor,"rule expression04");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:14: ( (x1= expression04 -> $x1) ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:16: (x1= expression04 -> $x1) ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:16: (x1= expression04 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:17: x1= expression04
			{
			pushFollow(FOLLOW_expression04_in_expression054304);
			x1=expression04();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression04.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 414:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:41: ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )*
			loop91:
			while (true) {
				int alt91=2;
				int LA91_0 = input.LA(1);
				if ( (LA91_0==PLUS) && (((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {
					int LA91_3 = input.LA(2);
					if ( ((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())) ) {
						alt91=1;
					}

				}
				else if ( (LA91_0==MINUS) && (((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {
					int LA91_4 = input.LA(2);
					if ( ((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())) ) {
						alt91=1;
					}

				}

				switch (alt91) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:66: {...}? =>op= operator04 x2= expression04
					{
					if ( !((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "expression05", "!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight()");
					}
					pushFollow(FOLLOW_operator04_in_expression054326);
					op=operator04();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator04.add(op.getTree());
					pushFollow(FOLLOW_expression04_in_expression054330);
					x2=expression04();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression04.add(x2.getTree());
					// AST REWRITE
					// elements: expression05, x2, op
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 414:156: -> ^( $op $expression05 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:414:159: ^( $op $expression05 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop91;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression05"


	public static class operator04_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator04"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:416:1: operator04 : ( PLUS -> PLUS | MINUS -> MINUS );
	public final MatlabParser.operator04_return operator04() throws RecognitionException {
		MatlabParser.operator04_return retval = new MatlabParser.operator04_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLUS338=null;
		Token MINUS339=null;

		Object PLUS338_tree=null;
		Object MINUS339_tree=null;
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:416:12: ( PLUS -> PLUS | MINUS -> MINUS )
			int alt92=2;
			int LA92_0 = input.LA(1);
			if ( (LA92_0==PLUS) ) {
				alt92=1;
			}
			else if ( (LA92_0==MINUS) ) {
				alt92=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 92, 0, input);
				throw nvae;
			}

			switch (alt92) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:416:14: PLUS
					{
					PLUS338=(Token)match(input,PLUS,FOLLOW_PLUS_in_operator044354); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PLUS.add(PLUS338);

					// AST REWRITE
					// elements: PLUS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 416:19: -> PLUS
					{
						adaptor.addChild(root_0, stream_PLUS.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:417:8: MINUS
					{
					MINUS339=(Token)match(input,MINUS,FOLLOW_MINUS_in_operator044367); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(MINUS339);

					// AST REWRITE
					// elements: MINUS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 417:14: -> MINUS
					{
						adaptor.addChild(root_0, stream_MINUS.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator04"


	public static class expression04_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression04"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:1: expression04 : (x1= expression03 -> $x1) ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )* ;
	public final MatlabParser.expression04_return expression04() throws RecognitionException {
		MatlabParser.expression04_return retval = new MatlabParser.expression04_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator03=new RewriteRuleSubtreeStream(adaptor,"rule operator03");
		RewriteRuleSubtreeStream stream_expression03=new RewriteRuleSubtreeStream(adaptor,"rule expression03");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:14: ( (x1= expression03 -> $x1) ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:16: (x1= expression03 -> $x1) ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:16: (x1= expression03 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:17: x1= expression03
			{
			pushFollow(FOLLOW_expression03_in_expression044388);
			x1=expression03();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression03.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 420:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:41: ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )*
			loop93:
			while (true) {
				int alt93=2;
				switch ( input.LA(1) ) {
				case TIMES:
					{
					alt93=1;
					}
					break;
				case RDIV:
					{
					alt93=1;
					}
					break;
				case LDIV:
					{
					alt93=1;
					}
					break;
				case MTIMES:
					{
					alt93=1;
					}
					break;
				case MRDIV:
					{
					alt93=1;
					}
					break;
				case MLDIV:
					{
					alt93=1;
					}
					break;
				}
				switch (alt93) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:66: op= operator03 x2= expression03
					{
					pushFollow(FOLLOW_operator03_in_expression044407);
					op=operator03();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator03.add(op.getTree());
					pushFollow(FOLLOW_expression03_in_expression044411);
					x2=expression03();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression03.add(x2.getTree());
					// AST REWRITE
					// elements: x2, op, expression04
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 420:96: -> ^( $op $expression04 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:420:99: ^( $op $expression04 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop93;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression04"


	public static class operator03_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator03"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:422:1: operator03 : ( TIMES -> TIMES | RDIV -> RDIV | LDIV -> LDIV | MTIMES -> MTIMES | MRDIV -> MRDIV | MLDIV -> MLDIV );
	public final MatlabParser.operator03_return operator03() throws RecognitionException {
		MatlabParser.operator03_return retval = new MatlabParser.operator03_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TIMES340=null;
		Token RDIV341=null;
		Token LDIV342=null;
		Token MTIMES343=null;
		Token MRDIV344=null;
		Token MLDIV345=null;

		Object TIMES340_tree=null;
		Object RDIV341_tree=null;
		Object LDIV342_tree=null;
		Object MTIMES343_tree=null;
		Object MRDIV344_tree=null;
		Object MLDIV345_tree=null;
		RewriteRuleTokenStream stream_MLDIV=new RewriteRuleTokenStream(adaptor,"token MLDIV");
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");
		RewriteRuleTokenStream stream_LDIV=new RewriteRuleTokenStream(adaptor,"token LDIV");
		RewriteRuleTokenStream stream_RDIV=new RewriteRuleTokenStream(adaptor,"token RDIV");
		RewriteRuleTokenStream stream_MTIMES=new RewriteRuleTokenStream(adaptor,"token MTIMES");
		RewriteRuleTokenStream stream_MRDIV=new RewriteRuleTokenStream(adaptor,"token MRDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:422:12: ( TIMES -> TIMES | RDIV -> RDIV | LDIV -> LDIV | MTIMES -> MTIMES | MRDIV -> MRDIV | MLDIV -> MLDIV )
			int alt94=6;
			switch ( input.LA(1) ) {
			case TIMES:
				{
				alt94=1;
				}
				break;
			case RDIV:
				{
				alt94=2;
				}
				break;
			case LDIV:
				{
				alt94=3;
				}
				break;
			case MTIMES:
				{
				alt94=4;
				}
				break;
			case MRDIV:
				{
				alt94=5;
				}
				break;
			case MLDIV:
				{
				alt94=6;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 94, 0, input);
				throw nvae;
			}
			switch (alt94) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:422:14: TIMES
					{
					TIMES340=(Token)match(input,TIMES,FOLLOW_TIMES_in_operator034435); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_TIMES.add(TIMES340);

					// AST REWRITE
					// elements: TIMES
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 422:20: -> TIMES
					{
						adaptor.addChild(root_0, stream_TIMES.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:423:8: RDIV
					{
					RDIV341=(Token)match(input,RDIV,FOLLOW_RDIV_in_operator034448); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RDIV.add(RDIV341);

					// AST REWRITE
					// elements: RDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 423:13: -> RDIV
					{
						adaptor.addChild(root_0, stream_RDIV.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:424:8: LDIV
					{
					LDIV342=(Token)match(input,LDIV,FOLLOW_LDIV_in_operator034461); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LDIV.add(LDIV342);

					// AST REWRITE
					// elements: LDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 424:13: -> LDIV
					{
						adaptor.addChild(root_0, stream_LDIV.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:425:8: MTIMES
					{
					MTIMES343=(Token)match(input,MTIMES,FOLLOW_MTIMES_in_operator034474); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MTIMES.add(MTIMES343);

					// AST REWRITE
					// elements: MTIMES
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 425:15: -> MTIMES
					{
						adaptor.addChild(root_0, stream_MTIMES.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:426:8: MRDIV
					{
					MRDIV344=(Token)match(input,MRDIV,FOLLOW_MRDIV_in_operator034487); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MRDIV.add(MRDIV344);

					// AST REWRITE
					// elements: MRDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 426:14: -> MRDIV
					{
						adaptor.addChild(root_0, stream_MRDIV.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:427:8: MLDIV
					{
					MLDIV345=(Token)match(input,MLDIV,FOLLOW_MLDIV_in_operator034500); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MLDIV.add(MLDIV345);

					// AST REWRITE
					// elements: MLDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 427:14: -> MLDIV
					{
						adaptor.addChild(root_0, stream_MLDIV.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator03"


	public static class expression03_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression03"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:430:1: expression03 : (op= operator02 x1= expression03 -> ^( $op $x1) |x2= expression02 -> $x2);
	public final MatlabParser.expression03_return expression03() throws RecognitionException {
		MatlabParser.expression03_return retval = new MatlabParser.expression03_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator02=new RewriteRuleSubtreeStream(adaptor,"rule operator02");
		RewriteRuleSubtreeStream stream_expression03=new RewriteRuleSubtreeStream(adaptor,"rule expression03");
		RewriteRuleSubtreeStream stream_expression02=new RewriteRuleSubtreeStream(adaptor,"rule expression02");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:430:14: (op= operator02 x1= expression03 -> ^( $op $x1) |x2= expression02 -> $x2)
			int alt95=2;
			int LA95_0 = input.LA(1);
			if ( (LA95_0==MINUS||LA95_0==NOT||LA95_0==PLUS) ) {
				alt95=1;
			}
			else if ( (LA95_0==ID||LA95_0==IMAGINARY||LA95_0==LCURLY||(LA95_0 >= LPAREN && LA95_0 <= LSQUARE)||LA95_0==REAL||LA95_0==STRING) ) {
				alt95=2;
			}
			else if ( (LA95_0==END) && ((Index_IsActive()))) {
				alt95=2;
			}
			else if ( (LA95_0==AT||LA95_0==QUESTION) ) {
				alt95=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 95, 0, input);
				throw nvae;
			}

			switch (alt95) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:430:16: op= operator02 x1= expression03
					{
					pushFollow(FOLLOW_operator02_in_expression034520);
					op=operator02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator02.add(op.getTree());
					pushFollow(FOLLOW_expression03_in_expression034524);
					x1=expression03();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression03.add(x1.getTree());
					// AST REWRITE
					// elements: x1, op
					// token labels: 
					// rule labels: op, x1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 430:46: -> ^( $op $x1)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:430:49: ^( $op $x1)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_x1.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:431:7: x2= expression02
					{
					pushFollow(FOLLOW_expression02_in_expression034544);
					x2=expression02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression02.add(x2.getTree());
					// AST REWRITE
					// elements: x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 431:23: -> $x2
					{
						adaptor.addChild(root_0, stream_x2.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression03"


	public static class operator02_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator02"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:434:1: operator02 : ( PLUS -> POSITIVE[$PLUS] | MINUS -> NEGATIVE[$MINUS] | NOT -> NOT );
	public final MatlabParser.operator02_return operator02() throws RecognitionException {
		MatlabParser.operator02_return retval = new MatlabParser.operator02_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLUS346=null;
		Token MINUS347=null;
		Token NOT348=null;

		Object PLUS346_tree=null;
		Object MINUS347_tree=null;
		Object NOT348_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:434:12: ( PLUS -> POSITIVE[$PLUS] | MINUS -> NEGATIVE[$MINUS] | NOT -> NOT )
			int alt96=3;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt96=1;
				}
				break;
			case MINUS:
				{
				alt96=2;
				}
				break;
			case NOT:
				{
				alt96=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 96, 0, input);
				throw nvae;
			}
			switch (alt96) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:434:14: PLUS
					{
					PLUS346=(Token)match(input,PLUS,FOLLOW_PLUS_in_operator024562); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PLUS.add(PLUS346);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 434:19: -> POSITIVE[$PLUS]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(POSITIVE, PLUS346));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:435:8: MINUS
					{
					MINUS347=(Token)match(input,MINUS,FOLLOW_MINUS_in_operator024576); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS.add(MINUS347);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 435:14: -> NEGATIVE[$MINUS]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(NEGATIVE, MINUS347));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:436:8: NOT
					{
					NOT348=(Token)match(input,NOT,FOLLOW_NOT_in_operator024590); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT348);

					// AST REWRITE
					// elements: NOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 436:12: -> NOT
					{
						adaptor.addChild(root_0, stream_NOT.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator02"


	public static class expression02_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression02"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:1: expression02 : (x1= expression00 -> $x1) ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )* ;
	public final MatlabParser.expression02_return expression02() throws RecognitionException {
		MatlabParser.expression02_return retval = new MatlabParser.expression02_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TRANS349=null;
		Token CTRANS350=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x2 =null;

		Object TRANS349_tree=null;
		Object CTRANS350_tree=null;
		RewriteRuleTokenStream stream_TRANS=new RewriteRuleTokenStream(adaptor,"token TRANS");
		RewriteRuleTokenStream stream_CTRANS=new RewriteRuleTokenStream(adaptor,"token CTRANS");
		RewriteRuleSubtreeStream stream_operator01=new RewriteRuleSubtreeStream(adaptor,"rule operator01");
		RewriteRuleSubtreeStream stream_expression01=new RewriteRuleSubtreeStream(adaptor,"rule expression01");
		RewriteRuleSubtreeStream stream_expression00=new RewriteRuleSubtreeStream(adaptor,"rule expression00");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:14: ( (x1= expression00 -> $x1) ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:16: (x1= expression00 -> $x1) ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:16: (x1= expression00 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:439:17: x1= expression00
			{
			pushFollow(FOLLOW_expression00_in_expression024611);
			x1=expression00();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression00.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 439:33: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:440:7: ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )*
			loop97:
			while (true) {
				int alt97=4;
				switch ( input.LA(1) ) {
				case POW:
					{
					alt97=1;
					}
					break;
				case MPOW:
					{
					alt97=1;
					}
					break;
				case TRANS:
					{
					alt97=2;
					}
					break;
				case CTRANS:
					{
					alt97=3;
					}
					break;
				}
				switch (alt97) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:441:9: (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) )
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:441:9: (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) )
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:441:10: op= operator01 x2= expression01
					{
					pushFollow(FOLLOW_operator01_in_expression024646);
					op=operator01();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator01.add(op.getTree());
					pushFollow(FOLLOW_expression01_in_expression024650);
					x2=expression01();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression01.add(x2.getTree());
					// AST REWRITE
					// elements: x2, op, expression02
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 441:40: -> ^( $op $expression02 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:441:43: ^( $op $expression02 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:442:9: ( TRANS -> ^( TRANS $expression02) )
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:442:9: ( TRANS -> ^( TRANS $expression02) )
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:442:10: TRANS
					{
					TRANS349=(Token)match(input,TRANS,FOLLOW_TRANS_in_expression024675); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_TRANS.add(TRANS349);

					// AST REWRITE
					// elements: TRANS, expression02
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 442:16: -> ^( TRANS $expression02)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:442:19: ^( TRANS $expression02)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_TRANS.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:443:9: ( CTRANS -> ^( CTRANS $expression02) )
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:443:9: ( CTRANS -> ^( CTRANS $expression02) )
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:443:10: CTRANS
					{
					CTRANS350=(Token)match(input,CTRANS,FOLLOW_CTRANS_in_expression024696); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CTRANS.add(CTRANS350);

					// AST REWRITE
					// elements: expression02, CTRANS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 443:17: -> ^( CTRANS $expression02)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:443:20: ^( CTRANS $expression02)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_CTRANS.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}

					}
					break;

				default :
					break loop97;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression02"


	public static class operator01_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "operator01"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:446:1: operator01 : ( POW -> POW | MPOW -> MPOW );
	public final MatlabParser.operator01_return operator01() throws RecognitionException {
		MatlabParser.operator01_return retval = new MatlabParser.operator01_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token POW351=null;
		Token MPOW352=null;

		Object POW351_tree=null;
		Object MPOW352_tree=null;
		RewriteRuleTokenStream stream_POW=new RewriteRuleTokenStream(adaptor,"token POW");
		RewriteRuleTokenStream stream_MPOW=new RewriteRuleTokenStream(adaptor,"token MPOW");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:446:12: ( POW -> POW | MPOW -> MPOW )
			int alt98=2;
			int LA98_0 = input.LA(1);
			if ( (LA98_0==POW) ) {
				alt98=1;
			}
			else if ( (LA98_0==MPOW) ) {
				alt98=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 98, 0, input);
				throw nvae;
			}

			switch (alt98) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:446:14: POW
					{
					POW351=(Token)match(input,POW,FOLLOW_POW_in_operator014724); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_POW.add(POW351);

					// AST REWRITE
					// elements: POW
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 446:18: -> POW
					{
						adaptor.addChild(root_0, stream_POW.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:447:8: MPOW
					{
					MPOW352=(Token)match(input,MPOW,FOLLOW_MPOW_in_operator014737); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MPOW.add(MPOW352);

					// AST REWRITE
					// elements: MPOW
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 447:13: -> MPOW
					{
						adaptor.addChild(root_0, stream_MPOW.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "operator01"


	public static class expression01_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression01"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:450:1: expression01 : (op= operator02 x1= expression01 -> ^( $op $x1) |x2= expression00 -> $x2);
	public final MatlabParser.expression01_return expression01() throws RecognitionException {
		MatlabParser.expression01_return retval = new MatlabParser.expression01_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope op =null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		RewriteRuleSubtreeStream stream_operator02=new RewriteRuleSubtreeStream(adaptor,"rule operator02");
		RewriteRuleSubtreeStream stream_expression01=new RewriteRuleSubtreeStream(adaptor,"rule expression01");
		RewriteRuleSubtreeStream stream_expression00=new RewriteRuleSubtreeStream(adaptor,"rule expression00");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:450:14: (op= operator02 x1= expression01 -> ^( $op $x1) |x2= expression00 -> $x2)
			int alt99=2;
			int LA99_0 = input.LA(1);
			if ( (LA99_0==MINUS||LA99_0==NOT||LA99_0==PLUS) ) {
				alt99=1;
			}
			else if ( (LA99_0==ID||LA99_0==IMAGINARY||LA99_0==LCURLY||(LA99_0 >= LPAREN && LA99_0 <= LSQUARE)||LA99_0==REAL||LA99_0==STRING) ) {
				alt99=2;
			}
			else if ( (LA99_0==END) && ((Index_IsActive()))) {
				alt99=2;
			}
			else if ( (LA99_0==AT||LA99_0==QUESTION) ) {
				alt99=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 99, 0, input);
				throw nvae;
			}

			switch (alt99) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:450:16: op= operator02 x1= expression01
					{
					pushFollow(FOLLOW_operator02_in_expression014757);
					op=operator02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_operator02.add(op.getTree());
					pushFollow(FOLLOW_expression01_in_expression014761);
					x1=expression01();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression01.add(x1.getTree());
					// AST REWRITE
					// elements: x1, op
					// token labels: 
					// rule labels: op, x1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.getTree():null);
					RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 450:46: -> ^( $op $x1)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:450:49: ^( $op $x1)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_op.nextNode(), root_1);
						adaptor.addChild(root_1, stream_x1.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:451:7: x2= expression00
					{
					pushFollow(FOLLOW_expression00_in_expression014781);
					x2=expression00();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression00.add(x2.getTree());
					// AST REWRITE
					// elements: x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 451:23: -> $x2
					{
						adaptor.addChild(root_0, stream_x2.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression01"


	public static class expression00_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression00"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:454:1: expression00 : atom -> atom ;
	public final MatlabParser.expression00_return expression00() throws RecognitionException {
		MatlabParser.expression00_return retval = new MatlabParser.expression00_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope atom353 =null;

		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:454:14: ( atom -> atom )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:454:16: atom
			{
			pushFollow(FOLLOW_atom_in_expression004799);
			atom353=atom();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_atom.add(atom353.getTree());
			// AST REWRITE
			// elements: atom
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 454:21: -> atom
			{
				adaptor.addChild(root_0, stream_atom.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression00"


	public static class atom_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "atom"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:458:1: atom : ( chain -> chain | real -> real | imaginary -> imaginary | stringDef -> stringDef | regularArray -> regularArray | cellArray -> cellArray | parenthesized -> parenthesized | end -> end | functionHandle -> functionHandle | anonymousFunction -> anonymousFunction | metaclass -> metaclass );
	public final MatlabParser.atom_return atom() throws RecognitionException {
		MatlabParser.atom_return retval = new MatlabParser.atom_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope chain354 =null;
		ParserRuleReturnScope real355 =null;
		ParserRuleReturnScope imaginary356 =null;
		ParserRuleReturnScope stringDef357 =null;
		ParserRuleReturnScope regularArray358 =null;
		ParserRuleReturnScope cellArray359 =null;
		ParserRuleReturnScope parenthesized360 =null;
		ParserRuleReturnScope end361 =null;
		ParserRuleReturnScope functionHandle362 =null;
		ParserRuleReturnScope anonymousFunction363 =null;
		ParserRuleReturnScope metaclass364 =null;

		RewriteRuleSubtreeStream stream_chain=new RewriteRuleSubtreeStream(adaptor,"rule chain");
		RewriteRuleSubtreeStream stream_stringDef=new RewriteRuleSubtreeStream(adaptor,"rule stringDef");
		RewriteRuleSubtreeStream stream_cellArray=new RewriteRuleSubtreeStream(adaptor,"rule cellArray");
		RewriteRuleSubtreeStream stream_imaginary=new RewriteRuleSubtreeStream(adaptor,"rule imaginary");
		RewriteRuleSubtreeStream stream_functionHandle=new RewriteRuleSubtreeStream(adaptor,"rule functionHandle");
		RewriteRuleSubtreeStream stream_parenthesized=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized");
		RewriteRuleSubtreeStream stream_anonymousFunction=new RewriteRuleSubtreeStream(adaptor,"rule anonymousFunction");
		RewriteRuleSubtreeStream stream_end=new RewriteRuleSubtreeStream(adaptor,"rule end");
		RewriteRuleSubtreeStream stream_real=new RewriteRuleSubtreeStream(adaptor,"rule real");
		RewriteRuleSubtreeStream stream_regularArray=new RewriteRuleSubtreeStream(adaptor,"rule regularArray");
		RewriteRuleSubtreeStream stream_metaclass=new RewriteRuleSubtreeStream(adaptor,"rule metaclass");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:458:6: ( chain -> chain | real -> real | imaginary -> imaginary | stringDef -> stringDef | regularArray -> regularArray | cellArray -> cellArray | parenthesized -> parenthesized | end -> end | functionHandle -> functionHandle | anonymousFunction -> anonymousFunction | metaclass -> metaclass )
			int alt100=11;
			int LA100_0 = input.LA(1);
			if ( (LA100_0==ID) ) {
				alt100=1;
			}
			else if ( (LA100_0==REAL) ) {
				alt100=2;
			}
			else if ( (LA100_0==IMAGINARY) ) {
				alt100=3;
			}
			else if ( (LA100_0==STRING) ) {
				alt100=4;
			}
			else if ( (LA100_0==LSQUARE) ) {
				alt100=5;
			}
			else if ( (LA100_0==LCURLY) ) {
				alt100=6;
			}
			else if ( (LA100_0==LPAREN) ) {
				alt100=7;
			}
			else if ( (LA100_0==END) && ((Index_IsActive()))) {
				alt100=8;
			}
			else if ( (LA100_0==AT) ) {
				int LA100_9 = input.LA(2);
				if ( (LA100_9==ID) ) {
					alt100=9;
				}
				else if ( (LA100_9==LPAREN) ) {
					alt100=10;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 100, 9, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA100_0==QUESTION) ) {
				alt100=11;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 100, 0, input);
				throw nvae;
			}

			switch (alt100) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:458:8: chain
					{
					pushFollow(FOLLOW_chain_in_atom4814);
					chain354=chain();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_chain.add(chain354.getTree());
					// AST REWRITE
					// elements: chain
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 458:14: -> chain
					{
						adaptor.addChild(root_0, stream_chain.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:459:8: real
					{
					pushFollow(FOLLOW_real_in_atom4827);
					real355=real();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_real.add(real355.getTree());
					// AST REWRITE
					// elements: real
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 459:13: -> real
					{
						adaptor.addChild(root_0, stream_real.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:460:5: imaginary
					{
					pushFollow(FOLLOW_imaginary_in_atom4837);
					imaginary356=imaginary();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_imaginary.add(imaginary356.getTree());
					// AST REWRITE
					// elements: imaginary
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 460:15: -> imaginary
					{
						adaptor.addChild(root_0, stream_imaginary.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:461:5: stringDef
					{
					pushFollow(FOLLOW_stringDef_in_atom4847);
					stringDef357=stringDef();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_stringDef.add(stringDef357.getTree());
					// AST REWRITE
					// elements: stringDef
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 461:15: -> stringDef
					{
						adaptor.addChild(root_0, stream_stringDef.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:462:5: regularArray
					{
					pushFollow(FOLLOW_regularArray_in_atom4857);
					regularArray358=regularArray();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_regularArray.add(regularArray358.getTree());
					// AST REWRITE
					// elements: regularArray
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 462:18: -> regularArray
					{
						adaptor.addChild(root_0, stream_regularArray.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:463:5: cellArray
					{
					pushFollow(FOLLOW_cellArray_in_atom4867);
					cellArray359=cellArray();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_cellArray.add(cellArray359.getTree());
					// AST REWRITE
					// elements: cellArray
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 463:15: -> cellArray
					{
						adaptor.addChild(root_0, stream_cellArray.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:464:5: parenthesized
					{
					pushFollow(FOLLOW_parenthesized_in_atom4877);
					parenthesized360=parenthesized();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesized.add(parenthesized360.getTree());
					// AST REWRITE
					// elements: parenthesized
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 464:19: -> parenthesized
					{
						adaptor.addChild(root_0, stream_parenthesized.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:465:5: end
					{
					pushFollow(FOLLOW_end_in_atom4887);
					end361=end();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_end.add(end361.getTree());
					// AST REWRITE
					// elements: end
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 465:9: -> end
					{
						adaptor.addChild(root_0, stream_end.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:466:5: functionHandle
					{
					pushFollow(FOLLOW_functionHandle_in_atom4897);
					functionHandle362=functionHandle();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_functionHandle.add(functionHandle362.getTree());
					// AST REWRITE
					// elements: functionHandle
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 466:20: -> functionHandle
					{
						adaptor.addChild(root_0, stream_functionHandle.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:467:5: anonymousFunction
					{
					pushFollow(FOLLOW_anonymousFunction_in_atom4907);
					anonymousFunction363=anonymousFunction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_anonymousFunction.add(anonymousFunction363.getTree());
					// AST REWRITE
					// elements: anonymousFunction
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 467:23: -> anonymousFunction
					{
						adaptor.addChild(root_0, stream_anonymousFunction.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:468:5: metaclass
					{
					pushFollow(FOLLOW_metaclass_in_atom4917);
					metaclass364=metaclass();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_metaclass.add(metaclass364.getTree());
					// AST REWRITE
					// elements: metaclass
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 468:15: -> metaclass
					{
						adaptor.addChild(root_0, stream_metaclass.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "atom"


	public static class chain_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "chain"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:473:1: chain : (x1= var -> $x1) ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )* ;
	public final MatlabParser.chain_return chain() throws RecognitionException {
		MatlabParser.chain_return retval = new MatlabParser.chain_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;
		ParserRuleReturnScope x3 =null;
		ParserRuleReturnScope x4 =null;
		ParserRuleReturnScope x5 =null;
		ParserRuleReturnScope x6 =null;

		RewriteRuleSubtreeStream stream_parenthesisOperator=new RewriteRuleSubtreeStream(adaptor,"rule parenthesisOperator");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_dotExpressionOperator=new RewriteRuleSubtreeStream(adaptor,"rule dotExpressionOperator");
		RewriteRuleSubtreeStream stream_curlyBraceOperator=new RewriteRuleSubtreeStream(adaptor,"rule curlyBraceOperator");
		RewriteRuleSubtreeStream stream_atBaseOperator=new RewriteRuleSubtreeStream(adaptor,"rule atBaseOperator");
		RewriteRuleSubtreeStream stream_dotNameOperator=new RewriteRuleSubtreeStream(adaptor,"rule dotNameOperator");

		Chain_Begin();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:474:24: ( (x1= var -> $x1) ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:475:2: (x1= var -> $x1) ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:475:2: (x1= var -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:475:2: x1= var
			{
			pushFollow(FOLLOW_var_in_chain4942);
			x1=var();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_var.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 475:9: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:5: ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )*
			loop101:
			while (true) {
				int alt101=6;
				alt101 = dfa101.predict(input);
				switch (alt101) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:5: ( DOT LPAREN )=>x2= dotExpressionOperator
					{
					pushFollow(FOLLOW_dotExpressionOperator_in_chain4963);
					x2=dotExpressionOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dotExpressionOperator.add(x2.getTree());
					// AST REWRITE
					// elements: chain, x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 476:45: -> ^( DOTEXPRESSION[$x2.start] $chain $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:48: ^( DOTEXPRESSION[$x2.start] $chain $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DOTEXPRESSION, (x2!=null?(x2.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:477:5: x3= dotNameOperator
					{
					pushFollow(FOLLOW_dotNameOperator_in_chain4984);
					x3=dotNameOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dotNameOperator.add(x3.getTree());
					// AST REWRITE
					// elements: x3, chain
					// token labels: 
					// rule labels: x3, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x3=new RewriteRuleSubtreeStream(adaptor,"rule x3",x3!=null?x3.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 477:24: -> ^( DOTNAME[$x3.start] $chain $x3)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:477:27: ^( DOTNAME[$x3.start] $chain $x3)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DOTNAME, (x3!=null?(x3.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x3.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:478:5: x4= parenthesisOperator
					{
					pushFollow(FOLLOW_parenthesisOperator_in_chain5005);
					x4=parenthesisOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_parenthesisOperator.add(x4.getTree());
					// AST REWRITE
					// elements: x4, chain
					// token labels: 
					// rule labels: x4, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x4=new RewriteRuleSubtreeStream(adaptor,"rule x4",x4!=null?x4.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 478:28: -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:478:31: ^( PARENTHESIS[$x4.start] $chain ( $x4)? )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PARENTHESIS, (x4!=null?(x4.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:478:63: ( $x4)?
						if ( stream_x4.hasNext() ) {
							adaptor.addChild(root_1, stream_x4.nextTree());
						}
						stream_x4.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:479:5: x5= curlyBraceOperator
					{
					pushFollow(FOLLOW_curlyBraceOperator_in_chain5029);
					x5=curlyBraceOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_curlyBraceOperator.add(x5.getTree());
					// AST REWRITE
					// elements: chain, x5
					// token labels: 
					// rule labels: x5, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x5=new RewriteRuleSubtreeStream(adaptor,"rule x5",x5!=null?x5.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 479:27: -> ^( CURLYBRACE[$x5.start] $chain $x5)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:479:30: ^( CURLYBRACE[$x5.start] $chain $x5)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CURLYBRACE, (x5!=null?(x5.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x5.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:480:5: x6= atBaseOperator
					{
					pushFollow(FOLLOW_atBaseOperator_in_chain5050);
					x6=atBaseOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_atBaseOperator.add(x6.getTree());
					// AST REWRITE
					// elements: x6, chain
					// token labels: 
					// rule labels: x6, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x6=new RewriteRuleSubtreeStream(adaptor,"rule x6",x6!=null?x6.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 480:23: -> ^( ATBASE[$x6.start] $chain $x6)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:480:26: ^( ATBASE[$x6.start] $chain $x6)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ATBASE, (x6!=null?(x6.start):null)), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x6.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop101;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Chain_End();
		}
		return retval;
	}
	// $ANTLR end "chain"


	public static class var_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "var"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:484:1: var : name -> ^( VAR[\"\"] name ) ;
	public final MatlabParser.var_return var() throws RecognitionException {
		MatlabParser.var_return retval = new MatlabParser.var_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name365 =null;

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:484:5: ( name -> ^( VAR[\"\"] name ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:484:7: name
			{
			pushFollow(FOLLOW_name_in_var5079);
			name365=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name365.getTree());
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 484:12: -> ^( VAR[\"\"] name )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:484:15: ^( VAR[\"\"] name )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "var"


	public static class dotExpressionOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dotExpressionOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:486:1: dotExpressionOperator :{...}? => DOT LPAREN expression RPAREN -> expression ;
	public final MatlabParser.dotExpressionOperator_return dotExpressionOperator() throws RecognitionException {
		MatlabParser.dotExpressionOperator_return retval = new MatlabParser.dotExpressionOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT366=null;
		Token LPAREN367=null;
		Token RPAREN369=null;
		ParserRuleReturnScope expression368 =null;

		Object DOT366_tree=null;
		Object LPAREN367_tree=null;
		Object RPAREN369_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		Balance_EnterParenthesis();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:487:37: ({...}? => DOT LPAREN expression RPAREN -> expression )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:488:1: {...}? => DOT LPAREN expression RPAREN
			{
			if ( !((Chain_MayAddDotExpression())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dotExpressionOperator", "Chain_MayAddDotExpression()");
			}
			DOT366=(Token)match(input,DOT,FOLLOW_DOT_in_dotExpressionOperator5105); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOT.add(DOT366);

			LPAREN367=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_dotExpressionOperator5107); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN367);

			pushFollow(FOLLOW_expression_in_dotExpressionOperator5109);
			expression368=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression368.getTree());
			RPAREN369=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_dotExpressionOperator5111); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN369);

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 488:63: -> expression
			{
				adaptor.addChild(root_0, stream_expression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitParenthesis(); Chain_AddedDotExpression();
		}
		return retval;
	}
	// $ANTLR end "dotExpressionOperator"


	public static class dotNameOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dotNameOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:491:1: dotNameOperator :{...}? => DOT anyName -> anyName ;
	public final MatlabParser.dotNameOperator_return dotNameOperator() throws RecognitionException {
		MatlabParser.dotNameOperator_return retval = new MatlabParser.dotNameOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT370=null;
		ParserRuleReturnScope anyName371 =null;

		Object DOT370_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_anyName=new RewriteRuleSubtreeStream(adaptor,"rule anyName");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:491:17: ({...}? => DOT anyName -> anyName )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:491:19: {...}? => DOT anyName
			{
			if ( !((Chain_MayAddDotName())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dotNameOperator", "Chain_MayAddDotName()");
			}
			DOT370=(Token)match(input,DOT,FOLLOW_DOT_in_dotNameOperator5131); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOT.add(DOT370);

			pushFollow(FOLLOW_anyName_in_dotNameOperator5133);
			anyName371=anyName();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_anyName.add(anyName371.getTree());
			// AST REWRITE
			// elements: anyName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 491:58: -> anyName
			{
				adaptor.addChild(root_0, stream_anyName.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Chain_AddedDotName();
		}
		return retval;
	}
	// $ANTLR end "dotNameOperator"


	public static class anyName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "anyName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:494:1: anyName : xANYID -> ^( NAME[\"\"] xANYID ) ;
	public final MatlabParser.anyName_return anyName() throws RecognitionException {
		MatlabParser.anyName_return retval = new MatlabParser.anyName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xANYID372 =null;

		RewriteRuleSubtreeStream stream_xANYID=new RewriteRuleSubtreeStream(adaptor,"rule xANYID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:494:9: ( xANYID -> ^( NAME[\"\"] xANYID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:494:11: xANYID
			{
			pushFollow(FOLLOW_xANYID_in_anyName5150);
			xANYID372=xANYID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xANYID.add(xANYID372.getTree());
			// AST REWRITE
			// elements: xANYID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 494:18: -> ^( NAME[\"\"] xANYID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:494:21: ^( NAME[\"\"] xANYID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xANYID.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "anyName"


	public static class parenthesisOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parenthesisOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:496:1: parenthesisOperator :{...}? =>{...}? => LPAREN ( arguments )? RPAREN -> ( arguments )? ;
	public final MatlabParser.parenthesisOperator_return parenthesisOperator() throws RecognitionException {
		MatlabParser.parenthesisOperator_return retval = new MatlabParser.parenthesisOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN373=null;
		Token RPAREN375=null;
		ParserRuleReturnScope arguments374 =null;

		Object LPAREN373_tree=null;
		Object RPAREN375_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");

		Index_EnterParenthesis(); Balance_EnterParenthesis();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:497:63: ({...}? =>{...}? => LPAREN ( arguments )? RPAREN -> ( arguments )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:498:1: {...}? =>{...}? => LPAREN ( arguments )? RPAREN
			{
			if ( !((Chain_MayAddParenthesis())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parenthesisOperator", "Chain_MayAddParenthesis()");
			}
			if ( !((!Balance_InCreationOrStore_SpacesOnLeft())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parenthesisOperator", "!Balance_InCreationOrStore_SpacesOnLeft()");
			}
			LPAREN373=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesisOperator5179); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN373);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:498:86: ( arguments )?
			int alt102=2;
			int LA102_0 = input.LA(1);
			if ( (LA102_0==ID||LA102_0==IMAGINARY||LA102_0==LCURLY||(LA102_0 >= LPAREN && LA102_0 <= LSQUARE)||LA102_0==MINUS||LA102_0==NOT||LA102_0==PLUS||LA102_0==REAL||LA102_0==STRING) ) {
				alt102=1;
			}
			else if ( (LA102_0==END) && ((Index_IsActive()))) {
				alt102=1;
			}
			else if ( (LA102_0==AT||LA102_0==COLON||LA102_0==QUESTION) ) {
				alt102=1;
			}
			switch (alt102) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:498:87: arguments
					{
					pushFollow(FOLLOW_arguments_in_parenthesisOperator5182);
					arguments374=arguments();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_arguments.add(arguments374.getTree());
					}
					break;

			}

			RPAREN375=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesisOperator5186); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN375);

			// AST REWRITE
			// elements: arguments
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 498:106: -> ( arguments )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:498:109: ( arguments )?
				if ( stream_arguments.hasNext() ) {
					adaptor.addChild(root_0, stream_arguments.nextTree());
				}
				stream_arguments.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitParenthesis(); Index_ExitParenthesis(); Chain_AddedParenthesis();
		}
		return retval;
	}
	// $ANTLR end "parenthesisOperator"


	public static class arguments_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "arguments"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:1: arguments : argument ( COMMA argument )* -> ( argument )+ ;
	public final MatlabParser.arguments_return arguments() throws RecognitionException {
		MatlabParser.arguments_return retval = new MatlabParser.arguments_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA377=null;
		ParserRuleReturnScope argument376 =null;
		ParserRuleReturnScope argument378 =null;

		Object COMMA377_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_argument=new RewriteRuleSubtreeStream(adaptor,"rule argument");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:11: ( argument ( COMMA argument )* -> ( argument )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:13: argument ( COMMA argument )*
			{
			pushFollow(FOLLOW_argument_in_arguments5206);
			argument376=argument();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_argument.add(argument376.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:22: ( COMMA argument )*
			loop103:
			while (true) {
				int alt103=2;
				int LA103_0 = input.LA(1);
				if ( (LA103_0==COMMA) ) {
					alt103=1;
				}

				switch (alt103) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:501:23: COMMA argument
					{
					COMMA377=(Token)match(input,COMMA,FOLLOW_COMMA_in_arguments5209); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA377);

					pushFollow(FOLLOW_argument_in_arguments5211);
					argument378=argument();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_argument.add(argument378.getTree());
					}
					break;

				default :
					break loop103;
				}
			}

			// AST REWRITE
			// elements: argument
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 501:40: -> ( argument )+
			{
				if ( !(stream_argument.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_argument.hasNext() ) {
					adaptor.addChild(root_0, stream_argument.nextTree());
				}
				stream_argument.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "arguments"


	public static class argument_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "argument"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:503:1: argument : ( expression -> expression | COLON -> ALL[$COLON] );
	public final MatlabParser.argument_return argument() throws RecognitionException {
		MatlabParser.argument_return retval = new MatlabParser.argument_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COLON380=null;
		ParserRuleReturnScope expression379 =null;

		Object COLON380_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:503:10: ( expression -> expression | COLON -> ALL[$COLON] )
			int alt104=2;
			int LA104_0 = input.LA(1);
			if ( (LA104_0==ID||LA104_0==IMAGINARY||LA104_0==LCURLY||(LA104_0 >= LPAREN && LA104_0 <= LSQUARE)||LA104_0==MINUS||LA104_0==NOT||LA104_0==PLUS||LA104_0==REAL||LA104_0==STRING) ) {
				alt104=1;
			}
			else if ( (LA104_0==END) && ((Index_IsActive()))) {
				alt104=1;
			}
			else if ( (LA104_0==AT||LA104_0==QUESTION) ) {
				alt104=1;
			}
			else if ( (LA104_0==COLON) ) {
				alt104=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 104, 0, input);
				throw nvae;
			}

			switch (alt104) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:503:12: expression
					{
					pushFollow(FOLLOW_expression_in_argument5229);
					expression379=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression379.getTree());
					// AST REWRITE
					// elements: expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 503:23: -> expression
					{
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:504:6: COLON
					{
					COLON380=(Token)match(input,COLON,FOLLOW_COLON_in_argument5240); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON380);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 504:12: -> ALL[$COLON]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ALL, COLON380));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "argument"


	public static class curlyBraceOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "curlyBraceOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:507:1: curlyBraceOperator :{...}? =>{...}? => LCURLY arguments RCURLY -> arguments ;
	public final MatlabParser.curlyBraceOperator_return curlyBraceOperator() throws RecognitionException {
		MatlabParser.curlyBraceOperator_return retval = new MatlabParser.curlyBraceOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LCURLY381=null;
		Token RCURLY383=null;
		ParserRuleReturnScope arguments382 =null;

		Object LCURLY381_tree=null;
		Object RCURLY383_tree=null;
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");

		Index_EnterCurlyBrace(); Balance_EnterIndexCurlyBrace();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:508:66: ({...}? =>{...}? => LCURLY arguments RCURLY -> arguments )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:509:1: {...}? =>{...}? => LCURLY arguments RCURLY
			{
			if ( !((Chain_MayAddCurlyBrace())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "curlyBraceOperator", "Chain_MayAddCurlyBrace()");
			}
			if ( !((!Balance_InCreationOrStore_SpacesOnLeft())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "curlyBraceOperator", "!Balance_InCreationOrStore_SpacesOnLeft()");
			}
			LCURLY381=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_curlyBraceOperator5268); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY381);

			pushFollow(FOLLOW_arguments_in_curlyBraceOperator5270);
			arguments382=arguments();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_arguments.add(arguments382.getTree());
			RCURLY383=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_curlyBraceOperator5272); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY383);

			// AST REWRITE
			// elements: arguments
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 509:102: -> arguments
			{
				adaptor.addChild(root_0, stream_arguments.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitIndexCurlyBrace(); Index_ExitCurlyBrace(); Chain_AddedCurlyBrace();
		}
		return retval;
	}
	// $ANTLR end "curlyBraceOperator"


	public static class atBaseOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "atBaseOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:512:1: atBaseOperator :{...}? =>{...}? => AT classReference -> classReference ;
	public final MatlabParser.atBaseOperator_return atBaseOperator() throws RecognitionException {
		MatlabParser.atBaseOperator_return retval = new MatlabParser.atBaseOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AT384=null;
		ParserRuleReturnScope classReference385 =null;

		Object AT384_tree=null;
		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:512:16: ({...}? =>{...}? => AT classReference -> classReference )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:512:18: {...}? =>{...}? => AT classReference
			{
			if ( !((Chain_MayAddAtBase())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "atBaseOperator", "Chain_MayAddAtBase()");
			}
			if ( !((!Balance_InCreationOrStore_SpacesOnLeft())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "atBaseOperator", "!Balance_InCreationOrStore_SpacesOnLeft()");
			}
			AT384=(Token)match(input,AT,FOLLOW_AT_in_atBaseOperator5295); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_AT.add(AT384);

			pushFollow(FOLLOW_classReference_in_atBaseOperator5297);
			classReference385=classReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classReference.add(classReference385.getTree());
			// AST REWRITE
			// elements: classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 512:109: -> classReference
			{
				adaptor.addChild(root_0, stream_classReference.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Chain_AddedAtBase();
		}
		return retval;
	}
	// $ANTLR end "atBaseOperator"


	public static class real_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "real"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:517:1: real : REAL -> REAL ;
	public final MatlabParser.real_return real() throws RecognitionException {
		MatlabParser.real_return retval = new MatlabParser.real_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REAL386=null;

		Object REAL386_tree=null;
		RewriteRuleTokenStream stream_REAL=new RewriteRuleTokenStream(adaptor,"token REAL");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:517:6: ( REAL -> REAL )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:517:8: REAL
			{
			REAL386=(Token)match(input,REAL,FOLLOW_REAL_in_real5316); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL.add(REAL386);

			// AST REWRITE
			// elements: REAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 517:13: -> REAL
			{
				adaptor.addChild(root_0, stream_REAL.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "real"


	public static class imaginary_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "imaginary"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:521:1: imaginary : IMAGINARY -> IMAGINARY ;
	public final MatlabParser.imaginary_return imaginary() throws RecognitionException {
		MatlabParser.imaginary_return retval = new MatlabParser.imaginary_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token IMAGINARY387=null;

		Object IMAGINARY387_tree=null;
		RewriteRuleTokenStream stream_IMAGINARY=new RewriteRuleTokenStream(adaptor,"token IMAGINARY");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:521:11: ( IMAGINARY -> IMAGINARY )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:521:13: IMAGINARY
			{
			IMAGINARY387=(Token)match(input,IMAGINARY,FOLLOW_IMAGINARY_in_imaginary5331); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_IMAGINARY.add(IMAGINARY387);

			// AST REWRITE
			// elements: IMAGINARY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 521:23: -> IMAGINARY
			{
				adaptor.addChild(root_0, stream_IMAGINARY.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "imaginary"


	public static class stringDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "stringDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:525:1: stringDef : STRING -> STRING ;
	public final MatlabParser.stringDef_return stringDef() throws RecognitionException {
		MatlabParser.stringDef_return retval = new MatlabParser.stringDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token STRING388=null;

		Object STRING388_tree=null;
		RewriteRuleTokenStream stream_STRING=new RewriteRuleTokenStream(adaptor,"token STRING");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:525:11: ( STRING -> STRING )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:525:13: STRING
			{
			STRING388=(Token)match(input,STRING,FOLLOW_STRING_in_stringDef5346); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_STRING.add(STRING388);

			// AST REWRITE
			// elements: STRING
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 525:20: -> STRING
			{
				adaptor.addChild(root_0, stream_STRING.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "stringDef"


	public static class regularArray_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "regularArray"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:531:1: regularArray : LSQUARE rows RSQUARE -> ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) ) ;
	public final MatlabParser.regularArray_return regularArray() throws RecognitionException {
		MatlabParser.regularArray_return retval = new MatlabParser.regularArray_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE389=null;
		Token RSQUARE391=null;
		ParserRuleReturnScope rows390 =null;

		Object LSQUARE389_tree=null;
		Object RSQUARE391_tree=null;
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_rows=new RewriteRuleSubtreeStream(adaptor,"rule rows");

		Balance_EnterCreationSquareBrace();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:532:45: ( LSQUARE rows RSQUARE -> ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:533:1: LSQUARE rows RSQUARE
			{
			LSQUARE389=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_regularArray5368); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE389);

			pushFollow(FOLLOW_rows_in_regularArray5370);
			rows390=rows();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_rows.add(rows390.getTree());
			RSQUARE391=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_regularArray5372); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE391);

			// AST REWRITE
			// elements: rows
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 533:22: -> ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:533:25: ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(REGULARARRAY, LSQUARE389), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:533:50: ^( VCAT[\"\"] rows )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(VCAT, ""), root_2);
				adaptor.addChild(root_2, stream_rows.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitCreationSquareBrace();
		}
		return retval;
	}
	// $ANTLR end "regularArray"


	public static class rows_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rows"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:1: rows : row ( ( SEMICOLON | EOL ) row )* -> ( row )+ ;
	public final MatlabParser.rows_return rows() throws RecognitionException {
		MatlabParser.rows_return retval = new MatlabParser.rows_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SEMICOLON393=null;
		Token EOL394=null;
		ParserRuleReturnScope row392 =null;
		ParserRuleReturnScope row395 =null;

		Object SEMICOLON393_tree=null;
		Object EOL394_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");
		RewriteRuleSubtreeStream stream_row=new RewriteRuleSubtreeStream(adaptor,"rule row");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:6: ( row ( ( SEMICOLON | EOL ) row )* -> ( row )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:8: row ( ( SEMICOLON | EOL ) row )*
			{
			pushFollow(FOLLOW_row_in_rows5399);
			row392=row();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_row.add(row392.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:12: ( ( SEMICOLON | EOL ) row )*
			loop106:
			while (true) {
				int alt106=2;
				int LA106_0 = input.LA(1);
				if ( (LA106_0==EOL||LA106_0==SEMICOLON) ) {
					alt106=1;
				}

				switch (alt106) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:13: ( SEMICOLON | EOL ) row
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:13: ( SEMICOLON | EOL )
					int alt105=2;
					int LA105_0 = input.LA(1);
					if ( (LA105_0==SEMICOLON) ) {
						alt105=1;
					}
					else if ( (LA105_0==EOL) ) {
						alt105=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 105, 0, input);
						throw nvae;
					}

					switch (alt105) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:14: SEMICOLON
							{
							SEMICOLON393=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_rows5403); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON393);

							}
							break;
						case 2 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:536:26: EOL
							{
							EOL394=(Token)match(input,EOL,FOLLOW_EOL_in_rows5407); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_EOL.add(EOL394);

							}
							break;

					}

					pushFollow(FOLLOW_row_in_rows5410);
					row395=row();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_row.add(row395.getTree());
					}
					break;

				default :
					break loop106;
				}
			}

			// AST REWRITE
			// elements: row
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 536:37: -> ( row )+
			{
				if ( !(stream_row.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_row.hasNext() ) {
					adaptor.addChild(root_0, stream_row.nextTree());
				}
				stream_row.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rows"


	public static class row_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "row"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:1: row : ( ( COMMA )? columns ( COMMA )? -> ^( HCAT[\"\"] columns ) | COMMA -> HCAT[\"\"] | () -> HCAT[\"\"] );
	public final MatlabParser.row_return row() throws RecognitionException {
		MatlabParser.row_return retval = new MatlabParser.row_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA396=null;
		Token COMMA398=null;
		Token COMMA399=null;
		ParserRuleReturnScope columns397 =null;

		Object COMMA396_tree=null;
		Object COMMA398_tree=null;
		Object COMMA399_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_columns=new RewriteRuleSubtreeStream(adaptor,"rule columns");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:5: ( ( COMMA )? columns ( COMMA )? -> ^( HCAT[\"\"] columns ) | COMMA -> HCAT[\"\"] | () -> HCAT[\"\"] )
			int alt109=3;
			int LA109_0 = input.LA(1);
			if ( (LA109_0==COMMA) ) {
				switch ( input.LA(2) ) {
				case NOT:
					{
					alt109=1;
					}
					break;
				case AT:
				case END:
				case ID:
				case IMAGINARY:
				case LCURLY:
				case LPAREN:
				case LSQUARE:
				case MINUS:
				case PLUS:
				case QUESTION:
				case REAL:
				case STRING:
					{
					alt109=1;
					}
					break;
				case EOL:
				case RCURLY:
				case RSQUARE:
				case SEMICOLON:
					{
					alt109=2;
					}
					break;
				default:
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 109, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}
			}
			else if ( (LA109_0==ID||LA109_0==IMAGINARY||LA109_0==LCURLY||(LA109_0 >= LPAREN && LA109_0 <= LSQUARE)||LA109_0==MINUS||LA109_0==NOT||LA109_0==PLUS||LA109_0==REAL||LA109_0==STRING) ) {
				alt109=1;
			}
			else if ( (LA109_0==END) && ((Index_IsActive()))) {
				alt109=1;
			}
			else if ( (LA109_0==AT||LA109_0==QUESTION) ) {
				alt109=1;
			}
			else if ( (LA109_0==EOL||LA109_0==RCURLY||(LA109_0 >= RSQUARE && LA109_0 <= SEMICOLON)) ) {
				alt109=3;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 109, 0, input);
				throw nvae;
			}

			switch (alt109) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:7: ( COMMA )? columns ( COMMA )?
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:7: ( COMMA )?
					int alt107=2;
					int LA107_0 = input.LA(1);
					if ( (LA107_0==COMMA) ) {
						alt107=1;
					}
					switch (alt107) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:8: COMMA
							{
							COMMA396=(Token)match(input,COMMA,FOLLOW_COMMA_in_row5429); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA396);

							}
							break;

					}

					pushFollow(FOLLOW_columns_in_row5433);
					columns397=columns();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_columns.add(columns397.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:24: ( COMMA )?
					int alt108=2;
					int LA108_0 = input.LA(1);
					if ( (LA108_0==COMMA) ) {
						alt108=1;
					}
					switch (alt108) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:25: COMMA
							{
							COMMA398=(Token)match(input,COMMA,FOLLOW_COMMA_in_row5436); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA398);

							}
							break;

					}

					// AST REWRITE
					// elements: columns
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 538:33: -> ^( HCAT[\"\"] columns )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:538:36: ^( HCAT[\"\"] columns )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(HCAT, ""), root_1);
						adaptor.addChild(root_1, stream_columns.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:539:4: COMMA
					{
					COMMA399=(Token)match(input,COMMA,FOLLOW_COMMA_in_row5452); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA399);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 539:10: -> HCAT[\"\"]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(HCAT, ""));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:540:4: ()
					{
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:540:4: ()
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:540:5: 
					{
					}

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 540:7: -> HCAT[\"\"]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(HCAT, ""));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "row"


	public static class columns_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "columns"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:1: columns : column ({...}? => ( COMMA )? column )* -> ( column )+ ;
	public final MatlabParser.columns_return columns() throws RecognitionException {
		MatlabParser.columns_return retval = new MatlabParser.columns_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA401=null;
		ParserRuleReturnScope column400 =null;
		ParserRuleReturnScope column402 =null;

		Object COMMA401_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_column=new RewriteRuleSubtreeStream(adaptor,"rule column");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:9: ( column ({...}? => ( COMMA )? column )* -> ( column )+ )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:11: column ({...}? => ( COMMA )? column )*
			{
			pushFollow(FOLLOW_column_in_columns5478);
			column400=column();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_column.add(column400.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:18: ({...}? => ( COMMA )? column )*
			loop111:
			while (true) {
				int alt111=2;
				int LA111_0 = input.LA(1);
				if ( (LA111_0==COMMA) ) {
					int LA111_1 = input.LA(2);
					if ( (LA111_1==NOT) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
						alt111=1;
					}
					else if ( (LA111_1==AT||LA111_1==END||LA111_1==ID||LA111_1==IMAGINARY||LA111_1==LCURLY||(LA111_1 >= LPAREN && LA111_1 <= LSQUARE)||LA111_1==MINUS||LA111_1==PLUS||LA111_1==QUESTION||LA111_1==REAL||LA111_1==STRING) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
						alt111=1;
					}

				}
				else if ( (LA111_0==ID||LA111_0==IMAGINARY||LA111_0==LCURLY||(LA111_0 >= LPAREN && LA111_0 <= LSQUARE)||LA111_0==MINUS||LA111_0==NOT||LA111_0==PLUS||LA111_0==REAL||LA111_0==STRING) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
					alt111=1;
				}
				else if ( (LA111_0==END) && (((Index_IsActive())&&(Separator_CommaFollowsOrSpacesPrecede())))) {
					alt111=1;
				}
				else if ( (LA111_0==AT||LA111_0==QUESTION) && ((Separator_CommaFollowsOrSpacesPrecede()))) {
					alt111=1;
				}

				switch (alt111) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:19: {...}? => ( COMMA )? column
					{
					if ( !((Separator_CommaFollowsOrSpacesPrecede())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "columns", "Separator_CommaFollowsOrSpacesPrecede()");
					}
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:64: ( COMMA )?
					int alt110=2;
					int LA110_0 = input.LA(1);
					if ( (LA110_0==COMMA) ) {
						alt110=1;
					}
					switch (alt110) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:543:65: COMMA
							{
							COMMA401=(Token)match(input,COMMA,FOLLOW_COMMA_in_columns5485); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA401);

							}
							break;

					}

					pushFollow(FOLLOW_column_in_columns5489);
					column402=column();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column.add(column402.getTree());
					}
					break;

				default :
					break loop111;
				}
			}

			// AST REWRITE
			// elements: column
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 543:82: -> ( column )+
			{
				if ( !(stream_column.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_column.hasNext() ) {
					adaptor.addChild(root_0, stream_column.nextTree());
				}
				stream_column.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "columns"


	public static class column_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "column"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:1: column : ( ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )=> NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) | expression -> expression );
	public final MatlabParser.column_return column() throws RecognitionException {
		MatlabParser.column_return retval = new MatlabParser.column_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token NOT403=null;
		ParserRuleReturnScope expression404 =null;

		Object NOT403_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:8: ( ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )=> NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) | expression -> expression )
			int alt112=2;
			int LA112_0 = input.LA(1);
			if ( (LA112_0==NOT) ) {
				int LA112_1 = input.LA(2);
				if ( (synpred8_MatlabParser()) ) {
					alt112=1;
				}
				else if ( (true) ) {
					alt112=2;
				}

			}
			else if ( (LA112_0==ID||LA112_0==IMAGINARY||LA112_0==LCURLY||(LA112_0 >= LPAREN && LA112_0 <= LSQUARE)||LA112_0==MINUS||LA112_0==PLUS||LA112_0==REAL||LA112_0==STRING) ) {
				alt112=2;
			}
			else if ( (LA112_0==END) && ((Index_IsActive()))) {
				alt112=2;
			}
			else if ( (LA112_0==AT||LA112_0==QUESTION) ) {
				alt112=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 112, 0, input);
				throw nvae;
			}

			switch (alt112) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:10: ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )=> NOT
					{
					NOT403=(Token)match(input,NOT,FOLLOW_NOT_in_column5528); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT403);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 545:58: -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:61: ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR, ""), root_1);
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:71: ^( NAME[\"\"] ID[$NOT] )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_2);
						adaptor.addChild(root_2, (Object)adaptor.create(ID, NOT403));
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:546:7: expression
					{
					pushFollow(FOLLOW_expression_in_column5551);
					expression404=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression404.getTree());
					// AST REWRITE
					// elements: expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 546:18: -> expression
					{
						adaptor.addChild(root_0, stream_expression.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "column"


	public static class cellArray_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cellArray"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:551:1: cellArray : LCURLY rows RCURLY -> ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) ) ;
	public final MatlabParser.cellArray_return cellArray() throws RecognitionException {
		MatlabParser.cellArray_return retval = new MatlabParser.cellArray_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LCURLY405=null;
		Token RCURLY407=null;
		ParserRuleReturnScope rows406 =null;

		Object LCURLY405_tree=null;
		Object RCURLY407_tree=null;
		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,"token LCURLY");
		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_rows=new RewriteRuleSubtreeStream(adaptor,"rule rows");

		Balance_EnterCreationCurlyBrace();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:552:44: ( LCURLY rows RCURLY -> ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:553:1: LCURLY rows RCURLY
			{
			LCURLY405=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_cellArray5575); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY405);

			pushFollow(FOLLOW_rows_in_cellArray5577);
			rows406=rows();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_rows.add(rows406.getTree());
			RCURLY407=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_cellArray5579); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY407);

			// AST REWRITE
			// elements: rows
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 553:20: -> ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:553:23: ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CELLARRAY, LCURLY405), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:553:44: ^( VCAT[\"\"] rows )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(VCAT, ""), root_2);
				adaptor.addChild(root_2, stream_rows.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitCreationCurlyBrace();
		}
		return retval;
	}
	// $ANTLR end "cellArray"


	public static class parenthesized_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parenthesized"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:558:1: parenthesized : LPAREN expression RPAREN -> expression ;
	public final MatlabParser.parenthesized_return parenthesized() throws RecognitionException {
		MatlabParser.parenthesized_return retval = new MatlabParser.parenthesized_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN408=null;
		Token RPAREN410=null;
		ParserRuleReturnScope expression409 =null;

		Object LPAREN408_tree=null;
		Object RPAREN410_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		Balance_EnterParenthesis();
		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:559:37: ( LPAREN expression RPAREN -> expression )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:560:1: LPAREN expression RPAREN
			{
			LPAREN408=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_parenthesized5613); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN408);

			pushFollow(FOLLOW_expression_in_parenthesized5615);
			expression409=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression409.getTree());
			RPAREN410=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_parenthesized5617); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN410);

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 560:26: -> expression
			{
				adaptor.addChild(root_0, stream_expression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			Balance_ExitParenthesis();
		}
		return retval;
	}
	// $ANTLR end "parenthesized"


	public static class end_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "end"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:565:1: end :{...}? => END -> END ;
	public final MatlabParser.end_return end() throws RecognitionException {
		MatlabParser.end_return retval = new MatlabParser.end_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END411=null;

		Object END411_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:565:5: ({...}? => END -> END )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:565:7: {...}? => END
			{
			if ( !((Index_IsActive())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "end", "Index_IsActive()");
			}
			END411=(Token)match(input,END,FOLLOW_END_in_end5639); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END411);

			// AST REWRITE
			// elements: END
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 565:33: -> END
			{
				adaptor.addChild(root_0, stream_END.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "end"


	public static class functionHandle_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionHandle"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:569:1: functionHandle : AT functionReference -> ^( FUNCTIONHANDLE[$AT] functionReference ) ;
	public final MatlabParser.functionHandle_return functionHandle() throws RecognitionException {
		MatlabParser.functionHandle_return retval = new MatlabParser.functionHandle_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AT412=null;
		ParserRuleReturnScope functionReference413 =null;

		Object AT412_tree=null;
		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_functionReference=new RewriteRuleSubtreeStream(adaptor,"rule functionReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:569:16: ( AT functionReference -> ^( FUNCTIONHANDLE[$AT] functionReference ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:569:18: AT functionReference
			{
			AT412=(Token)match(input,AT,FOLLOW_AT_in_functionHandle5654); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_AT.add(AT412);

			pushFollow(FOLLOW_functionReference_in_functionHandle5656);
			functionReference413=functionReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_functionReference.add(functionReference413.getTree());
			// AST REWRITE
			// elements: functionReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 569:39: -> ^( FUNCTIONHANDLE[$AT] functionReference )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:569:42: ^( FUNCTIONHANDLE[$AT] functionReference )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNCTIONHANDLE, AT412), root_1);
				adaptor.addChild(root_1, stream_functionReference.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionHandle"


	public static class functionReference_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "functionReference"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:571:1: functionReference : fullFunctioName -> ^( FUNCTIONREF[\"\"] fullFunctioName ) ;
	public final MatlabParser.functionReference_return functionReference() throws RecognitionException {
		MatlabParser.functionReference_return retval = new MatlabParser.functionReference_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope fullFunctioName414 =null;

		RewriteRuleSubtreeStream stream_fullFunctioName=new RewriteRuleSubtreeStream(adaptor,"rule fullFunctioName");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:571:19: ( fullFunctioName -> ^( FUNCTIONREF[\"\"] fullFunctioName ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:571:21: fullFunctioName
			{
			pushFollow(FOLLOW_fullFunctioName_in_functionReference5674);
			fullFunctioName414=fullFunctioName();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_fullFunctioName.add(fullFunctioName414.getTree());
			// AST REWRITE
			// elements: fullFunctioName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 571:37: -> ^( FUNCTIONREF[\"\"] fullFunctioName )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:571:40: ^( FUNCTIONREF[\"\"] fullFunctioName )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNCTIONREF, ""), root_1);
				adaptor.addChild(root_1, stream_fullFunctioName.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "functionReference"


	public static class fullFunctioName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "fullFunctioName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:1: fullFunctioName : xID ( DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) ;
	public final MatlabParser.fullFunctioName_return fullFunctioName() throws RecognitionException {
		MatlabParser.fullFunctioName_return retval = new MatlabParser.fullFunctioName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOT416=null;
		ParserRuleReturnScope xID415 =null;
		ParserRuleReturnScope xANYID417 =null;

		Object DOT416_tree=null;
		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_xANYID=new RewriteRuleSubtreeStream(adaptor,"rule xANYID");
		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:17: ( xID ( DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:19: xID ( DOT xANYID )*
			{
			pushFollow(FOLLOW_xID_in_fullFunctioName5692);
			xID415=xID();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xID.add(xID415.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:23: ( DOT xANYID )*
			loop113:
			while (true) {
				int alt113=2;
				int LA113_0 = input.LA(1);
				if ( (LA113_0==DOT) ) {
					alt113=1;
				}

				switch (alt113) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:24: DOT xANYID
					{
					DOT416=(Token)match(input,DOT,FOLLOW_DOT_in_fullFunctioName5695); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_DOT.add(DOT416);

					pushFollow(FOLLOW_xANYID_in_fullFunctioName5697);
					xANYID417=xANYID();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xANYID.add(xANYID417.getTree());
					}
					break;

				default :
					break loop113;
				}
			}

			// AST REWRITE
			// elements: xID, xANYID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 573:37: -> ^( NAME[\"\"] xID ( xANYID )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:40: ^( NAME[\"\"] xID ( xANYID )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_xID.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:573:55: ( xANYID )*
				while ( stream_xANYID.hasNext() ) {
					adaptor.addChild(root_1, stream_xANYID.nextTree());
				}
				stream_xANYID.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "fullFunctioName"


	public static class anonymousFunction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "anonymousFunction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:1: anonymousFunction : AT inputPortion expression -> ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression ) ;
	public final MatlabParser.anonymousFunction_return anonymousFunction() throws RecognitionException {
		MatlabParser.anonymousFunction_return retval = new MatlabParser.anonymousFunction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AT418=null;
		ParserRuleReturnScope inputPortion419 =null;
		ParserRuleReturnScope expression420 =null;

		Object AT418_tree=null;
		RewriteRuleTokenStream stream_AT=new RewriteRuleTokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:19: ( AT inputPortion expression -> ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:21: AT inputPortion expression
			{
			AT418=(Token)match(input,AT,FOLLOW_AT_in_anonymousFunction5724); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_AT.add(AT418);

			pushFollow(FOLLOW_inputPortion_in_anonymousFunction5726);
			inputPortion419=inputPortion();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion419.getTree());
			pushFollow(FOLLOW_expression_in_anonymousFunction5728);
			expression420=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression420.getTree());
			// AST REWRITE
			// elements: inputPortion, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 577:48: -> ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:51: ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ANONYMOUSFUNCTION, AT418), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:577:76: ( inputPortion )?
				if ( stream_inputPortion.hasNext() ) {
					adaptor.addChild(root_1, stream_inputPortion.nextTree());
				}
				stream_inputPortion.reset();

				adaptor.addChild(root_1, stream_expression.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "anonymousFunction"


	public static class metaclass_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "metaclass"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:581:1: metaclass : QUESTION classReference -> ^( QUESTION classReference ) ;
	public final MatlabParser.metaclass_return metaclass() throws RecognitionException {
		MatlabParser.metaclass_return retval = new MatlabParser.metaclass_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token QUESTION421=null;
		ParserRuleReturnScope classReference422 =null;

		Object QUESTION421_tree=null;
		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,"token QUESTION");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:581:11: ( QUESTION classReference -> ^( QUESTION classReference ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:581:13: QUESTION classReference
			{
			QUESTION421=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_metaclass5753); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION421);

			pushFollow(FOLLOW_classReference_in_metaclass5755);
			classReference422=classReference();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_classReference.add(classReference422.getTree());
			// AST REWRITE
			// elements: classReference, QUESTION
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 581:37: -> ^( QUESTION classReference )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:581:40: ^( QUESTION classReference )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_QUESTION.nextNode(), root_1);
				adaptor.addChild(root_1, stream_classReference.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "metaclass"


	public static class xEOS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xEOS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:585:1: xEOS : ( SEMICOLON -> NOPRINT[$SEMICOLON] | COMMA -> PRINT[$COMMA] | EOL -> PRINT[$EOL] );
	public final MatlabParser.xEOS_return xEOS() throws RecognitionException {
		MatlabParser.xEOS_return retval = new MatlabParser.xEOS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SEMICOLON423=null;
		Token COMMA424=null;
		Token EOL425=null;

		Object SEMICOLON423_tree=null;
		Object COMMA424_tree=null;
		Object EOL425_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_SEMICOLON=new RewriteRuleTokenStream(adaptor,"token SEMICOLON");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:585:6: ( SEMICOLON -> NOPRINT[$SEMICOLON] | COMMA -> PRINT[$COMMA] | EOL -> PRINT[$EOL] )
			int alt114=3;
			switch ( input.LA(1) ) {
			case SEMICOLON:
				{
				alt114=1;
				}
				break;
			case COMMA:
				{
				alt114=2;
				}
				break;
			case EOL:
				{
				alt114=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 114, 0, input);
				throw nvae;
			}
			switch (alt114) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:585:8: SEMICOLON
					{
					SEMICOLON423=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_xEOS5774); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SEMICOLON.add(SEMICOLON423);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 585:18: -> NOPRINT[$SEMICOLON]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(NOPRINT, SEMICOLON423));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:586:5: COMMA
					{
					COMMA424=(Token)match(input,COMMA,FOLLOW_COMMA_in_xEOS5785); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA424);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 586:11: -> PRINT[$COMMA]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(PRINT, COMMA424));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:587:5: EOL
					{
					EOL425=(Token)match(input,EOL,FOLLOW_EOL_in_xEOS5796); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL425);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 587:9: -> PRINT[$EOL]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(PRINT, EOL425));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xEOS"


	public static class xEOL_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xEOL"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:590:1: xEOL : EOL -> PRINT[$EOL] ;
	public final MatlabParser.xEOL_return xEOL() throws RecognitionException {
		MatlabParser.xEOL_return retval = new MatlabParser.xEOL_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL426=null;

		Object EOL426_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:590:6: ( EOL -> PRINT[$EOL] )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:590:8: EOL
			{
			EOL426=(Token)match(input,EOL,FOLLOW_EOL_in_xEOL5812); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOL.add(EOL426);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 590:12: -> PRINT[$EOL]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PRINT, EOL426));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xEOL"


	public static class xID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:592:1: xID : ID -> ID ;
	public final MatlabParser.xID_return xID() throws RecognitionException {
		MatlabParser.xID_return retval = new MatlabParser.xID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID427=null;

		Object ID427_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:592:5: ( ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:592:7: ID
			{
			ID427=(Token)match(input,ID,FOLLOW_ID_in_xID5826); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID427);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 592:10: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xID"


	public static class xANYID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xANYID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:594:1: xANYID : ( ID -> ID | BREAK -> ID[$BREAK] | CASE -> ID[$CASE] | CATCH -> ID[$CATCH] | CLASSDEF -> ID[$CLASSDEF] | CONTINUE -> ID[$CONTINUE] | ELSE -> ID[$ELSE] | ELSEIF -> ID[$ELSEIF] | END -> ID[$END] | FOR -> ID[$FOR] | FUNCTION -> ID[$FUNCTION] | GLOBAL -> ID[$GLOBAL] | IF -> ID[$IF] | OTHERWISE -> ID[$OTHERWISE] | PARFOR -> ID[$PARFOR] | PERSISTENT -> ID[$PERSISTENT] | RETURN -> ID[$RETURN] | SPMD -> ID[$SPMD] | SWITCH -> ID[$SWITCH] | TRY -> ID[$TRY] | WHILE -> ID[$WHILE] );
	public final MatlabParser.xANYID_return xANYID() throws RecognitionException {
		MatlabParser.xANYID_return retval = new MatlabParser.xANYID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID428=null;
		Token BREAK429=null;
		Token CASE430=null;
		Token CATCH431=null;
		Token CLASSDEF432=null;
		Token CONTINUE433=null;
		Token ELSE434=null;
		Token ELSEIF435=null;
		Token END436=null;
		Token FOR437=null;
		Token FUNCTION438=null;
		Token GLOBAL439=null;
		Token IF440=null;
		Token OTHERWISE441=null;
		Token PARFOR442=null;
		Token PERSISTENT443=null;
		Token RETURN444=null;
		Token SPMD445=null;
		Token SWITCH446=null;
		Token TRY447=null;
		Token WHILE448=null;

		Object ID428_tree=null;
		Object BREAK429_tree=null;
		Object CASE430_tree=null;
		Object CATCH431_tree=null;
		Object CLASSDEF432_tree=null;
		Object CONTINUE433_tree=null;
		Object ELSE434_tree=null;
		Object ELSEIF435_tree=null;
		Object END436_tree=null;
		Object FOR437_tree=null;
		Object FUNCTION438_tree=null;
		Object GLOBAL439_tree=null;
		Object IF440_tree=null;
		Object OTHERWISE441_tree=null;
		Object PARFOR442_tree=null;
		Object PERSISTENT443_tree=null;
		Object RETURN444_tree=null;
		Object SPMD445_tree=null;
		Object SWITCH446_tree=null;
		Object TRY447_tree=null;
		Object WHILE448_tree=null;
		RewriteRuleTokenStream stream_ELSEIF=new RewriteRuleTokenStream(adaptor,"token ELSEIF");
		RewriteRuleTokenStream stream_PERSISTENT=new RewriteRuleTokenStream(adaptor,"token PERSISTENT");
		RewriteRuleTokenStream stream_CLASSDEF=new RewriteRuleTokenStream(adaptor,"token CLASSDEF");
		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,"token FOR");
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");
		RewriteRuleTokenStream stream_CASE=new RewriteRuleTokenStream(adaptor,"token CASE");
		RewriteRuleTokenStream stream_CONTINUE=new RewriteRuleTokenStream(adaptor,"token CONTINUE");
		RewriteRuleTokenStream stream_RETURN=new RewriteRuleTokenStream(adaptor,"token RETURN");
		RewriteRuleTokenStream stream_SPMD=new RewriteRuleTokenStream(adaptor,"token SPMD");
		RewriteRuleTokenStream stream_CATCH=new RewriteRuleTokenStream(adaptor,"token CATCH");
		RewriteRuleTokenStream stream_PARFOR=new RewriteRuleTokenStream(adaptor,"token PARFOR");
		RewriteRuleTokenStream stream_BREAK=new RewriteRuleTokenStream(adaptor,"token BREAK");
		RewriteRuleTokenStream stream_GLOBAL=new RewriteRuleTokenStream(adaptor,"token GLOBAL");
		RewriteRuleTokenStream stream_OTHERWISE=new RewriteRuleTokenStream(adaptor,"token OTHERWISE");
		RewriteRuleTokenStream stream_ELSE=new RewriteRuleTokenStream(adaptor,"token ELSE");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_SWITCH=new RewriteRuleTokenStream(adaptor,"token SWITCH");
		RewriteRuleTokenStream stream_TRY=new RewriteRuleTokenStream(adaptor,"token TRY");
		RewriteRuleTokenStream stream_WHILE=new RewriteRuleTokenStream(adaptor,"token WHILE");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");
		RewriteRuleTokenStream stream_IF=new RewriteRuleTokenStream(adaptor,"token IF");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:594:8: ( ID -> ID | BREAK -> ID[$BREAK] | CASE -> ID[$CASE] | CATCH -> ID[$CATCH] | CLASSDEF -> ID[$CLASSDEF] | CONTINUE -> ID[$CONTINUE] | ELSE -> ID[$ELSE] | ELSEIF -> ID[$ELSEIF] | END -> ID[$END] | FOR -> ID[$FOR] | FUNCTION -> ID[$FUNCTION] | GLOBAL -> ID[$GLOBAL] | IF -> ID[$IF] | OTHERWISE -> ID[$OTHERWISE] | PARFOR -> ID[$PARFOR] | PERSISTENT -> ID[$PERSISTENT] | RETURN -> ID[$RETURN] | SPMD -> ID[$SPMD] | SWITCH -> ID[$SWITCH] | TRY -> ID[$TRY] | WHILE -> ID[$WHILE] )
			int alt115=21;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt115=1;
				}
				break;
			case BREAK:
				{
				alt115=2;
				}
				break;
			case CASE:
				{
				alt115=3;
				}
				break;
			case CATCH:
				{
				alt115=4;
				}
				break;
			case CLASSDEF:
				{
				alt115=5;
				}
				break;
			case CONTINUE:
				{
				alt115=6;
				}
				break;
			case ELSE:
				{
				alt115=7;
				}
				break;
			case ELSEIF:
				{
				alt115=8;
				}
				break;
			case END:
				{
				alt115=9;
				}
				break;
			case FOR:
				{
				alt115=10;
				}
				break;
			case FUNCTION:
				{
				alt115=11;
				}
				break;
			case GLOBAL:
				{
				alt115=12;
				}
				break;
			case IF:
				{
				alt115=13;
				}
				break;
			case OTHERWISE:
				{
				alt115=14;
				}
				break;
			case PARFOR:
				{
				alt115=15;
				}
				break;
			case PERSISTENT:
				{
				alt115=16;
				}
				break;
			case RETURN:
				{
				alt115=17;
				}
				break;
			case SPMD:
				{
				alt115=18;
				}
				break;
			case SWITCH:
				{
				alt115=19;
				}
				break;
			case TRY:
				{
				alt115=20;
				}
				break;
			case WHILE:
				{
				alt115=21;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 115, 0, input);
				throw nvae;
			}
			switch (alt115) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:594:10: ID
					{
					ID428=(Token)match(input,ID,FOLLOW_ID_in_xANYID5839); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(ID428);

					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 594:13: -> ID
					{
						adaptor.addChild(root_0, stream_ID.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:595:7: BREAK
					{
					BREAK429=(Token)match(input,BREAK,FOLLOW_BREAK_in_xANYID5851); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_BREAK.add(BREAK429);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 595:13: -> ID[$BREAK]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, BREAK429));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:596:7: CASE
					{
					CASE430=(Token)match(input,CASE,FOLLOW_CASE_in_xANYID5864); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CASE.add(CASE430);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 596:12: -> ID[$CASE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, CASE430));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:597:7: CATCH
					{
					CATCH431=(Token)match(input,CATCH,FOLLOW_CATCH_in_xANYID5877); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CATCH.add(CATCH431);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 597:13: -> ID[$CATCH]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, CATCH431));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:598:7: CLASSDEF
					{
					CLASSDEF432=(Token)match(input,CLASSDEF,FOLLOW_CLASSDEF_in_xANYID5890); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CLASSDEF.add(CLASSDEF432);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 598:16: -> ID[$CLASSDEF]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, CLASSDEF432));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:599:7: CONTINUE
					{
					CONTINUE433=(Token)match(input,CONTINUE,FOLLOW_CONTINUE_in_xANYID5903); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_CONTINUE.add(CONTINUE433);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 599:16: -> ID[$CONTINUE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, CONTINUE433));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:600:7: ELSE
					{
					ELSE434=(Token)match(input,ELSE,FOLLOW_ELSE_in_xANYID5916); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ELSE.add(ELSE434);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 600:12: -> ID[$ELSE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, ELSE434));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:601:7: ELSEIF
					{
					ELSEIF435=(Token)match(input,ELSEIF,FOLLOW_ELSEIF_in_xANYID5929); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ELSEIF.add(ELSEIF435);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 601:14: -> ID[$ELSEIF]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, ELSEIF435));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:602:7: END
					{
					END436=(Token)match(input,END,FOLLOW_END_in_xANYID5942); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_END.add(END436);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 602:11: -> ID[$END]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, END436));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:603:7: FOR
					{
					FOR437=(Token)match(input,FOR,FOLLOW_FOR_in_xANYID5955); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_FOR.add(FOR437);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 603:11: -> ID[$FOR]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, FOR437));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:604:7: FUNCTION
					{
					FUNCTION438=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_xANYID5968); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION438);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 604:16: -> ID[$FUNCTION]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, FUNCTION438));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 12 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:605:7: GLOBAL
					{
					GLOBAL439=(Token)match(input,GLOBAL,FOLLOW_GLOBAL_in_xANYID5981); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_GLOBAL.add(GLOBAL439);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 605:14: -> ID[$GLOBAL]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, GLOBAL439));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 13 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:606:7: IF
					{
					IF440=(Token)match(input,IF,FOLLOW_IF_in_xANYID5994); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_IF.add(IF440);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 606:10: -> ID[$IF]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, IF440));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 14 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:607:7: OTHERWISE
					{
					OTHERWISE441=(Token)match(input,OTHERWISE,FOLLOW_OTHERWISE_in_xANYID6007); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OTHERWISE.add(OTHERWISE441);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 607:17: -> ID[$OTHERWISE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, OTHERWISE441));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 15 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:608:7: PARFOR
					{
					PARFOR442=(Token)match(input,PARFOR,FOLLOW_PARFOR_in_xANYID6020); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PARFOR.add(PARFOR442);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 608:14: -> ID[$PARFOR]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, PARFOR442));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 16 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:609:7: PERSISTENT
					{
					PERSISTENT443=(Token)match(input,PERSISTENT,FOLLOW_PERSISTENT_in_xANYID6033); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PERSISTENT.add(PERSISTENT443);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 609:18: -> ID[$PERSISTENT]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, PERSISTENT443));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 17 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:610:7: RETURN
					{
					RETURN444=(Token)match(input,RETURN,FOLLOW_RETURN_in_xANYID6046); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RETURN.add(RETURN444);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 610:14: -> ID[$RETURN]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, RETURN444));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 18 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:611:7: SPMD
					{
					SPMD445=(Token)match(input,SPMD,FOLLOW_SPMD_in_xANYID6059); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SPMD.add(SPMD445);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 611:12: -> ID[$SPMD]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, SPMD445));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 19 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:612:7: SWITCH
					{
					SWITCH446=(Token)match(input,SWITCH,FOLLOW_SWITCH_in_xANYID6072); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_SWITCH.add(SWITCH446);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 612:14: -> ID[$SWITCH]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, SWITCH446));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 20 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:613:7: TRY
					{
					TRY447=(Token)match(input,TRY,FOLLOW_TRY_in_xANYID6085); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_TRY.add(TRY447);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 613:11: -> ID[$TRY]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, TRY447));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 21 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:614:7: WHILE
					{
					WHILE448=(Token)match(input,WHILE,FOLLOW_WHILE_in_xANYID6098); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_WHILE.add(WHILE448);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 614:13: -> ID[$WHILE]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, WHILE448));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xANYID"


	public static class xFUNCTIONID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xFUNCTIONID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:617:1: xFUNCTIONID : ( ID -> ID | END -> ID[$END] );
	public final MatlabParser.xFUNCTIONID_return xFUNCTIONID() throws RecognitionException {
		MatlabParser.xFUNCTIONID_return retval = new MatlabParser.xFUNCTIONID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID449=null;
		Token END450=null;

		Object ID449_tree=null;
		Object END450_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:617:13: ( ID -> ID | END -> ID[$END] )
			int alt116=2;
			int LA116_0 = input.LA(1);
			if ( (LA116_0==ID) ) {
				alt116=1;
			}
			else if ( (LA116_0==END) ) {
				alt116=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 116, 0, input);
				throw nvae;
			}

			switch (alt116) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:617:15: ID
					{
					ID449=(Token)match(input,ID,FOLLOW_ID_in_xFUNCTIONID6116); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(ID449);

					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 617:18: -> ID
					{
						adaptor.addChild(root_0, stream_ID.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:618:6: END
					{
					END450=(Token)match(input,END,FOLLOW_END_in_xFUNCTIONID6127); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_END.add(END450);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 618:10: -> ID[$END]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, END450));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xFUNCTIONID"


	public static class xPARAMETERID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xPARAMETERID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:621:1: xPARAMETERID : ( ID -> ID | NOT -> ID[$NOT] );
	public final MatlabParser.xPARAMETERID_return xPARAMETERID() throws RecognitionException {
		MatlabParser.xPARAMETERID_return retval = new MatlabParser.xPARAMETERID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID451=null;
		Token NOT452=null;

		Object ID451_tree=null;
		Object NOT452_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:621:14: ( ID -> ID | NOT -> ID[$NOT] )
			int alt117=2;
			int LA117_0 = input.LA(1);
			if ( (LA117_0==ID) ) {
				alt117=1;
			}
			else if ( (LA117_0==NOT) ) {
				alt117=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 117, 0, input);
				throw nvae;
			}

			switch (alt117) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:621:16: ID
					{
					ID451=(Token)match(input,ID,FOLLOW_ID_in_xPARAMETERID6144); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ID.add(ID451);

					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 621:19: -> ID
					{
						adaptor.addChild(root_0, stream_ID.nextNode());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:622:7: NOT
					{
					NOT452=(Token)match(input,NOT,FOLLOW_NOT_in_xPARAMETERID6156); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT452);

					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 622:11: -> ID[$NOT]
					{
						adaptor.addChild(root_0, (Object)adaptor.create(ID, NOT452));
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xPARAMETERID"


	public static class xEVENTS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xEVENTS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:625:1: xEVENTS :{...}? => ID -> ID ;
	public final MatlabParser.xEVENTS_return xEVENTS() throws RecognitionException {
		MatlabParser.xEVENTS_return retval = new MatlabParser.xEVENTS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID453=null;

		Object ID453_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:625:9: ({...}? => ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:625:11: {...}? => ID
			{
			if ( !((Keyword_EventsIdFollows())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xEVENTS", "Keyword_EventsIdFollows()");
			}
			ID453=(Token)match(input,ID,FOLLOW_ID_in_xEVENTS6177); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID453);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 625:45: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xEVENTS"


	public static class xPROPERTIES_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xPROPERTIES"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:627:1: xPROPERTIES :{...}? => ID -> ID ;
	public final MatlabParser.xPROPERTIES_return xPROPERTIES() throws RecognitionException {
		MatlabParser.xPROPERTIES_return retval = new MatlabParser.xPROPERTIES_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID454=null;

		Object ID454_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:627:13: ({...}? => ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:627:15: {...}? => ID
			{
			if ( !((Keyword_PropertiesIdFollows())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xPROPERTIES", "Keyword_PropertiesIdFollows()");
			}
			ID454=(Token)match(input,ID,FOLLOW_ID_in_xPROPERTIES6193); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID454);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 627:53: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xPROPERTIES"


	public static class xMETHODS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xMETHODS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:629:1: xMETHODS :{...}? => ID -> ID ;
	public final MatlabParser.xMETHODS_return xMETHODS() throws RecognitionException {
		MatlabParser.xMETHODS_return retval = new MatlabParser.xMETHODS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID455=null;

		Object ID455_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:629:10: ({...}? => ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:629:12: {...}? => ID
			{
			if ( !((Keyword_MethodsIdFollows())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xMETHODS", "Keyword_MethodsIdFollows()");
			}
			ID455=(Token)match(input,ID,FOLLOW_ID_in_xMETHODS6209); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID455);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 629:47: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xMETHODS"


	public static class xENUMERATION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xENUMERATION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:631:1: xENUMERATION :{...}? => ID -> ID ;
	public final MatlabParser.xENUMERATION_return xENUMERATION() throws RecognitionException {
		MatlabParser.xENUMERATION_return retval = new MatlabParser.xENUMERATION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID456=null;

		Object ID456_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:631:14: ({...}? => ID -> ID )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:631:16: {...}? => ID
			{
			if ( !((Keyword_EnumerationIdFollows())) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xENUMERATION", "Keyword_EnumerationIdFollows()");
			}
			ID456=(Token)match(input,ID,FOLLOW_ID_in_xENUMERATION6225); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID456);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 631:55: -> ID
			{
				adaptor.addChild(root_0, stream_ID.nextNode());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xENUMERATION"


	public static class aspectFile_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectFile"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:1: aspectFile : ( EOL )* aspectDef ( EOL )* EOF -> ^( ASPECTFILE[\"\"] aspectDef ) ;
	public final MatlabParser.aspectFile_return aspectFile() throws RecognitionException {
		MatlabParser.aspectFile_return retval = new MatlabParser.aspectFile_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EOL457=null;
		Token EOL459=null;
		Token EOF460=null;
		ParserRuleReturnScope aspectDef458 =null;

		Object EOL457_tree=null;
		Object EOL459_tree=null;
		Object EOF460_tree=null;
		RewriteRuleTokenStream stream_EOL=new RewriteRuleTokenStream(adaptor,"token EOL");
		RewriteRuleTokenStream stream_EOF=new RewriteRuleTokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_aspectDef=new RewriteRuleSubtreeStream(adaptor,"rule aspectDef");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:12: ( ( EOL )* aspectDef ( EOL )* EOF -> ^( ASPECTFILE[\"\"] aspectDef ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:14: ( EOL )* aspectDef ( EOL )* EOF
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:14: ( EOL )*
			loop118:
			while (true) {
				int alt118=2;
				int LA118_0 = input.LA(1);
				if ( (LA118_0==EOL) ) {
					alt118=1;
				}

				switch (alt118) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:15: EOL
					{
					EOL457=(Token)match(input,EOL,FOLLOW_EOL_in_aspectFile6241); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL457);

					}
					break;

				default :
					break loop118;
				}
			}

			pushFollow(FOLLOW_aspectDef_in_aspectFile6245);
			aspectDef458=aspectDef();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectDef.add(aspectDef458.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:31: ( EOL )*
			loop119:
			while (true) {
				int alt119=2;
				int LA119_0 = input.LA(1);
				if ( (LA119_0==EOL) ) {
					alt119=1;
				}

				switch (alt119) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:32: EOL
					{
					EOL459=(Token)match(input,EOL,FOLLOW_EOL_in_aspectFile6248); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EOL.add(EOL459);

					}
					break;

				default :
					break loop119;
				}
			}

			EOF460=(Token)match(input,EOF,FOLLOW_EOF_in_aspectFile6252); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EOF.add(EOF460);

			// AST REWRITE
			// elements: aspectDef
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 635:42: -> ^( ASPECTFILE[\"\"] aspectDef )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:635:45: ^( ASPECTFILE[\"\"] aspectDef )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTFILE, ""), root_1);
				adaptor.addChild(root_1, stream_aspectDef.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectFile"


	public static class aspectDef_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectDef"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:1: aspectDef : ASPECT name xEOS aspectSections END -> ^( ASPECTDEF name ( aspectSections )? ) ;
	public final MatlabParser.aspectDef_return aspectDef() throws RecognitionException {
		MatlabParser.aspectDef_return retval = new MatlabParser.aspectDef_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASPECT461=null;
		Token END465=null;
		ParserRuleReturnScope name462 =null;
		ParserRuleReturnScope xEOS463 =null;
		ParserRuleReturnScope aspectSections464 =null;

		Object ASPECT461_tree=null;
		Object END465_tree=null;
		RewriteRuleTokenStream stream_ASPECT=new RewriteRuleTokenStream(adaptor,"token ASPECT");
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_aspectSections=new RewriteRuleSubtreeStream(adaptor,"rule aspectSections");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:11: ( ASPECT name xEOS aspectSections END -> ^( ASPECTDEF name ( aspectSections )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:13: ASPECT name xEOS aspectSections END
			{
			ASPECT461=(Token)match(input,ASPECT,FOLLOW_ASPECT_in_aspectDef6270); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ASPECT.add(ASPECT461);

			pushFollow(FOLLOW_name_in_aspectDef6272);
			name462=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name462.getTree());
			pushFollow(FOLLOW_xEOS_in_aspectDef6274);
			xEOS463=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS463.getTree());
			pushFollow(FOLLOW_aspectSections_in_aspectDef6276);
			aspectSections464=aspectSections();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectSections.add(aspectSections464.getTree());
			END465=(Token)match(input,END,FOLLOW_END_in_aspectDef6278); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END465);

			// AST REWRITE
			// elements: name, aspectSections
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 637:49: -> ^( ASPECTDEF name ( aspectSections )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:52: ^( ASPECTDEF name ( aspectSections )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTDEF, "ASPECTDEF"), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:637:69: ( aspectSections )?
				if ( stream_aspectSections.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectSections.nextTree());
				}
				stream_aspectSections.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectDef"


	public static class aspectSections_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSections"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:1: aspectSections : ( aspectSection | xEOS )* -> ( aspectSection )* ;
	public final MatlabParser.aspectSections_return aspectSections() throws RecognitionException {
		MatlabParser.aspectSections_return retval = new MatlabParser.aspectSections_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectSection466 =null;
		ParserRuleReturnScope xEOS467 =null;

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_aspectSection=new RewriteRuleSubtreeStream(adaptor,"rule aspectSection");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:16: ( ( aspectSection | xEOS )* -> ( aspectSection )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:18: ( aspectSection | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:18: ( aspectSection | xEOS )*
			loop120:
			while (true) {
				int alt120=3;
				int LA120_0 = input.LA(1);
				if ( (LA120_0==ID) && (((Keyword_IdFollows("patterns"))||(Keyword_EnumerationIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_IdFollows("actions"))||(Keyword_EventsIdFollows())||(Keyword_MethodsIdFollows())))) {
					alt120=1;
				}
				else if ( (LA120_0==COMMA||LA120_0==EOL||LA120_0==SEMICOLON) ) {
					alt120=2;
				}

				switch (alt120) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:19: aspectSection
					{
					pushFollow(FOLLOW_aspectSection_in_aspectSections6301);
					aspectSection466=aspectSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectSection.add(aspectSection466.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:35: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_aspectSections6305);
					xEOS467=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS467.getTree());
					}
					break;

				default :
					break loop120;
				}
			}

			// AST REWRITE
			// elements: aspectSection
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 639:42: -> ( aspectSection )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:639:45: ( aspectSection )*
				while ( stream_aspectSection.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectSection.nextTree());
				}
				stream_aspectSection.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSections"


	public static class aspectSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:641:1: aspectSection : ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection | aspectPatternSection -> aspectPatternSection | aspectActionSection -> aspectActionSection );
	public final MatlabParser.aspectSection_return aspectSection() throws RecognitionException {
		MatlabParser.aspectSection_return retval = new MatlabParser.aspectSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope eventSection468 =null;
		ParserRuleReturnScope propertySection469 =null;
		ParserRuleReturnScope methodSection470 =null;
		ParserRuleReturnScope enumerationSection471 =null;
		ParserRuleReturnScope aspectPatternSection472 =null;
		ParserRuleReturnScope aspectActionSection473 =null;

		RewriteRuleSubtreeStream stream_propertySection=new RewriteRuleSubtreeStream(adaptor,"rule propertySection");
		RewriteRuleSubtreeStream stream_methodSection=new RewriteRuleSubtreeStream(adaptor,"rule methodSection");
		RewriteRuleSubtreeStream stream_aspectPatternSection=new RewriteRuleSubtreeStream(adaptor,"rule aspectPatternSection");
		RewriteRuleSubtreeStream stream_eventSection=new RewriteRuleSubtreeStream(adaptor,"rule eventSection");
		RewriteRuleSubtreeStream stream_aspectActionSection=new RewriteRuleSubtreeStream(adaptor,"rule aspectActionSection");
		RewriteRuleSubtreeStream stream_enumerationSection=new RewriteRuleSubtreeStream(adaptor,"rule enumerationSection");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:641:15: ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection | aspectPatternSection -> aspectPatternSection | aspectActionSection -> aspectActionSection )
			int alt121=6;
			int LA121_0 = input.LA(1);
			if ( (LA121_0==ID) && (((Keyword_IdFollows("patterns"))||(Keyword_EnumerationIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_IdFollows("actions"))||(Keyword_EventsIdFollows())||(Keyword_MethodsIdFollows())))) {
				int LA121_1 = input.LA(2);
				if ( ((Keyword_EventsIdFollows())) ) {
					alt121=1;
				}
				else if ( ((Keyword_PropertiesIdFollows())) ) {
					alt121=2;
				}
				else if ( ((Keyword_MethodsIdFollows())) ) {
					alt121=3;
				}
				else if ( ((Keyword_EnumerationIdFollows())) ) {
					alt121=4;
				}
				else if ( ((Keyword_IdFollows("patterns"))) ) {
					alt121=5;
				}
				else if ( ((Keyword_IdFollows("actions"))) ) {
					alt121=6;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 121, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt121) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:641:17: eventSection
					{
					pushFollow(FOLLOW_eventSection_in_aspectSection6323);
					eventSection468=eventSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_eventSection.add(eventSection468.getTree());
					// AST REWRITE
					// elements: eventSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 641:30: -> eventSection
					{
						adaptor.addChild(root_0, stream_eventSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:642:8: propertySection
					{
					pushFollow(FOLLOW_propertySection_in_aspectSection6336);
					propertySection469=propertySection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_propertySection.add(propertySection469.getTree());
					// AST REWRITE
					// elements: propertySection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 642:24: -> propertySection
					{
						adaptor.addChild(root_0, stream_propertySection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:643:11: methodSection
					{
					pushFollow(FOLLOW_methodSection_in_aspectSection6352);
					methodSection470=methodSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_methodSection.add(methodSection470.getTree());
					// AST REWRITE
					// elements: methodSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 643:25: -> methodSection
					{
						adaptor.addChild(root_0, stream_methodSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:644:11: enumerationSection
					{
					pushFollow(FOLLOW_enumerationSection_in_aspectSection6368);
					enumerationSection471=enumerationSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_enumerationSection.add(enumerationSection471.getTree());
					// AST REWRITE
					// elements: enumerationSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 644:30: -> enumerationSection
					{
						adaptor.addChild(root_0, stream_enumerationSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:645:8: aspectPatternSection
					{
					pushFollow(FOLLOW_aspectPatternSection_in_aspectSection6381);
					aspectPatternSection472=aspectPatternSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectPatternSection.add(aspectPatternSection472.getTree());
					// AST REWRITE
					// elements: aspectPatternSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 645:29: -> aspectPatternSection
					{
						adaptor.addChild(root_0, stream_aspectPatternSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:646:8: aspectActionSection
					{
					pushFollow(FOLLOW_aspectActionSection_in_aspectSection6394);
					aspectActionSection473=aspectActionSection();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectActionSection.add(aspectActionSection473.getTree());
					// AST REWRITE
					// elements: aspectActionSection
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 646:28: -> aspectActionSection
					{
						adaptor.addChild(root_0, stream_aspectActionSection.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSection"


	public static class aspectActionSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActionSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:1: aspectActionSection : wACTIONS aspectActions END -> ^( ASPECTACTIONSECTION[$wACTIONS.start] ( aspectActions )? ) ;
	public final MatlabParser.aspectActionSection_return aspectActionSection() throws RecognitionException {
		MatlabParser.aspectActionSection_return retval = new MatlabParser.aspectActionSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END476=null;
		ParserRuleReturnScope wACTIONS474 =null;
		ParserRuleReturnScope aspectActions475 =null;

		Object END476_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_wACTIONS=new RewriteRuleSubtreeStream(adaptor,"rule wACTIONS");
		RewriteRuleSubtreeStream stream_aspectActions=new RewriteRuleSubtreeStream(adaptor,"rule aspectActions");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:21: ( wACTIONS aspectActions END -> ^( ASPECTACTIONSECTION[$wACTIONS.start] ( aspectActions )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:23: wACTIONS aspectActions END
			{
			pushFollow(FOLLOW_wACTIONS_in_aspectActionSection6417);
			wACTIONS474=wACTIONS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wACTIONS.add(wACTIONS474.getTree());
			pushFollow(FOLLOW_aspectActions_in_aspectActionSection6419);
			aspectActions475=aspectActions();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectActions.add(aspectActions475.getTree());
			END476=(Token)match(input,END,FOLLOW_END_in_aspectActionSection6421); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END476);

			// AST REWRITE
			// elements: aspectActions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 651:50: -> ^( ASPECTACTIONSECTION[$wACTIONS.start] ( aspectActions )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:53: ^( ASPECTACTIONSECTION[$wACTIONS.start] ( aspectActions )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTACTIONSECTION, (wACTIONS474!=null?(wACTIONS474.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:651:92: ( aspectActions )?
				if ( stream_aspectActions.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectActions.nextTree());
				}
				stream_aspectActions.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActionSection"


	public static class aspectActions_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActions"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:1: aspectActions : ( aspectAction | xEOS )* -> ( aspectAction )* ;
	public final MatlabParser.aspectActions_return aspectActions() throws RecognitionException {
		MatlabParser.aspectActions_return retval = new MatlabParser.aspectActions_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectAction477 =null;
		ParserRuleReturnScope xEOS478 =null;

		RewriteRuleSubtreeStream stream_aspectAction=new RewriteRuleSubtreeStream(adaptor,"rule aspectAction");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:15: ( ( aspectAction | xEOS )* -> ( aspectAction )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:17: ( aspectAction | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:17: ( aspectAction | xEOS )*
			loop122:
			while (true) {
				int alt122=3;
				int LA122_0 = input.LA(1);
				if ( (LA122_0==ID) ) {
					alt122=1;
				}
				else if ( (LA122_0==COMMA||LA122_0==EOL||LA122_0==SEMICOLON) ) {
					alt122=2;
				}

				switch (alt122) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:18: aspectAction
					{
					pushFollow(FOLLOW_aspectAction_in_aspectActions6443);
					aspectAction477=aspectAction();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectAction.add(aspectAction477.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:33: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_aspectActions6447);
					xEOS478=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS478.getTree());
					}
					break;

				default :
					break loop122;
				}
			}

			// AST REWRITE
			// elements: aspectAction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 653:40: -> ( aspectAction )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:653:43: ( aspectAction )*
				while ( stream_aspectAction.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectAction.nextTree());
				}
				stream_aspectAction.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActions"


	public static class aspectAction_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectAction"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:1: aspectAction : aspectActionSignature aspectActionBody END -> ^( ASPECTACTION aspectActionSignature ( aspectActionBody )? ) ;
	public final MatlabParser.aspectAction_return aspectAction() throws RecognitionException {
		MatlabParser.aspectAction_return retval = new MatlabParser.aspectAction_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END481=null;
		ParserRuleReturnScope aspectActionSignature479 =null;
		ParserRuleReturnScope aspectActionBody480 =null;

		Object END481_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_aspectActionSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectActionSignature");
		RewriteRuleSubtreeStream stream_aspectActionBody=new RewriteRuleSubtreeStream(adaptor,"rule aspectActionBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:14: ( aspectActionSignature aspectActionBody END -> ^( ASPECTACTION aspectActionSignature ( aspectActionBody )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:16: aspectActionSignature aspectActionBody END
			{
			pushFollow(FOLLOW_aspectActionSignature_in_aspectAction6465);
			aspectActionSignature479=aspectActionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectActionSignature.add(aspectActionSignature479.getTree());
			pushFollow(FOLLOW_aspectActionBody_in_aspectAction6467);
			aspectActionBody480=aspectActionBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectActionBody.add(aspectActionBody480.getTree());
			END481=(Token)match(input,END,FOLLOW_END_in_aspectAction6469); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END481);

			// AST REWRITE
			// elements: aspectActionSignature, aspectActionBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 655:59: -> ^( ASPECTACTION aspectActionSignature ( aspectActionBody )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:62: ^( ASPECTACTION aspectActionSignature ( aspectActionBody )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTACTION, "ASPECTACTION"), root_1);
				adaptor.addChild(root_1, stream_aspectActionSignature.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:655:99: ( aspectActionBody )?
				if ( stream_aspectActionBody.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectActionBody.nextTree());
				}
				stream_aspectActionBody.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectAction"


	public static class aspectActionSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActionSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:1: aspectActionSignature : name COLON aspectActionType ( COLON )? aspectExpression ( COLON inputPortion )? -> name aspectActionType aspectExpression ( inputPortion )? ;
	public final MatlabParser.aspectActionSignature_return aspectActionSignature() throws RecognitionException {
		MatlabParser.aspectActionSignature_return retval = new MatlabParser.aspectActionSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COLON483=null;
		Token COLON485=null;
		Token COLON487=null;
		ParserRuleReturnScope name482 =null;
		ParserRuleReturnScope aspectActionType484 =null;
		ParserRuleReturnScope aspectExpression486 =null;
		ParserRuleReturnScope inputPortion488 =null;

		Object COLON483_tree=null;
		Object COLON485_tree=null;
		Object COLON487_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_aspectExpression=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_aspectActionType=new RewriteRuleSubtreeStream(adaptor,"rule aspectActionType");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:23: ( name COLON aspectActionType ( COLON )? aspectExpression ( COLON inputPortion )? -> name aspectActionType aspectExpression ( inputPortion )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:25: name COLON aspectActionType ( COLON )? aspectExpression ( COLON inputPortion )?
			{
			pushFollow(FOLLOW_name_in_aspectActionSignature6490);
			name482=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name482.getTree());
			COLON483=(Token)match(input,COLON,FOLLOW_COLON_in_aspectActionSignature6492); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON483);

			pushFollow(FOLLOW_aspectActionType_in_aspectActionSignature6494);
			aspectActionType484=aspectActionType();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectActionType.add(aspectActionType484.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:53: ( COLON )?
			int alt123=2;
			int LA123_0 = input.LA(1);
			if ( (LA123_0==COLON) ) {
				alt123=1;
			}
			switch (alt123) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:54: COLON
					{
					COLON485=(Token)match(input,COLON,FOLLOW_COLON_in_aspectActionSignature6497); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON485);

					}
					break;

			}

			pushFollow(FOLLOW_aspectExpression_in_aspectActionSignature6501);
			aspectExpression486=aspectExpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression.add(aspectExpression486.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:79: ( COLON inputPortion )?
			int alt124=2;
			int LA124_0 = input.LA(1);
			if ( (LA124_0==COLON) ) {
				alt124=1;
			}
			switch (alt124) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:80: COLON inputPortion
					{
					COLON487=(Token)match(input,COLON,FOLLOW_COLON_in_aspectActionSignature6504); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON487);

					pushFollow(FOLLOW_inputPortion_in_aspectActionSignature6506);
					inputPortion488=inputPortion();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_inputPortion.add(inputPortion488.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: inputPortion, aspectActionType, name, aspectExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 657:101: -> name aspectActionType aspectExpression ( inputPortion )?
			{
				adaptor.addChild(root_0, stream_name.nextTree());
				adaptor.addChild(root_0, stream_aspectActionType.nextTree());
				adaptor.addChild(root_0, stream_aspectExpression.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:657:143: ( inputPortion )?
				if ( stream_inputPortion.hasNext() ) {
					adaptor.addChild(root_0, stream_inputPortion.nextTree());
				}
				stream_inputPortion.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActionSignature"


	public static class aspectActionType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActionType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:659:1: aspectActionType : ( wBEFORE -> wBEFORE | wAFTER -> wAFTER | wAROUND -> wAROUND );
	public final MatlabParser.aspectActionType_return aspectActionType() throws RecognitionException {
		MatlabParser.aspectActionType_return retval = new MatlabParser.aspectActionType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wBEFORE489 =null;
		ParserRuleReturnScope wAFTER490 =null;
		ParserRuleReturnScope wAROUND491 =null;

		RewriteRuleSubtreeStream stream_wAFTER=new RewriteRuleSubtreeStream(adaptor,"rule wAFTER");
		RewriteRuleSubtreeStream stream_wBEFORE=new RewriteRuleSubtreeStream(adaptor,"rule wBEFORE");
		RewriteRuleSubtreeStream stream_wAROUND=new RewriteRuleSubtreeStream(adaptor,"rule wAROUND");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:659:18: ( wBEFORE -> wBEFORE | wAFTER -> wAFTER | wAROUND -> wAROUND )
			int alt125=3;
			int LA125_0 = input.LA(1);
			if ( (LA125_0==ID) && (((Keyword_IdFollows("after"))||(Keyword_IdFollows("before"))||(Keyword_IdFollows("around"))))) {
				int LA125_1 = input.LA(2);
				if ( ((Keyword_IdFollows("before"))) ) {
					alt125=1;
				}
				else if ( ((Keyword_IdFollows("after"))) ) {
					alt125=2;
				}
				else if ( ((Keyword_IdFollows("around"))) ) {
					alt125=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 125, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt125) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:659:20: wBEFORE
					{
					pushFollow(FOLLOW_wBEFORE_in_aspectActionType6530);
					wBEFORE489=wBEFORE();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wBEFORE.add(wBEFORE489.getTree());
					// AST REWRITE
					// elements: wBEFORE
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 659:28: -> wBEFORE
					{
						adaptor.addChild(root_0, stream_wBEFORE.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:660:20: wAFTER
					{
					pushFollow(FOLLOW_wAFTER_in_aspectActionType6555);
					wAFTER490=wAFTER();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wAFTER.add(wAFTER490.getTree());
					// AST REWRITE
					// elements: wAFTER
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 660:27: -> wAFTER
					{
						adaptor.addChild(root_0, stream_wAFTER.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:661:8: wAROUND
					{
					pushFollow(FOLLOW_wAROUND_in_aspectActionType6568);
					wAROUND491=wAROUND();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wAROUND.add(wAROUND491.getTree());
					// AST REWRITE
					// elements: wAROUND
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 661:16: -> wAROUND
					{
						adaptor.addChild(root_0, stream_wAROUND.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActionType"


	public static class aspectActionBody_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectActionBody"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:664:1: aspectActionBody : closeBody -> ( closeBody )? ;
	public final MatlabParser.aspectActionBody_return aspectActionBody() throws RecognitionException {
		MatlabParser.aspectActionBody_return retval = new MatlabParser.aspectActionBody_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope closeBody492 =null;

		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:664:18: ( closeBody -> ( closeBody )? )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:664:20: closeBody
			{
			pushFollow(FOLLOW_closeBody_in_aspectActionBody6586);
			closeBody492=closeBody();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_closeBody.add(closeBody492.getTree());
			// AST REWRITE
			// elements: closeBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 664:30: -> ( closeBody )?
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:664:33: ( closeBody )?
				if ( stream_closeBody.hasNext() ) {
					adaptor.addChild(root_0, stream_closeBody.nextTree());
				}
				stream_closeBody.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectActionBody"


	public static class aspectPatternSection_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPatternSection"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:1: aspectPatternSection : wPATTERNS aspectPatterns END -> ^( ASPECTPATTERNSECTION[$wPATTERNS.start] ( aspectPatterns )? ) ;
	public final MatlabParser.aspectPatternSection_return aspectPatternSection() throws RecognitionException {
		MatlabParser.aspectPatternSection_return retval = new MatlabParser.aspectPatternSection_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token END495=null;
		ParserRuleReturnScope wPATTERNS493 =null;
		ParserRuleReturnScope aspectPatterns494 =null;

		Object END495_tree=null;
		RewriteRuleTokenStream stream_END=new RewriteRuleTokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_wPATTERNS=new RewriteRuleSubtreeStream(adaptor,"rule wPATTERNS");
		RewriteRuleSubtreeStream stream_aspectPatterns=new RewriteRuleSubtreeStream(adaptor,"rule aspectPatterns");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:22: ( wPATTERNS aspectPatterns END -> ^( ASPECTPATTERNSECTION[$wPATTERNS.start] ( aspectPatterns )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:24: wPATTERNS aspectPatterns END
			{
			pushFollow(FOLLOW_wPATTERNS_in_aspectPatternSection6604);
			wPATTERNS493=wPATTERNS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wPATTERNS.add(wPATTERNS493.getTree());
			pushFollow(FOLLOW_aspectPatterns_in_aspectPatternSection6606);
			aspectPatterns494=aspectPatterns();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectPatterns.add(aspectPatterns494.getTree());
			END495=(Token)match(input,END,FOLLOW_END_in_aspectPatternSection6608); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_END.add(END495);

			// AST REWRITE
			// elements: aspectPatterns
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 668:53: -> ^( ASPECTPATTERNSECTION[$wPATTERNS.start] ( aspectPatterns )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:56: ^( ASPECTPATTERNSECTION[$wPATTERNS.start] ( aspectPatterns )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTPATTERNSECTION, (wPATTERNS493!=null?(wPATTERNS493.start):null)), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:668:97: ( aspectPatterns )?
				if ( stream_aspectPatterns.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectPatterns.nextTree());
				}
				stream_aspectPatterns.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPatternSection"


	public static class aspectPatterns_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPatterns"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:1: aspectPatterns : ( aspectPattern | xEOS )* -> ( aspectPattern )* ;
	public final MatlabParser.aspectPatterns_return aspectPatterns() throws RecognitionException {
		MatlabParser.aspectPatterns_return retval = new MatlabParser.aspectPatterns_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectPattern496 =null;
		ParserRuleReturnScope xEOS497 =null;

		RewriteRuleSubtreeStream stream_aspectPattern=new RewriteRuleSubtreeStream(adaptor,"rule aspectPattern");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:16: ( ( aspectPattern | xEOS )* -> ( aspectPattern )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:18: ( aspectPattern | xEOS )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:18: ( aspectPattern | xEOS )*
			loop126:
			while (true) {
				int alt126=3;
				int LA126_0 = input.LA(1);
				if ( (LA126_0==ID) ) {
					alt126=1;
				}
				else if ( (LA126_0==COMMA||LA126_0==EOL||LA126_0==SEMICOLON) ) {
					alt126=2;
				}

				switch (alt126) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:19: aspectPattern
					{
					pushFollow(FOLLOW_aspectPattern_in_aspectPatterns6630);
					aspectPattern496=aspectPattern();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectPattern.add(aspectPattern496.getTree());
					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:35: xEOS
					{
					pushFollow(FOLLOW_xEOS_in_aspectPatterns6634);
					xEOS497=xEOS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xEOS.add(xEOS497.getTree());
					}
					break;

				default :
					break loop126;
				}
			}

			// AST REWRITE
			// elements: aspectPattern
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 670:42: -> ( aspectPattern )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:670:45: ( aspectPattern )*
				while ( stream_aspectPattern.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectPattern.nextTree());
				}
				stream_aspectPattern.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPatterns"


	public static class aspectPattern_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPattern"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:672:1: aspectPattern : name COLON aspectExpression xEOS -> ^( ASPECTPATTERN name aspectExpression ) ;
	public final MatlabParser.aspectPattern_return aspectPattern() throws RecognitionException {
		MatlabParser.aspectPattern_return retval = new MatlabParser.aspectPattern_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COLON499=null;
		ParserRuleReturnScope name498 =null;
		ParserRuleReturnScope aspectExpression500 =null;
		ParserRuleReturnScope xEOS501 =null;

		Object COLON499_tree=null;
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_aspectExpression=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:672:15: ( name COLON aspectExpression xEOS -> ^( ASPECTPATTERN name aspectExpression ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:672:17: name COLON aspectExpression xEOS
			{
			pushFollow(FOLLOW_name_in_aspectPattern6652);
			name498=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name498.getTree());
			COLON499=(Token)match(input,COLON,FOLLOW_COLON_in_aspectPattern6654); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON499);

			pushFollow(FOLLOW_aspectExpression_in_aspectPattern6656);
			aspectExpression500=aspectExpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression.add(aspectExpression500.getTree());
			pushFollow(FOLLOW_xEOS_in_aspectPattern6658);
			xEOS501=xEOS();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xEOS.add(xEOS501.getTree());
			// AST REWRITE
			// elements: aspectExpression, name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 672:50: -> ^( ASPECTPATTERN name aspectExpression )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:672:53: ^( ASPECTPATTERN name aspectExpression )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTPATTERN, "ASPECTPATTERN"), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_1, stream_aspectExpression.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPattern"


	public static class aspectExpression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:674:1: aspectExpression : aspectExpression04 -> aspectExpression04 ;
	public final MatlabParser.aspectExpression_return aspectExpression() throws RecognitionException {
		MatlabParser.aspectExpression_return retval = new MatlabParser.aspectExpression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectExpression04502 =null;

		RewriteRuleSubtreeStream stream_aspectExpression04=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression04");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:674:18: ( aspectExpression04 -> aspectExpression04 )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:674:20: aspectExpression04
			{
			pushFollow(FOLLOW_aspectExpression04_in_aspectExpression6677);
			aspectExpression04502=aspectExpression04();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression04.add(aspectExpression04502.getTree());
			// AST REWRITE
			// elements: aspectExpression04
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 674:39: -> aspectExpression04
			{
				adaptor.addChild(root_0, stream_aspectExpression04.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression"


	public static class aspectExpression04_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression04"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:1: aspectExpression04 : (x1= aspectExpression03 -> $x1) ( options {greedy=true; } : OR x2= aspectExpression03 -> ^( OR $aspectExpression04 $x2) )* ;
	public final MatlabParser.aspectExpression04_return aspectExpression04() throws RecognitionException {
		MatlabParser.aspectExpression04_return retval = new MatlabParser.aspectExpression04_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token OR503=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object OR503_tree=null;
		RewriteRuleTokenStream stream_OR=new RewriteRuleTokenStream(adaptor,"token OR");
		RewriteRuleSubtreeStream stream_aspectExpression03=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression03");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:20: ( (x1= aspectExpression03 -> $x1) ( options {greedy=true; } : OR x2= aspectExpression03 -> ^( OR $aspectExpression04 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:22: (x1= aspectExpression03 -> $x1) ( options {greedy=true; } : OR x2= aspectExpression03 -> ^( OR $aspectExpression04 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:22: (x1= aspectExpression03 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:23: x1= aspectExpression03
			{
			pushFollow(FOLLOW_aspectExpression03_in_aspectExpression046693);
			x1=aspectExpression03();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression03.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 676:45: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:53: ( options {greedy=true; } : OR x2= aspectExpression03 -> ^( OR $aspectExpression04 $x2) )*
			loop127:
			while (true) {
				int alt127=2;
				int LA127_0 = input.LA(1);
				if ( (LA127_0==OR) ) {
					alt127=1;
				}

				switch (alt127) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:78: OR x2= aspectExpression03
					{
					OR503=(Token)match(input,OR,FOLLOW_OR_in_aspectExpression046710); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_OR.add(OR503);

					pushFollow(FOLLOW_aspectExpression03_in_aspectExpression046714);
					x2=aspectExpression03();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExpression03.add(x2.getTree());
					// AST REWRITE
					// elements: OR, x2, aspectExpression04
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 676:103: -> ^( OR $aspectExpression04 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:676:106: ^( OR $aspectExpression04 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_OR.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop127;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression04"


	public static class aspectExpression03_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression03"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:1: aspectExpression03 : (x1= aspectExpression02 -> $x1) ( options {greedy=true; } : AND x2= aspectExpression02 -> ^( AND $aspectExpression03 $x2) )* ;
	public final MatlabParser.aspectExpression03_return aspectExpression03() throws RecognitionException {
		MatlabParser.aspectExpression03_return retval = new MatlabParser.aspectExpression03_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token AND504=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object AND504_tree=null;
		RewriteRuleTokenStream stream_AND=new RewriteRuleTokenStream(adaptor,"token AND");
		RewriteRuleSubtreeStream stream_aspectExpression02=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression02");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:20: ( (x1= aspectExpression02 -> $x1) ( options {greedy=true; } : AND x2= aspectExpression02 -> ^( AND $aspectExpression03 $x2) )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:22: (x1= aspectExpression02 -> $x1) ( options {greedy=true; } : AND x2= aspectExpression02 -> ^( AND $aspectExpression03 $x2) )*
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:22: (x1= aspectExpression02 -> $x1)
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:23: x1= aspectExpression02
			{
			pushFollow(FOLLOW_aspectExpression02_in_aspectExpression036740);
			x1=aspectExpression02();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression02.add(x1.getTree());
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 678:45: -> $x1
			{
				adaptor.addChild(root_0, stream_x1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:53: ( options {greedy=true; } : AND x2= aspectExpression02 -> ^( AND $aspectExpression03 $x2) )*
			loop128:
			while (true) {
				int alt128=2;
				int LA128_0 = input.LA(1);
				if ( (LA128_0==AND) ) {
					alt128=1;
				}

				switch (alt128) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:78: AND x2= aspectExpression02
					{
					AND504=(Token)match(input,AND,FOLLOW_AND_in_aspectExpression036757); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_AND.add(AND504);

					pushFollow(FOLLOW_aspectExpression02_in_aspectExpression036761);
					x2=aspectExpression02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExpression02.add(x2.getTree());
					// AST REWRITE
					// elements: x2, aspectExpression03, AND
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 678:104: -> ^( AND $aspectExpression03 $x2)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:678:107: ^( AND $aspectExpression03 $x2)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_AND.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_x2.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

				default :
					break loop128;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression03"


	public static class aspectExpression02_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression02"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:680:1: aspectExpression02 : ( NOT x1= aspectExpression02 -> ^( NOT $x1) |x2= aspectExpression01 -> $x2);
	public final MatlabParser.aspectExpression02_return aspectExpression02() throws RecognitionException {
		MatlabParser.aspectExpression02_return retval = new MatlabParser.aspectExpression02_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token NOT505=null;
		ParserRuleReturnScope x1 =null;
		ParserRuleReturnScope x2 =null;

		Object NOT505_tree=null;
		RewriteRuleTokenStream stream_NOT=new RewriteRuleTokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_aspectExpression02=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression02");
		RewriteRuleSubtreeStream stream_aspectExpression01=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression01");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:680:20: ( NOT x1= aspectExpression02 -> ^( NOT $x1) |x2= aspectExpression01 -> $x2)
			int alt129=2;
			int LA129_0 = input.LA(1);
			if ( (LA129_0==NOT) ) {
				alt129=1;
			}
			else if ( (LA129_0==ID||LA129_0==LPAREN) ) {
				alt129=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 129, 0, input);
				throw nvae;
			}

			switch (alt129) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:680:22: NOT x1= aspectExpression02
					{
					NOT505=(Token)match(input,NOT,FOLLOW_NOT_in_aspectExpression026784); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_NOT.add(NOT505);

					pushFollow(FOLLOW_aspectExpression02_in_aspectExpression026788);
					x1=aspectExpression02();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExpression02.add(x1.getTree());
					// AST REWRITE
					// elements: NOT, x1
					// token labels: 
					// rule labels: x1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 680:48: -> ^( NOT $x1)
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:680:51: ^( NOT $x1)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_NOT.nextNode(), root_1);
						adaptor.addChild(root_1, stream_x1.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:681:13: x2= aspectExpression01
					{
					pushFollow(FOLLOW_aspectExpression01_in_aspectExpression026813);
					x2=aspectExpression01();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExpression01.add(x2.getTree());
					// AST REWRITE
					// elements: x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 681:35: -> $x2
					{
						adaptor.addChild(root_0, stream_x2.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression02"


	public static class aspectExpression01_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExpression01"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:684:1: aspectExpression01 : aspectAtom -> aspectAtom ;
	public final MatlabParser.aspectExpression01_return aspectExpression01() throws RecognitionException {
		MatlabParser.aspectExpression01_return retval = new MatlabParser.aspectExpression01_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectAtom506 =null;

		RewriteRuleSubtreeStream stream_aspectAtom=new RewriteRuleSubtreeStream(adaptor,"rule aspectAtom");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:684:20: ( aspectAtom -> aspectAtom )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:684:22: aspectAtom
			{
			pushFollow(FOLLOW_aspectAtom_in_aspectExpression016837);
			aspectAtom506=aspectAtom();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectAtom.add(aspectAtom506.getTree());
			// AST REWRITE
			// elements: aspectAtom
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 684:33: -> aspectAtom
			{
				adaptor.addChild(root_0, stream_aspectAtom.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExpression01"


	public static class aspectAtom_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectAtom"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:686:1: aspectAtom : ( aspectParenthesis -> aspectParenthesis | aspectName -> aspectName | aspectGet -> aspectGet | aspectSet -> aspectSet | aspectCall -> aspectCall | aspectExecution -> aspectExecution | aspectMainExecution -> aspectMainExecution | aspectLoop -> aspectLoop | aspectLoopHead -> aspectLoopHead | aspectLoopBody -> aspectLoopBody | aspectAnnotate -> aspectAnnotate | aspectOperator -> aspectOperator | aspectWithin -> aspectWithin | aspectDimension -> aspectDimension | aspectIsType -> aspectIsType );
	public final MatlabParser.aspectAtom_return aspectAtom() throws RecognitionException {
		MatlabParser.aspectAtom_return retval = new MatlabParser.aspectAtom_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectParenthesis507 =null;
		ParserRuleReturnScope aspectName508 =null;
		ParserRuleReturnScope aspectGet509 =null;
		ParserRuleReturnScope aspectSet510 =null;
		ParserRuleReturnScope aspectCall511 =null;
		ParserRuleReturnScope aspectExecution512 =null;
		ParserRuleReturnScope aspectMainExecution513 =null;
		ParserRuleReturnScope aspectLoop514 =null;
		ParserRuleReturnScope aspectLoopHead515 =null;
		ParserRuleReturnScope aspectLoopBody516 =null;
		ParserRuleReturnScope aspectAnnotate517 =null;
		ParserRuleReturnScope aspectOperator518 =null;
		ParserRuleReturnScope aspectWithin519 =null;
		ParserRuleReturnScope aspectDimension520 =null;
		ParserRuleReturnScope aspectIsType521 =null;

		RewriteRuleSubtreeStream stream_aspectName=new RewriteRuleSubtreeStream(adaptor,"rule aspectName");
		RewriteRuleSubtreeStream stream_aspectAnnotate=new RewriteRuleSubtreeStream(adaptor,"rule aspectAnnotate");
		RewriteRuleSubtreeStream stream_aspectMainExecution=new RewriteRuleSubtreeStream(adaptor,"rule aspectMainExecution");
		RewriteRuleSubtreeStream stream_aspectCall=new RewriteRuleSubtreeStream(adaptor,"rule aspectCall");
		RewriteRuleSubtreeStream stream_aspectWithin=new RewriteRuleSubtreeStream(adaptor,"rule aspectWithin");
		RewriteRuleSubtreeStream stream_aspectParenthesis=new RewriteRuleSubtreeStream(adaptor,"rule aspectParenthesis");
		RewriteRuleSubtreeStream stream_aspectGet=new RewriteRuleSubtreeStream(adaptor,"rule aspectGet");
		RewriteRuleSubtreeStream stream_aspectExecution=new RewriteRuleSubtreeStream(adaptor,"rule aspectExecution");
		RewriteRuleSubtreeStream stream_aspectLoopHead=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopHead");
		RewriteRuleSubtreeStream stream_aspectOperator=new RewriteRuleSubtreeStream(adaptor,"rule aspectOperator");
		RewriteRuleSubtreeStream stream_aspectSet=new RewriteRuleSubtreeStream(adaptor,"rule aspectSet");
		RewriteRuleSubtreeStream stream_aspectLoopBody=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopBody");
		RewriteRuleSubtreeStream stream_aspectLoop=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoop");
		RewriteRuleSubtreeStream stream_aspectDimension=new RewriteRuleSubtreeStream(adaptor,"rule aspectDimension");
		RewriteRuleSubtreeStream stream_aspectIsType=new RewriteRuleSubtreeStream(adaptor,"rule aspectIsType");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:686:12: ( aspectParenthesis -> aspectParenthesis | aspectName -> aspectName | aspectGet -> aspectGet | aspectSet -> aspectSet | aspectCall -> aspectCall | aspectExecution -> aspectExecution | aspectMainExecution -> aspectMainExecution | aspectLoop -> aspectLoop | aspectLoopHead -> aspectLoopHead | aspectLoopBody -> aspectLoopBody | aspectAnnotate -> aspectAnnotate | aspectOperator -> aspectOperator | aspectWithin -> aspectWithin | aspectDimension -> aspectDimension | aspectIsType -> aspectIsType )
			int alt130=15;
			alt130 = dfa130.predict(input);
			switch (alt130) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:686:14: aspectParenthesis
					{
					pushFollow(FOLLOW_aspectParenthesis_in_aspectAtom6850);
					aspectParenthesis507=aspectParenthesis();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectParenthesis.add(aspectParenthesis507.getTree());
					// AST REWRITE
					// elements: aspectParenthesis
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 686:32: -> aspectParenthesis
					{
						adaptor.addChild(root_0, stream_aspectParenthesis.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:687:14: aspectName
					{
					pushFollow(FOLLOW_aspectName_in_aspectAtom6869);
					aspectName508=aspectName();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectName.add(aspectName508.getTree());
					// AST REWRITE
					// elements: aspectName
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 687:25: -> aspectName
					{
						adaptor.addChild(root_0, stream_aspectName.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:688:14: aspectGet
					{
					pushFollow(FOLLOW_aspectGet_in_aspectAtom6888);
					aspectGet509=aspectGet();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectGet.add(aspectGet509.getTree());
					// AST REWRITE
					// elements: aspectGet
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 688:24: -> aspectGet
					{
						adaptor.addChild(root_0, stream_aspectGet.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:689:14: aspectSet
					{
					pushFollow(FOLLOW_aspectSet_in_aspectAtom6907);
					aspectSet510=aspectSet();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectSet.add(aspectSet510.getTree());
					// AST REWRITE
					// elements: aspectSet
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 689:24: -> aspectSet
					{
						adaptor.addChild(root_0, stream_aspectSet.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:690:14: aspectCall
					{
					pushFollow(FOLLOW_aspectCall_in_aspectAtom6926);
					aspectCall511=aspectCall();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectCall.add(aspectCall511.getTree());
					// AST REWRITE
					// elements: aspectCall
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 690:25: -> aspectCall
					{
						adaptor.addChild(root_0, stream_aspectCall.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:691:14: aspectExecution
					{
					pushFollow(FOLLOW_aspectExecution_in_aspectAtom6945);
					aspectExecution512=aspectExecution();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectExecution.add(aspectExecution512.getTree());
					// AST REWRITE
					// elements: aspectExecution
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 691:30: -> aspectExecution
					{
						adaptor.addChild(root_0, stream_aspectExecution.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:692:14: aspectMainExecution
					{
					pushFollow(FOLLOW_aspectMainExecution_in_aspectAtom6964);
					aspectMainExecution513=aspectMainExecution();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectMainExecution.add(aspectMainExecution513.getTree());
					// AST REWRITE
					// elements: aspectMainExecution
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 692:34: -> aspectMainExecution
					{
						adaptor.addChild(root_0, stream_aspectMainExecution.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:693:14: aspectLoop
					{
					pushFollow(FOLLOW_aspectLoop_in_aspectAtom6983);
					aspectLoop514=aspectLoop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoop.add(aspectLoop514.getTree());
					// AST REWRITE
					// elements: aspectLoop
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 693:25: -> aspectLoop
					{
						adaptor.addChild(root_0, stream_aspectLoop.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:694:14: aspectLoopHead
					{
					pushFollow(FOLLOW_aspectLoopHead_in_aspectAtom7002);
					aspectLoopHead515=aspectLoopHead();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopHead.add(aspectLoopHead515.getTree());
					// AST REWRITE
					// elements: aspectLoopHead
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 694:29: -> aspectLoopHead
					{
						adaptor.addChild(root_0, stream_aspectLoopHead.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:695:14: aspectLoopBody
					{
					pushFollow(FOLLOW_aspectLoopBody_in_aspectAtom7021);
					aspectLoopBody516=aspectLoopBody();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopBody.add(aspectLoopBody516.getTree());
					// AST REWRITE
					// elements: aspectLoopBody
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 695:29: -> aspectLoopBody
					{
						adaptor.addChild(root_0, stream_aspectLoopBody.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:696:14: aspectAnnotate
					{
					pushFollow(FOLLOW_aspectAnnotate_in_aspectAtom7040);
					aspectAnnotate517=aspectAnnotate();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectAnnotate.add(aspectAnnotate517.getTree());
					// AST REWRITE
					// elements: aspectAnnotate
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 696:29: -> aspectAnnotate
					{
						adaptor.addChild(root_0, stream_aspectAnnotate.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 12 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:697:14: aspectOperator
					{
					pushFollow(FOLLOW_aspectOperator_in_aspectAtom7059);
					aspectOperator518=aspectOperator();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectOperator.add(aspectOperator518.getTree());
					// AST REWRITE
					// elements: aspectOperator
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 697:29: -> aspectOperator
					{
						adaptor.addChild(root_0, stream_aspectOperator.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 13 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:698:14: aspectWithin
					{
					pushFollow(FOLLOW_aspectWithin_in_aspectAtom7078);
					aspectWithin519=aspectWithin();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectWithin.add(aspectWithin519.getTree());
					// AST REWRITE
					// elements: aspectWithin
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 698:27: -> aspectWithin
					{
						adaptor.addChild(root_0, stream_aspectWithin.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 14 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:699:14: aspectDimension
					{
					pushFollow(FOLLOW_aspectDimension_in_aspectAtom7097);
					aspectDimension520=aspectDimension();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectDimension.add(aspectDimension520.getTree());
					// AST REWRITE
					// elements: aspectDimension
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 699:30: -> aspectDimension
					{
						adaptor.addChild(root_0, stream_aspectDimension.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 15 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:700:14: aspectIsType
					{
					pushFollow(FOLLOW_aspectIsType_in_aspectAtom7116);
					aspectIsType521=aspectIsType();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectIsType.add(aspectIsType521.getTree());
					// AST REWRITE
					// elements: aspectIsType
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 700:27: -> aspectIsType
					{
						adaptor.addChild(root_0, stream_aspectIsType.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectAtom"


	public static class aspectParenthesis_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectParenthesis"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:703:1: aspectParenthesis : LPAREN aspectExpression RPAREN -> aspectExpression ;
	public final MatlabParser.aspectParenthesis_return aspectParenthesis() throws RecognitionException {
		MatlabParser.aspectParenthesis_return retval = new MatlabParser.aspectParenthesis_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN522=null;
		Token RPAREN524=null;
		ParserRuleReturnScope aspectExpression523 =null;

		Object LPAREN522_tree=null;
		Object RPAREN524_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectExpression=new RewriteRuleSubtreeStream(adaptor,"rule aspectExpression");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:703:19: ( LPAREN aspectExpression RPAREN -> aspectExpression )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:703:21: LPAREN aspectExpression RPAREN
			{
			LPAREN522=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectParenthesis7140); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN522);

			pushFollow(FOLLOW_aspectExpression_in_aspectParenthesis7142);
			aspectExpression523=aspectExpression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectExpression.add(aspectExpression523.getTree());
			RPAREN524=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectParenthesis7144); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN524);

			// AST REWRITE
			// elements: aspectExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 703:52: -> aspectExpression
			{
				adaptor.addChild(root_0, stream_aspectExpression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectParenthesis"


	public static class aspectName_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectName"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:705:1: aspectName : name -> ^( ASPECTNAME[\"\"] name ) ;
	public final MatlabParser.aspectName_return aspectName() throws RecognitionException {
		MatlabParser.aspectName_return retval = new MatlabParser.aspectName_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope name525 =null;

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:705:12: ( name -> ^( ASPECTNAME[\"\"] name ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:705:14: name
			{
			pushFollow(FOLLOW_name_in_aspectName7157);
			name525=name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_name.add(name525.getTree());
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 705:19: -> ^( ASPECTNAME[\"\"] name )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:705:22: ^( ASPECTNAME[\"\"] name )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTNAME, ""), root_1);
				adaptor.addChild(root_1, stream_name.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectName"


	public static class aspectIdentifier_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectIdentifier"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:707:1: aspectIdentifier : ( wID -> wID | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectIdentifier_return aspectIdentifier() throws RecognitionException {
		MatlabParser.aspectIdentifier_return retval = new MatlabParser.aspectIdentifier_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wID526 =null;
		ParserRuleReturnScope wSTAR527 =null;
		ParserRuleReturnScope wDOTDOT528 =null;

		RewriteRuleSubtreeStream stream_wID=new RewriteRuleSubtreeStream(adaptor,"rule wID");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:707:18: ( wID -> wID | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt131=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt131=1;
				}
				break;
			case MTIMES:
				{
				alt131=2;
				}
				break;
			case DOTDOT:
				{
				alt131=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 131, 0, input);
				throw nvae;
			}
			switch (alt131) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:707:20: wID
					{
					pushFollow(FOLLOW_wID_in_aspectIdentifier7175);
					wID526=wID();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wID.add(wID526.getTree());
					// AST REWRITE
					// elements: wID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 707:24: -> wID
					{
						adaptor.addChild(root_0, stream_wID.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:708:20: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectIdentifier7200);
					wSTAR527=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR527.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 708:26: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:709:20: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectIdentifier7225);
					wDOTDOT528=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT528.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 709:28: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectIdentifier"


	public static class aspectTypeSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectTypeSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:712:1: aspectTypeSignature : ( wID -> ^( ASPECTTYPESIGNATURE wID ) | wSTAR -> ^( ASPECTTYPESIGNATURE wSTAR ) | wDOTDOT -> ^( ASPECTTYPESIGNATURE wDOTDOT ) );
	public final MatlabParser.aspectTypeSignature_return aspectTypeSignature() throws RecognitionException {
		MatlabParser.aspectTypeSignature_return retval = new MatlabParser.aspectTypeSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wID529 =null;
		ParserRuleReturnScope wSTAR530 =null;
		ParserRuleReturnScope wDOTDOT531 =null;

		RewriteRuleSubtreeStream stream_wID=new RewriteRuleSubtreeStream(adaptor,"rule wID");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:712:21: ( wID -> ^( ASPECTTYPESIGNATURE wID ) | wSTAR -> ^( ASPECTTYPESIGNATURE wSTAR ) | wDOTDOT -> ^( ASPECTTYPESIGNATURE wDOTDOT ) )
			int alt132=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				alt132=1;
				}
				break;
			case MTIMES:
				{
				alt132=2;
				}
				break;
			case DOTDOT:
				{
				alt132=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 132, 0, input);
				throw nvae;
			}
			switch (alt132) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:712:23: wID
					{
					pushFollow(FOLLOW_wID_in_aspectTypeSignature7255);
					wID529=wID();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wID.add(wID529.getTree());
					// AST REWRITE
					// elements: wID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 712:27: -> ^( ASPECTTYPESIGNATURE wID )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:712:30: ^( ASPECTTYPESIGNATURE wID )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTTYPESIGNATURE, "ASPECTTYPESIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_wID.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:713:23: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectTypeSignature7287);
					wSTAR530=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR530.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 713:29: -> ^( ASPECTTYPESIGNATURE wSTAR )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:713:32: ^( ASPECTTYPESIGNATURE wSTAR )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTTYPESIGNATURE, "ASPECTTYPESIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_wSTAR.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:714:23: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectTypeSignature7319);
					wDOTDOT531=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT531.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 714:31: -> ^( ASPECTTYPESIGNATURE wDOTDOT )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:714:34: ^( ASPECTTYPESIGNATURE wDOTDOT )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTTYPESIGNATURE, "ASPECTTYPESIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_wDOTDOT.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectTypeSignature"


	public static class aspectPartSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPartSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:717:1: aspectPartSignature : ( wREAL -> wREAL | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectPartSignature_return aspectPartSignature() throws RecognitionException {
		MatlabParser.aspectPartSignature_return retval = new MatlabParser.aspectPartSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wREAL532 =null;
		ParserRuleReturnScope wSTAR533 =null;
		ParserRuleReturnScope wDOTDOT534 =null;

		RewriteRuleSubtreeStream stream_wREAL=new RewriteRuleSubtreeStream(adaptor,"rule wREAL");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:717:21: ( wREAL -> wREAL | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt133=3;
			switch ( input.LA(1) ) {
			case REAL:
				{
				alt133=1;
				}
				break;
			case MTIMES:
				{
				alt133=2;
				}
				break;
			case DOTDOT:
				{
				alt133=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 133, 0, input);
				throw nvae;
			}
			switch (alt133) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:717:23: wREAL
					{
					pushFollow(FOLLOW_wREAL_in_aspectPartSignature7356);
					wREAL532=wREAL();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wREAL.add(wREAL532.getTree());
					// AST REWRITE
					// elements: wREAL
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 717:29: -> wREAL
					{
						adaptor.addChild(root_0, stream_wREAL.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:718:23: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectPartSignature7384);
					wSTAR533=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR533.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 718:29: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:719:23: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectPartSignature7412);
					wDOTDOT534=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT534.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 719:31: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPartSignature"


	public static class aspectDimensionSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectDimensionSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:1: aspectDimensionSignature : LSQUARE ( aspectPartSignature ( COMMA aspectPartSignature )* )? RSQUARE -> ^( ASPECTDIMENSIONSIGNATURE ( aspectPartSignature )* ) ;
	public final MatlabParser.aspectDimensionSignature_return aspectDimensionSignature() throws RecognitionException {
		MatlabParser.aspectDimensionSignature_return retval = new MatlabParser.aspectDimensionSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE535=null;
		Token COMMA537=null;
		Token RSQUARE539=null;
		ParserRuleReturnScope aspectPartSignature536 =null;
		ParserRuleReturnScope aspectPartSignature538 =null;

		Object LSQUARE535_tree=null;
		Object COMMA537_tree=null;
		Object RSQUARE539_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_aspectPartSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectPartSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:26: ( LSQUARE ( aspectPartSignature ( COMMA aspectPartSignature )* )? RSQUARE -> ^( ASPECTDIMENSIONSIGNATURE ( aspectPartSignature )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:28: LSQUARE ( aspectPartSignature ( COMMA aspectPartSignature )* )? RSQUARE
			{
			LSQUARE535=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_aspectDimensionSignature7445); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE535);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:36: ( aspectPartSignature ( COMMA aspectPartSignature )* )?
			int alt135=2;
			int LA135_0 = input.LA(1);
			if ( (LA135_0==DOTDOT||LA135_0==MTIMES||LA135_0==REAL) ) {
				alt135=1;
			}
			switch (alt135) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:37: aspectPartSignature ( COMMA aspectPartSignature )*
					{
					pushFollow(FOLLOW_aspectPartSignature_in_aspectDimensionSignature7448);
					aspectPartSignature536=aspectPartSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectPartSignature.add(aspectPartSignature536.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:57: ( COMMA aspectPartSignature )*
					loop134:
					while (true) {
						int alt134=2;
						int LA134_0 = input.LA(1);
						if ( (LA134_0==COMMA) ) {
							alt134=1;
						}

						switch (alt134) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:58: COMMA aspectPartSignature
							{
							COMMA537=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectDimensionSignature7451); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA537);

							pushFollow(FOLLOW_aspectPartSignature_in_aspectDimensionSignature7453);
							aspectPartSignature538=aspectPartSignature();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectPartSignature.add(aspectPartSignature538.getTree());
							}
							break;

						default :
							break loop134;
						}
					}

					}
					break;

			}

			RSQUARE539=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_aspectDimensionSignature7459); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE539);

			// AST REWRITE
			// elements: aspectPartSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 722:96: -> ^( ASPECTDIMENSIONSIGNATURE ( aspectPartSignature )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:99: ^( ASPECTDIMENSIONSIGNATURE ( aspectPartSignature )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTDIMENSIONSIGNATURE, "ASPECTDIMENSIONSIGNATURE"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:722:126: ( aspectPartSignature )*
				while ( stream_aspectPartSignature.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectPartSignature.nextTree());
				}
				stream_aspectPartSignature.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectDimensionSignature"


	public static class aspectFullSignature_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectFullSignature"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:724:1: aspectFullSignature : ( aspectTypeSignature -> ^( ASPECTFULLSIGNATURE aspectTypeSignature ) | aspectTypeSignature aspectDimensionSignature -> ^( ASPECTFULLSIGNATURE aspectTypeSignature aspectDimensionSignature ) | aspectDimensionSignature -> ^( ASPECTFULLSIGNATURE aspectDimensionSignature ) );
	public final MatlabParser.aspectFullSignature_return aspectFullSignature() throws RecognitionException {
		MatlabParser.aspectFullSignature_return retval = new MatlabParser.aspectFullSignature_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectTypeSignature540 =null;
		ParserRuleReturnScope aspectTypeSignature541 =null;
		ParserRuleReturnScope aspectDimensionSignature542 =null;
		ParserRuleReturnScope aspectDimensionSignature543 =null;

		RewriteRuleSubtreeStream stream_aspectDimensionSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectDimensionSignature");
		RewriteRuleSubtreeStream stream_aspectTypeSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectTypeSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:724:21: ( aspectTypeSignature -> ^( ASPECTFULLSIGNATURE aspectTypeSignature ) | aspectTypeSignature aspectDimensionSignature -> ^( ASPECTFULLSIGNATURE aspectTypeSignature aspectDimensionSignature ) | aspectDimensionSignature -> ^( ASPECTFULLSIGNATURE aspectDimensionSignature ) )
			int alt136=3;
			switch ( input.LA(1) ) {
			case ID:
				{
				int LA136_1 = input.LA(2);
				if ( (LA136_1==COMMA||LA136_1==RPAREN) ) {
					alt136=1;
				}
				else if ( (LA136_1==LSQUARE) ) {
					alt136=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 136, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case MTIMES:
				{
				int LA136_2 = input.LA(2);
				if ( (LA136_2==COMMA||LA136_2==RPAREN) ) {
					alt136=1;
				}
				else if ( (LA136_2==LSQUARE) ) {
					alt136=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 136, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case DOTDOT:
				{
				int LA136_3 = input.LA(2);
				if ( (LA136_3==COMMA||LA136_3==RPAREN) ) {
					alt136=1;
				}
				else if ( (LA136_3==LSQUARE) ) {
					alt136=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 136, 3, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LSQUARE:
				{
				alt136=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 136, 0, input);
				throw nvae;
			}
			switch (alt136) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:724:23: aspectTypeSignature
					{
					pushFollow(FOLLOW_aspectTypeSignature_in_aspectFullSignature7479);
					aspectTypeSignature540=aspectTypeSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectTypeSignature.add(aspectTypeSignature540.getTree());
					// AST REWRITE
					// elements: aspectTypeSignature
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 724:43: -> ^( ASPECTFULLSIGNATURE aspectTypeSignature )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:724:46: ^( ASPECTFULLSIGNATURE aspectTypeSignature )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTFULLSIGNATURE, "ASPECTFULLSIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_aspectTypeSignature.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:725:23: aspectTypeSignature aspectDimensionSignature
					{
					pushFollow(FOLLOW_aspectTypeSignature_in_aspectFullSignature7511);
					aspectTypeSignature541=aspectTypeSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectTypeSignature.add(aspectTypeSignature541.getTree());
					pushFollow(FOLLOW_aspectDimensionSignature_in_aspectFullSignature7513);
					aspectDimensionSignature542=aspectDimensionSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectDimensionSignature.add(aspectDimensionSignature542.getTree());
					// AST REWRITE
					// elements: aspectDimensionSignature, aspectTypeSignature
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 725:69: -> ^( ASPECTFULLSIGNATURE aspectTypeSignature aspectDimensionSignature )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:725:72: ^( ASPECTFULLSIGNATURE aspectTypeSignature aspectDimensionSignature )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTFULLSIGNATURE, "ASPECTFULLSIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_aspectTypeSignature.nextTree());
						adaptor.addChild(root_1, stream_aspectDimensionSignature.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:726:23: aspectDimensionSignature
					{
					pushFollow(FOLLOW_aspectDimensionSignature_in_aspectFullSignature7548);
					aspectDimensionSignature543=aspectDimensionSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectDimensionSignature.add(aspectDimensionSignature543.getTree());
					// AST REWRITE
					// elements: aspectDimensionSignature
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 726:49: -> ^( ASPECTFULLSIGNATURE aspectDimensionSignature )
					{
						// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:726:52: ^( ASPECTFULLSIGNATURE aspectDimensionSignature )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTFULLSIGNATURE, "ASPECTFULLSIGNATURE"), root_1);
						adaptor.addChild(root_1, stream_aspectDimensionSignature.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectFullSignature"


	public static class aspectGet_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectGet"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:1: aspectGet : wGET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN -> ^( ASPECTGET aspectIdentifier ( aspectFullSignature )? ) ;
	public final MatlabParser.aspectGet_return aspectGet() throws RecognitionException {
		MatlabParser.aspectGet_return retval = new MatlabParser.aspectGet_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN545=null;
		Token COLON547=null;
		Token RPAREN549=null;
		ParserRuleReturnScope wGET544 =null;
		ParserRuleReturnScope aspectIdentifier546 =null;
		ParserRuleReturnScope aspectFullSignature548 =null;

		Object LPAREN545_tree=null;
		Object COLON547_tree=null;
		Object RPAREN549_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wGET=new RewriteRuleSubtreeStream(adaptor,"rule wGET");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:11: ( wGET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN -> ^( ASPECTGET aspectIdentifier ( aspectFullSignature )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:13: wGET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN
			{
			pushFollow(FOLLOW_wGET_in_aspectGet7586);
			wGET544=wGET();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wGET.add(wGET544.getTree());
			LPAREN545=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectGet7588); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN545);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectGet7590);
			aspectIdentifier546=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier546.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:42: ( COLON aspectFullSignature )?
			int alt137=2;
			int LA137_0 = input.LA(1);
			if ( (LA137_0==COLON) ) {
				alt137=1;
			}
			switch (alt137) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:43: COLON aspectFullSignature
					{
					COLON547=(Token)match(input,COLON,FOLLOW_COLON_in_aspectGet7593); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON547);

					pushFollow(FOLLOW_aspectFullSignature_in_aspectGet7595);
					aspectFullSignature548=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature548.getTree());
					}
					break;

			}

			RPAREN549=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectGet7599); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN549);

			// AST REWRITE
			// elements: aspectIdentifier, aspectFullSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 729:78: -> ^( ASPECTGET aspectIdentifier ( aspectFullSignature )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:81: ^( ASPECTGET aspectIdentifier ( aspectFullSignature )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTGET, "ASPECTGET"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:729:110: ( aspectFullSignature )?
				if ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectGet"


	public static class aspectSet_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSet"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:1: aspectSet : wSET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN -> ^( ASPECTSET aspectIdentifier ( aspectFullSignature )? ) ;
	public final MatlabParser.aspectSet_return aspectSet() throws RecognitionException {
		MatlabParser.aspectSet_return retval = new MatlabParser.aspectSet_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN551=null;
		Token COLON553=null;
		Token RPAREN555=null;
		ParserRuleReturnScope wSET550 =null;
		ParserRuleReturnScope aspectIdentifier552 =null;
		ParserRuleReturnScope aspectFullSignature554 =null;

		Object LPAREN551_tree=null;
		Object COLON553_tree=null;
		Object RPAREN555_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");
		RewriteRuleSubtreeStream stream_wSET=new RewriteRuleSubtreeStream(adaptor,"rule wSET");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:11: ( wSET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN -> ^( ASPECTSET aspectIdentifier ( aspectFullSignature )? ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:13: wSET LPAREN aspectIdentifier ( COLON aspectFullSignature )? RPAREN
			{
			pushFollow(FOLLOW_wSET_in_aspectSet7621);
			wSET550=wSET();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wSET.add(wSET550.getTree());
			LPAREN551=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectSet7623); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN551);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectSet7625);
			aspectIdentifier552=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier552.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:42: ( COLON aspectFullSignature )?
			int alt138=2;
			int LA138_0 = input.LA(1);
			if ( (LA138_0==COLON) ) {
				alt138=1;
			}
			switch (alt138) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:43: COLON aspectFullSignature
					{
					COLON553=(Token)match(input,COLON,FOLLOW_COLON_in_aspectSet7628); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON553);

					pushFollow(FOLLOW_aspectFullSignature_in_aspectSet7630);
					aspectFullSignature554=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature554.getTree());
					}
					break;

			}

			RPAREN555=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectSet7634); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN555);

			// AST REWRITE
			// elements: aspectIdentifier, aspectFullSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 731:78: -> ^( ASPECTSET aspectIdentifier ( aspectFullSignature )? )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:81: ^( ASPECTSET aspectIdentifier ( aspectFullSignature )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTSET, "ASPECTSET"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:731:110: ( aspectFullSignature )?
				if ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSet"


	public static class aspectInput_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectInput"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:1: aspectInput : ( aspectFullSignature ( COMMA aspectFullSignature )* )? -> ( aspectFullSignature )* ;
	public final MatlabParser.aspectInput_return aspectInput() throws RecognitionException {
		MatlabParser.aspectInput_return retval = new MatlabParser.aspectInput_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA557=null;
		ParserRuleReturnScope aspectFullSignature556 =null;
		ParserRuleReturnScope aspectFullSignature558 =null;

		Object COMMA557_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:13: ( ( aspectFullSignature ( COMMA aspectFullSignature )* )? -> ( aspectFullSignature )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:15: ( aspectFullSignature ( COMMA aspectFullSignature )* )?
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:15: ( aspectFullSignature ( COMMA aspectFullSignature )* )?
			int alt140=2;
			int LA140_0 = input.LA(1);
			if ( (LA140_0==DOTDOT||LA140_0==ID||LA140_0==LSQUARE||LA140_0==MTIMES) ) {
				alt140=1;
			}
			switch (alt140) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:16: aspectFullSignature ( COMMA aspectFullSignature )*
					{
					pushFollow(FOLLOW_aspectFullSignature_in_aspectInput7657);
					aspectFullSignature556=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature556.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:36: ( COMMA aspectFullSignature )*
					loop139:
					while (true) {
						int alt139=2;
						int LA139_0 = input.LA(1);
						if ( (LA139_0==COMMA) ) {
							alt139=1;
						}

						switch (alt139) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:37: COMMA aspectFullSignature
							{
							COMMA557=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectInput7660); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA557);

							pushFollow(FOLLOW_aspectFullSignature_in_aspectInput7662);
							aspectFullSignature558=aspectFullSignature();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature558.getTree());
							}
							break;

						default :
							break loop139;
						}
					}

					}
					break;

			}

			// AST REWRITE
			// elements: aspectFullSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 733:67: -> ( aspectFullSignature )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:733:70: ( aspectFullSignature )*
				while ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectInput"


	public static class aspectOutput_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectOutput"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:1: aspectOutput : ( aspectFullSignature ( COMMA aspectFullSignature )* )? -> ( aspectFullSignature )* ;
	public final MatlabParser.aspectOutput_return aspectOutput() throws RecognitionException {
		MatlabParser.aspectOutput_return retval = new MatlabParser.aspectOutput_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA560=null;
		ParserRuleReturnScope aspectFullSignature559 =null;
		ParserRuleReturnScope aspectFullSignature561 =null;

		Object COMMA560_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:14: ( ( aspectFullSignature ( COMMA aspectFullSignature )* )? -> ( aspectFullSignature )* )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:16: ( aspectFullSignature ( COMMA aspectFullSignature )* )?
			{
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:16: ( aspectFullSignature ( COMMA aspectFullSignature )* )?
			int alt142=2;
			int LA142_0 = input.LA(1);
			if ( (LA142_0==DOTDOT||LA142_0==ID||LA142_0==LSQUARE||LA142_0==MTIMES) ) {
				alt142=1;
			}
			switch (alt142) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:17: aspectFullSignature ( COMMA aspectFullSignature )*
					{
					pushFollow(FOLLOW_aspectFullSignature_in_aspectOutput7683);
					aspectFullSignature559=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature559.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:37: ( COMMA aspectFullSignature )*
					loop141:
					while (true) {
						int alt141=2;
						int LA141_0 = input.LA(1);
						if ( (LA141_0==COMMA) ) {
							alt141=1;
						}

						switch (alt141) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:38: COMMA aspectFullSignature
							{
							COMMA560=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectOutput7686); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA560);

							pushFollow(FOLLOW_aspectFullSignature_in_aspectOutput7688);
							aspectFullSignature561=aspectFullSignature();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature561.getTree());
							}
							break;

						default :
							break loop141;
						}
					}

					}
					break;

			}

			// AST REWRITE
			// elements: aspectFullSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 735:68: -> ( aspectFullSignature )*
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:735:72: ( aspectFullSignature )*
				while ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_0, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectOutput"


	public static class aspectCall_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectCall"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:1: aspectCall : wCALL LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN -> ^( ASPECTCALL aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) ) ;
	public final MatlabParser.aspectCall_return aspectCall() throws RecognitionException {
		MatlabParser.aspectCall_return retval = new MatlabParser.aspectCall_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN563=null;
		Token LPAREN565=null;
		Token RPAREN567=null;
		Token COLON568=null;
		Token RPAREN570=null;
		ParserRuleReturnScope wCALL562 =null;
		ParserRuleReturnScope aspectIdentifier564 =null;
		ParserRuleReturnScope aspectInput566 =null;
		ParserRuleReturnScope aspectOutput569 =null;

		Object LPAREN563_tree=null;
		Object LPAREN565_tree=null;
		Object RPAREN567_tree=null;
		Object COLON568_tree=null;
		Object RPAREN570_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectInput=new RewriteRuleSubtreeStream(adaptor,"rule aspectInput");
		RewriteRuleSubtreeStream stream_aspectOutput=new RewriteRuleSubtreeStream(adaptor,"rule aspectOutput");
		RewriteRuleSubtreeStream stream_wCALL=new RewriteRuleSubtreeStream(adaptor,"rule wCALL");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:12: ( wCALL LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN -> ^( ASPECTCALL aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:14: wCALL LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN
			{
			pushFollow(FOLLOW_wCALL_in_aspectCall7709);
			wCALL562=wCALL();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wCALL.add(wCALL562.getTree());
			LPAREN563=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectCall7711); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN563);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectCall7713);
			aspectIdentifier564=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier564.getTree());
			LPAREN565=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectCall7715); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN565);

			pushFollow(FOLLOW_aspectInput_in_aspectCall7717);
			aspectInput566=aspectInput();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectInput.add(aspectInput566.getTree());
			RPAREN567=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectCall7719); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN567);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:70: ( COLON aspectOutput )?
			int alt143=2;
			int LA143_0 = input.LA(1);
			if ( (LA143_0==COLON) ) {
				alt143=1;
			}
			switch (alt143) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:71: COLON aspectOutput
					{
					COLON568=(Token)match(input,COLON,FOLLOW_COLON_in_aspectCall7722); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON568);

					pushFollow(FOLLOW_aspectOutput_in_aspectCall7724);
					aspectOutput569=aspectOutput();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectOutput.add(aspectOutput569.getTree());
					}
					break;

			}

			RPAREN570=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectCall7728); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN570);

			// AST REWRITE
			// elements: aspectIdentifier, aspectOutput, aspectInput
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 737:99: -> ^( ASPECTCALL aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:102: ^( ASPECTCALL aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTCALL, "ASPECTCALL"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:132: ^( ASPECTINPUT ( aspectInput )? )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTINPUT, "ASPECTINPUT"), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:146: ( aspectInput )?
				if ( stream_aspectInput.hasNext() ) {
					adaptor.addChild(root_2, stream_aspectInput.nextTree());
				}
				stream_aspectInput.reset();

				adaptor.addChild(root_1, root_2);
				}

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:162: ^( ASPECTOUTPUT ( aspectOutput )? )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTOUTPUT, "ASPECTOUTPUT"), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:737:177: ( aspectOutput )?
				if ( stream_aspectOutput.hasNext() ) {
					adaptor.addChild(root_2, stream_aspectOutput.nextTree());
				}
				stream_aspectOutput.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectCall"


	public static class aspectExecution_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectExecution"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:1: aspectExecution : wEXECUTION LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN -> ^( ASPECTEXECUTION aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) ) ;
	public final MatlabParser.aspectExecution_return aspectExecution() throws RecognitionException {
		MatlabParser.aspectExecution_return retval = new MatlabParser.aspectExecution_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN572=null;
		Token LPAREN574=null;
		Token RPAREN576=null;
		Token COLON577=null;
		Token RPAREN579=null;
		ParserRuleReturnScope wEXECUTION571 =null;
		ParserRuleReturnScope aspectIdentifier573 =null;
		ParserRuleReturnScope aspectInput575 =null;
		ParserRuleReturnScope aspectOutput578 =null;

		Object LPAREN572_tree=null;
		Object LPAREN574_tree=null;
		Object RPAREN576_tree=null;
		Object COLON577_tree=null;
		Object RPAREN579_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectInput=new RewriteRuleSubtreeStream(adaptor,"rule aspectInput");
		RewriteRuleSubtreeStream stream_aspectOutput=new RewriteRuleSubtreeStream(adaptor,"rule aspectOutput");
		RewriteRuleSubtreeStream stream_wEXECUTION=new RewriteRuleSubtreeStream(adaptor,"rule wEXECUTION");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:17: ( wEXECUTION LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN -> ^( ASPECTEXECUTION aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:19: wEXECUTION LPAREN aspectIdentifier LPAREN aspectInput RPAREN ( COLON aspectOutput )? RPAREN
			{
			pushFollow(FOLLOW_wEXECUTION_in_aspectExecution7763);
			wEXECUTION571=wEXECUTION();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wEXECUTION.add(wEXECUTION571.getTree());
			LPAREN572=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectExecution7765); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN572);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectExecution7767);
			aspectIdentifier573=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier573.getTree());
			LPAREN574=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectExecution7769); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN574);

			pushFollow(FOLLOW_aspectInput_in_aspectExecution7771);
			aspectInput575=aspectInput();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectInput.add(aspectInput575.getTree());
			RPAREN576=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectExecution7773); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN576);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:80: ( COLON aspectOutput )?
			int alt144=2;
			int LA144_0 = input.LA(1);
			if ( (LA144_0==COLON) ) {
				alt144=1;
			}
			switch (alt144) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:81: COLON aspectOutput
					{
					COLON577=(Token)match(input,COLON,FOLLOW_COLON_in_aspectExecution7776); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON577);

					pushFollow(FOLLOW_aspectOutput_in_aspectExecution7778);
					aspectOutput578=aspectOutput();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectOutput.add(aspectOutput578.getTree());
					}
					break;

			}

			RPAREN579=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectExecution7782); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN579);

			// AST REWRITE
			// elements: aspectIdentifier, aspectOutput, aspectInput
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 739:109: -> ^( ASPECTEXECUTION aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:112: ^( ASPECTEXECUTION aspectIdentifier ^( ASPECTINPUT ( aspectInput )? ) ^( ASPECTOUTPUT ( aspectOutput )? ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTEXECUTION, "ASPECTEXECUTION"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:147: ^( ASPECTINPUT ( aspectInput )? )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTINPUT, "ASPECTINPUT"), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:161: ( aspectInput )?
				if ( stream_aspectInput.hasNext() ) {
					adaptor.addChild(root_2, stream_aspectInput.nextTree());
				}
				stream_aspectInput.reset();

				adaptor.addChild(root_1, root_2);
				}

				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:177: ^( ASPECTOUTPUT ( aspectOutput )? )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTOUTPUT, "ASPECTOUTPUT"), root_2);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:739:192: ( aspectOutput )?
				if ( stream_aspectOutput.hasNext() ) {
					adaptor.addChild(root_2, stream_aspectOutput.nextTree());
				}
				stream_aspectOutput.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectExecution"


	public static class aspectMainExecution_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectMainExecution"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:741:1: aspectMainExecution : wMAINEXECUTION LPAREN RPAREN -> ASPECTMAINEXECUTION ;
	public final MatlabParser.aspectMainExecution_return aspectMainExecution() throws RecognitionException {
		MatlabParser.aspectMainExecution_return retval = new MatlabParser.aspectMainExecution_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN581=null;
		Token RPAREN582=null;
		ParserRuleReturnScope wMAINEXECUTION580 =null;

		Object LPAREN581_tree=null;
		Object RPAREN582_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wMAINEXECUTION=new RewriteRuleSubtreeStream(adaptor,"rule wMAINEXECUTION");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:741:21: ( wMAINEXECUTION LPAREN RPAREN -> ASPECTMAINEXECUTION )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:741:23: wMAINEXECUTION LPAREN RPAREN
			{
			pushFollow(FOLLOW_wMAINEXECUTION_in_aspectMainExecution7817);
			wMAINEXECUTION580=wMAINEXECUTION();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wMAINEXECUTION.add(wMAINEXECUTION580.getTree());
			LPAREN581=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectMainExecution7819); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN581);

			RPAREN582=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectMainExecution7821); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN582);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 741:52: -> ASPECTMAINEXECUTION
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ASPECTMAINEXECUTION, "ASPECTMAINEXECUTION"));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectMainExecution"


	public static class aspectLoopType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectLoopType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:743:1: aspectLoopType : ( wFOR -> wFOR | wWHILE -> wWHILE | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectLoopType_return aspectLoopType() throws RecognitionException {
		MatlabParser.aspectLoopType_return retval = new MatlabParser.aspectLoopType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wFOR583 =null;
		ParserRuleReturnScope wWHILE584 =null;
		ParserRuleReturnScope wSTAR585 =null;
		ParserRuleReturnScope wDOTDOT586 =null;

		RewriteRuleSubtreeStream stream_wFOR=new RewriteRuleSubtreeStream(adaptor,"rule wFOR");
		RewriteRuleSubtreeStream stream_wWHILE=new RewriteRuleSubtreeStream(adaptor,"rule wWHILE");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:743:16: ( wFOR -> wFOR | wWHILE -> wWHILE | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt145=4;
			switch ( input.LA(1) ) {
			case FOR:
				{
				alt145=1;
				}
				break;
			case WHILE:
				{
				alt145=2;
				}
				break;
			case MTIMES:
				{
				alt145=3;
				}
				break;
			case DOTDOT:
				{
				alt145=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 145, 0, input);
				throw nvae;
			}
			switch (alt145) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:743:18: wFOR
					{
					pushFollow(FOLLOW_wFOR_in_aspectLoopType7834);
					wFOR583=wFOR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wFOR.add(wFOR583.getTree());
					// AST REWRITE
					// elements: wFOR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 743:23: -> wFOR
					{
						adaptor.addChild(root_0, stream_wFOR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:744:18: wWHILE
					{
					pushFollow(FOLLOW_wWHILE_in_aspectLoopType7857);
					wWHILE584=wWHILE();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wWHILE.add(wWHILE584.getTree());
					// AST REWRITE
					// elements: wWHILE
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 744:25: -> wWHILE
					{
						adaptor.addChild(root_0, stream_wWHILE.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:745:18: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectLoopType7880);
					wSTAR585=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR585.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 745:24: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:746:18: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectLoopType7903);
					wDOTDOT586=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT586.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 746:26: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectLoopType"


	public static class aspectLoop_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectLoop"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:1: aspectLoop : wLOOP LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOP ( aspectLoopType )? aspectIdentifier ) ;
	public final MatlabParser.aspectLoop_return aspectLoop() throws RecognitionException {
		MatlabParser.aspectLoop_return retval = new MatlabParser.aspectLoop_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN588=null;
		Token COLON590=null;
		Token RPAREN592=null;
		ParserRuleReturnScope wLOOP587 =null;
		ParserRuleReturnScope aspectLoopType589 =null;
		ParserRuleReturnScope aspectIdentifier591 =null;

		Object LPAREN588_tree=null;
		Object COLON590_tree=null;
		Object RPAREN592_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wLOOP=new RewriteRuleSubtreeStream(adaptor,"rule wLOOP");
		RewriteRuleSubtreeStream stream_aspectLoopType=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopType");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:12: ( wLOOP LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOP ( aspectLoopType )? aspectIdentifier ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:14: wLOOP LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN
			{
			pushFollow(FOLLOW_wLOOP_in_aspectLoop7931);
			wLOOP587=wLOOP();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wLOOP.add(wLOOP587.getTree());
			LPAREN588=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectLoop7933); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN588);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:27: ( aspectLoopType COLON )?
			int alt146=2;
			switch ( input.LA(1) ) {
				case FOR:
				case WHILE:
					{
					alt146=1;
					}
					break;
				case MTIMES:
					{
					int LA146_2 = input.LA(2);
					if ( (LA146_2==COLON) ) {
						alt146=1;
					}
					}
					break;
				case DOTDOT:
					{
					int LA146_3 = input.LA(2);
					if ( (LA146_3==COLON) ) {
						alt146=1;
					}
					}
					break;
			}
			switch (alt146) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:28: aspectLoopType COLON
					{
					pushFollow(FOLLOW_aspectLoopType_in_aspectLoop7936);
					aspectLoopType589=aspectLoopType();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopType.add(aspectLoopType589.getTree());
					COLON590=(Token)match(input,COLON,FOLLOW_COLON_in_aspectLoop7938); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON590);

					}
					break;

			}

			pushFollow(FOLLOW_aspectIdentifier_in_aspectLoop7942);
			aspectIdentifier591=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier591.getTree());
			RPAREN592=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectLoop7944); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN592);

			// AST REWRITE
			// elements: aspectIdentifier, aspectLoopType
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 749:75: -> ^( ASPECTLOOP ( aspectLoopType )? aspectIdentifier )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:78: ^( ASPECTLOOP ( aspectLoopType )? aspectIdentifier )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTLOOP, "ASPECTLOOP"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:749:91: ( aspectLoopType )?
				if ( stream_aspectLoopType.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectLoopType.nextTree());
				}
				stream_aspectLoopType.reset();

				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectLoop"


	public static class aspectLoopBody_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectLoopBody"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:1: aspectLoopBody : wLOOPBODY LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOPBODY ( aspectLoopType )? aspectIdentifier ) ;
	public final MatlabParser.aspectLoopBody_return aspectLoopBody() throws RecognitionException {
		MatlabParser.aspectLoopBody_return retval = new MatlabParser.aspectLoopBody_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN594=null;
		Token COLON596=null;
		Token RPAREN598=null;
		ParserRuleReturnScope wLOOPBODY593 =null;
		ParserRuleReturnScope aspectLoopType595 =null;
		ParserRuleReturnScope aspectIdentifier597 =null;

		Object LPAREN594_tree=null;
		Object COLON596_tree=null;
		Object RPAREN598_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wLOOPBODY=new RewriteRuleSubtreeStream(adaptor,"rule wLOOPBODY");
		RewriteRuleSubtreeStream stream_aspectLoopType=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopType");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:16: ( wLOOPBODY LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOPBODY ( aspectLoopType )? aspectIdentifier ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:18: wLOOPBODY LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN
			{
			pushFollow(FOLLOW_wLOOPBODY_in_aspectLoopBody7965);
			wLOOPBODY593=wLOOPBODY();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wLOOPBODY.add(wLOOPBODY593.getTree());
			LPAREN594=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectLoopBody7967); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN594);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:35: ( aspectLoopType COLON )?
			int alt147=2;
			switch ( input.LA(1) ) {
				case FOR:
				case WHILE:
					{
					alt147=1;
					}
					break;
				case MTIMES:
					{
					int LA147_2 = input.LA(2);
					if ( (LA147_2==COLON) ) {
						alt147=1;
					}
					}
					break;
				case DOTDOT:
					{
					int LA147_3 = input.LA(2);
					if ( (LA147_3==COLON) ) {
						alt147=1;
					}
					}
					break;
			}
			switch (alt147) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:36: aspectLoopType COLON
					{
					pushFollow(FOLLOW_aspectLoopType_in_aspectLoopBody7970);
					aspectLoopType595=aspectLoopType();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopType.add(aspectLoopType595.getTree());
					COLON596=(Token)match(input,COLON,FOLLOW_COLON_in_aspectLoopBody7972); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON596);

					}
					break;

			}

			pushFollow(FOLLOW_aspectIdentifier_in_aspectLoopBody7976);
			aspectIdentifier597=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier597.getTree());
			RPAREN598=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectLoopBody7978); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN598);

			// AST REWRITE
			// elements: aspectIdentifier, aspectLoopType
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 751:83: -> ^( ASPECTLOOPBODY ( aspectLoopType )? aspectIdentifier )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:86: ^( ASPECTLOOPBODY ( aspectLoopType )? aspectIdentifier )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTLOOPBODY, "ASPECTLOOPBODY"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:751:103: ( aspectLoopType )?
				if ( stream_aspectLoopType.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectLoopType.nextTree());
				}
				stream_aspectLoopType.reset();

				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectLoopBody"


	public static class aspectLoopHead_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectLoopHead"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:1: aspectLoopHead : wLOOPHEAD LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOPHEAD ( aspectLoopType )? aspectIdentifier ) ;
	public final MatlabParser.aspectLoopHead_return aspectLoopHead() throws RecognitionException {
		MatlabParser.aspectLoopHead_return retval = new MatlabParser.aspectLoopHead_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN600=null;
		Token COLON602=null;
		Token RPAREN604=null;
		ParserRuleReturnScope wLOOPHEAD599 =null;
		ParserRuleReturnScope aspectLoopType601 =null;
		ParserRuleReturnScope aspectIdentifier603 =null;

		Object LPAREN600_tree=null;
		Object COLON602_tree=null;
		Object RPAREN604_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wLOOPHEAD=new RewriteRuleSubtreeStream(adaptor,"rule wLOOPHEAD");
		RewriteRuleSubtreeStream stream_aspectLoopType=new RewriteRuleSubtreeStream(adaptor,"rule aspectLoopType");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:16: ( wLOOPHEAD LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN -> ^( ASPECTLOOPHEAD ( aspectLoopType )? aspectIdentifier ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:18: wLOOPHEAD LPAREN ( aspectLoopType COLON )? aspectIdentifier RPAREN
			{
			pushFollow(FOLLOW_wLOOPHEAD_in_aspectLoopHead7999);
			wLOOPHEAD599=wLOOPHEAD();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wLOOPHEAD.add(wLOOPHEAD599.getTree());
			LPAREN600=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectLoopHead8001); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN600);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:35: ( aspectLoopType COLON )?
			int alt148=2;
			switch ( input.LA(1) ) {
				case FOR:
				case WHILE:
					{
					alt148=1;
					}
					break;
				case MTIMES:
					{
					int LA148_2 = input.LA(2);
					if ( (LA148_2==COLON) ) {
						alt148=1;
					}
					}
					break;
				case DOTDOT:
					{
					int LA148_3 = input.LA(2);
					if ( (LA148_3==COLON) ) {
						alt148=1;
					}
					}
					break;
			}
			switch (alt148) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:36: aspectLoopType COLON
					{
					pushFollow(FOLLOW_aspectLoopType_in_aspectLoopHead8004);
					aspectLoopType601=aspectLoopType();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectLoopType.add(aspectLoopType601.getTree());
					COLON602=(Token)match(input,COLON,FOLLOW_COLON_in_aspectLoopHead8006); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON602);

					}
					break;

			}

			pushFollow(FOLLOW_aspectIdentifier_in_aspectLoopHead8010);
			aspectIdentifier603=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier603.getTree());
			RPAREN604=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectLoopHead8012); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN604);

			// AST REWRITE
			// elements: aspectLoopType, aspectIdentifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 753:83: -> ^( ASPECTLOOPHEAD ( aspectLoopType )? aspectIdentifier )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:86: ^( ASPECTLOOPHEAD ( aspectLoopType )? aspectIdentifier )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTLOOPHEAD, "ASPECTLOOPHEAD"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:753:103: ( aspectLoopType )?
				if ( stream_aspectLoopType.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectLoopType.nextTree());
				}
				stream_aspectLoopType.reset();

				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectLoopHead"


	public static class aspectPartSelector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectPartSelector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:755:1: aspectPartSelector : ( wVAR -> wVAR | wSTR -> wSTR | wNUM -> wNUM | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectPartSelector_return aspectPartSelector() throws RecognitionException {
		MatlabParser.aspectPartSelector_return retval = new MatlabParser.aspectPartSelector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wVAR605 =null;
		ParserRuleReturnScope wSTR606 =null;
		ParserRuleReturnScope wNUM607 =null;
		ParserRuleReturnScope wSTAR608 =null;
		ParserRuleReturnScope wDOTDOT609 =null;

		RewriteRuleSubtreeStream stream_wVAR=new RewriteRuleSubtreeStream(adaptor,"rule wVAR");
		RewriteRuleSubtreeStream stream_wNUM=new RewriteRuleSubtreeStream(adaptor,"rule wNUM");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");
		RewriteRuleSubtreeStream stream_wSTR=new RewriteRuleSubtreeStream(adaptor,"rule wSTR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:755:20: ( wVAR -> wVAR | wSTR -> wSTR | wNUM -> wNUM | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt149=5;
			int LA149_0 = input.LA(1);
			if ( (LA149_0==ID) && (((Keyword_IdFollows("var"))||(Keyword_IdFollows("str"))||(Keyword_IdFollows("num"))))) {
				int LA149_1 = input.LA(2);
				if ( ((Keyword_IdFollows("var"))) ) {
					alt149=1;
				}
				else if ( ((Keyword_IdFollows("str"))) ) {
					alt149=2;
				}
				else if ( ((Keyword_IdFollows("num"))) ) {
					alt149=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 149, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA149_0==MTIMES) ) {
				alt149=4;
			}
			else if ( (LA149_0==DOTDOT) ) {
				alt149=5;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 149, 0, input);
				throw nvae;
			}

			switch (alt149) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:755:22: wVAR
					{
					pushFollow(FOLLOW_wVAR_in_aspectPartSelector8033);
					wVAR605=wVAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wVAR.add(wVAR605.getTree());
					// AST REWRITE
					// elements: wVAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 755:27: -> wVAR
					{
						adaptor.addChild(root_0, stream_wVAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:756:22: wSTR
					{
					pushFollow(FOLLOW_wSTR_in_aspectPartSelector8060);
					wSTR606=wSTR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTR.add(wSTR606.getTree());
					// AST REWRITE
					// elements: wSTR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 756:27: -> wSTR
					{
						adaptor.addChild(root_0, stream_wSTR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:757:22: wNUM
					{
					pushFollow(FOLLOW_wNUM_in_aspectPartSelector8087);
					wNUM607=wNUM();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wNUM.add(wNUM607.getTree());
					// AST REWRITE
					// elements: wNUM
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 757:27: -> wNUM
					{
						adaptor.addChild(root_0, stream_wNUM.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:758:22: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectPartSelector8114);
					wSTAR608=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR608.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 758:28: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:759:22: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectPartSelector8141);
					wDOTDOT609=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT609.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 759:30: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectPartSelector"


	public static class aspectSimpleSelector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSimpleSelector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:762:1: aspectSimpleSelector : aspectPartSelector -> ^( ASPECTSELECTOR aspectPartSelector ) ;
	public final MatlabParser.aspectSimpleSelector_return aspectSimpleSelector() throws RecognitionException {
		MatlabParser.aspectSimpleSelector_return retval = new MatlabParser.aspectSimpleSelector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectPartSelector610 =null;

		RewriteRuleSubtreeStream stream_aspectPartSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectPartSelector");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:762:22: ( aspectPartSelector -> ^( ASPECTSELECTOR aspectPartSelector ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:762:24: aspectPartSelector
			{
			pushFollow(FOLLOW_aspectPartSelector_in_aspectSimpleSelector8173);
			aspectPartSelector610=aspectPartSelector();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectPartSelector.add(aspectPartSelector610.getTree());
			// AST REWRITE
			// elements: aspectPartSelector
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 762:43: -> ^( ASPECTSELECTOR aspectPartSelector )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:762:46: ^( ASPECTSELECTOR aspectPartSelector )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTSELECTOR, "ASPECTSELECTOR"), root_1);
				adaptor.addChild(root_1, stream_aspectPartSelector.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSimpleSelector"


	public static class aspectCompoundSelector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectCompoundSelector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:1: aspectCompoundSelector : LSQUARE ( aspectPartSelector ( COMMA aspectPartSelector )* )? RSQUARE -> ^( ASPECTSELECTOR ( aspectPartSelector )* ) ;
	public final MatlabParser.aspectCompoundSelector_return aspectCompoundSelector() throws RecognitionException {
		MatlabParser.aspectCompoundSelector_return retval = new MatlabParser.aspectCompoundSelector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LSQUARE611=null;
		Token COMMA613=null;
		Token RSQUARE615=null;
		ParserRuleReturnScope aspectPartSelector612 =null;
		ParserRuleReturnScope aspectPartSelector614 =null;

		Object LSQUARE611_tree=null;
		Object COMMA613_tree=null;
		Object RSQUARE615_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,"token LSQUARE");
		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_aspectPartSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectPartSelector");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:24: ( LSQUARE ( aspectPartSelector ( COMMA aspectPartSelector )* )? RSQUARE -> ^( ASPECTSELECTOR ( aspectPartSelector )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:26: LSQUARE ( aspectPartSelector ( COMMA aspectPartSelector )* )? RSQUARE
			{
			LSQUARE611=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_aspectCompoundSelector8190); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE611);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:34: ( aspectPartSelector ( COMMA aspectPartSelector )* )?
			int alt151=2;
			int LA151_0 = input.LA(1);
			if ( (LA151_0==ID) && (((Keyword_IdFollows("var"))||(Keyword_IdFollows("str"))||(Keyword_IdFollows("num"))))) {
				alt151=1;
			}
			else if ( (LA151_0==DOTDOT||LA151_0==MTIMES) ) {
				alt151=1;
			}
			switch (alt151) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:35: aspectPartSelector ( COMMA aspectPartSelector )*
					{
					pushFollow(FOLLOW_aspectPartSelector_in_aspectCompoundSelector8193);
					aspectPartSelector612=aspectPartSelector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectPartSelector.add(aspectPartSelector612.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:54: ( COMMA aspectPartSelector )*
					loop150:
					while (true) {
						int alt150=2;
						int LA150_0 = input.LA(1);
						if ( (LA150_0==COMMA) ) {
							alt150=1;
						}

						switch (alt150) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:55: COMMA aspectPartSelector
							{
							COMMA613=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectCompoundSelector8196); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA613);

							pushFollow(FOLLOW_aspectPartSelector_in_aspectCompoundSelector8198);
							aspectPartSelector614=aspectPartSelector();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectPartSelector.add(aspectPartSelector614.getTree());
							}
							break;

						default :
							break loop150;
						}
					}

					}
					break;

			}

			RSQUARE615=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_aspectCompoundSelector8204); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE615);

			// AST REWRITE
			// elements: aspectPartSelector
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 764:92: -> ^( ASPECTSELECTOR ( aspectPartSelector )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:95: ^( ASPECTSELECTOR ( aspectPartSelector )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTSELECTOR, "ASPECTSELECTOR"), root_1);
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:764:112: ( aspectPartSelector )*
				while ( stream_aspectPartSelector.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectPartSelector.nextTree());
				}
				stream_aspectPartSelector.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectCompoundSelector"


	public static class aspectSelector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectSelector"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:766:1: aspectSelector : ( aspectSimpleSelector -> aspectSimpleSelector | aspectCompoundSelector -> aspectCompoundSelector );
	public final MatlabParser.aspectSelector_return aspectSelector() throws RecognitionException {
		MatlabParser.aspectSelector_return retval = new MatlabParser.aspectSelector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope aspectSimpleSelector616 =null;
		ParserRuleReturnScope aspectCompoundSelector617 =null;

		RewriteRuleSubtreeStream stream_aspectCompoundSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectCompoundSelector");
		RewriteRuleSubtreeStream stream_aspectSimpleSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectSimpleSelector");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:766:16: ( aspectSimpleSelector -> aspectSimpleSelector | aspectCompoundSelector -> aspectCompoundSelector )
			int alt152=2;
			int LA152_0 = input.LA(1);
			if ( (LA152_0==ID) && (((Keyword_IdFollows("var"))||(Keyword_IdFollows("str"))||(Keyword_IdFollows("num"))))) {
				alt152=1;
			}
			else if ( (LA152_0==DOTDOT||LA152_0==MTIMES) ) {
				alt152=1;
			}
			else if ( (LA152_0==LSQUARE) ) {
				alt152=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 152, 0, input);
				throw nvae;
			}

			switch (alt152) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:766:18: aspectSimpleSelector
					{
					pushFollow(FOLLOW_aspectSimpleSelector_in_aspectSelector8223);
					aspectSimpleSelector616=aspectSimpleSelector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectSimpleSelector.add(aspectSimpleSelector616.getTree());
					// AST REWRITE
					// elements: aspectSimpleSelector
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 766:39: -> aspectSimpleSelector
					{
						adaptor.addChild(root_0, stream_aspectSimpleSelector.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:767:18: aspectCompoundSelector
					{
					pushFollow(FOLLOW_aspectCompoundSelector_in_aspectSelector8246);
					aspectCompoundSelector617=aspectCompoundSelector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectCompoundSelector.add(aspectCompoundSelector617.getTree());
					// AST REWRITE
					// elements: aspectCompoundSelector
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 767:41: -> aspectCompoundSelector
					{
						adaptor.addChild(root_0, stream_aspectCompoundSelector.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectSelector"


	public static class aspectAnnotate_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectAnnotate"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:1: aspectAnnotate : wANNOTATE LPAREN aspectIdentifier LPAREN ( aspectSelector ( COMMA aspectSelector )* )? RPAREN RPAREN -> ^( ASPECTANNOTATE aspectIdentifier ( aspectSelector )* ) ;
	public final MatlabParser.aspectAnnotate_return aspectAnnotate() throws RecognitionException {
		MatlabParser.aspectAnnotate_return retval = new MatlabParser.aspectAnnotate_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN619=null;
		Token LPAREN621=null;
		Token COMMA623=null;
		Token RPAREN625=null;
		Token RPAREN626=null;
		ParserRuleReturnScope wANNOTATE618 =null;
		ParserRuleReturnScope aspectIdentifier620 =null;
		ParserRuleReturnScope aspectSelector622 =null;
		ParserRuleReturnScope aspectSelector624 =null;

		Object LPAREN619_tree=null;
		Object LPAREN621_tree=null;
		Object COMMA623_tree=null;
		Object RPAREN625_tree=null;
		Object RPAREN626_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectSelector=new RewriteRuleSubtreeStream(adaptor,"rule aspectSelector");
		RewriteRuleSubtreeStream stream_wANNOTATE=new RewriteRuleSubtreeStream(adaptor,"rule wANNOTATE");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:16: ( wANNOTATE LPAREN aspectIdentifier LPAREN ( aspectSelector ( COMMA aspectSelector )* )? RPAREN RPAREN -> ^( ASPECTANNOTATE aspectIdentifier ( aspectSelector )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:18: wANNOTATE LPAREN aspectIdentifier LPAREN ( aspectSelector ( COMMA aspectSelector )* )? RPAREN RPAREN
			{
			pushFollow(FOLLOW_wANNOTATE_in_aspectAnnotate8274);
			wANNOTATE618=wANNOTATE();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wANNOTATE.add(wANNOTATE618.getTree());
			LPAREN619=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectAnnotate8276); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN619);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectAnnotate8278);
			aspectIdentifier620=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier620.getTree());
			LPAREN621=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectAnnotate8280); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN621);

			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:59: ( aspectSelector ( COMMA aspectSelector )* )?
			int alt154=2;
			int LA154_0 = input.LA(1);
			if ( (LA154_0==ID) && (((Keyword_IdFollows("var"))||(Keyword_IdFollows("str"))||(Keyword_IdFollows("num"))))) {
				alt154=1;
			}
			else if ( (LA154_0==DOTDOT||LA154_0==LSQUARE||LA154_0==MTIMES) ) {
				alt154=1;
			}
			switch (alt154) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:60: aspectSelector ( COMMA aspectSelector )*
					{
					pushFollow(FOLLOW_aspectSelector_in_aspectAnnotate8283);
					aspectSelector622=aspectSelector();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectSelector.add(aspectSelector622.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:75: ( COMMA aspectSelector )*
					loop153:
					while (true) {
						int alt153=2;
						int LA153_0 = input.LA(1);
						if ( (LA153_0==COMMA) ) {
							alt153=1;
						}

						switch (alt153) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:76: COMMA aspectSelector
							{
							COMMA623=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectAnnotate8286); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA623);

							pushFollow(FOLLOW_aspectSelector_in_aspectAnnotate8288);
							aspectSelector624=aspectSelector();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectSelector.add(aspectSelector624.getTree());
							}
							break;

						default :
							break loop153;
						}
					}

					}
					break;

			}

			RPAREN625=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectAnnotate8294); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN625);

			RPAREN626=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectAnnotate8296); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN626);

			// AST REWRITE
			// elements: aspectIdentifier, aspectSelector
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 770:115: -> ^( ASPECTANNOTATE aspectIdentifier ( aspectSelector )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:118: ^( ASPECTANNOTATE aspectIdentifier ( aspectSelector )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTANNOTATE, "ASPECTANNOTATE"), root_1);
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:770:152: ( aspectSelector )*
				while ( stream_aspectSelector.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectSelector.nextTree());
				}
				stream_aspectSelector.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectAnnotate"


	public static class aspectOperatorType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectOperatorType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:772:1: aspectOperatorType : ( wPLUS -> wPLUS | wMINUS -> wMINUS | wMTIMES -> wMTIMES | wTIMES -> wTIMES | wMRDIV -> wMRDIV | wRDIV -> wRDIV | wMLDIV -> wMLDIV | wLDIV -> wLDIV | wMPOW -> wMPOW | wPOW -> wPOW | wCTRANS -> CTRANS | wTRANS -> wTRANS );
	public final MatlabParser.aspectOperatorType_return aspectOperatorType() throws RecognitionException {
		MatlabParser.aspectOperatorType_return retval = new MatlabParser.aspectOperatorType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wPLUS627 =null;
		ParserRuleReturnScope wMINUS628 =null;
		ParserRuleReturnScope wMTIMES629 =null;
		ParserRuleReturnScope wTIMES630 =null;
		ParserRuleReturnScope wMRDIV631 =null;
		ParserRuleReturnScope wRDIV632 =null;
		ParserRuleReturnScope wMLDIV633 =null;
		ParserRuleReturnScope wLDIV634 =null;
		ParserRuleReturnScope wMPOW635 =null;
		ParserRuleReturnScope wPOW636 =null;
		ParserRuleReturnScope wCTRANS637 =null;
		ParserRuleReturnScope wTRANS638 =null;

		RewriteRuleSubtreeStream stream_wMRDIV=new RewriteRuleSubtreeStream(adaptor,"rule wMRDIV");
		RewriteRuleSubtreeStream stream_wPLUS=new RewriteRuleSubtreeStream(adaptor,"rule wPLUS");
		RewriteRuleSubtreeStream stream_wMPOW=new RewriteRuleSubtreeStream(adaptor,"rule wMPOW");
		RewriteRuleSubtreeStream stream_wRDIV=new RewriteRuleSubtreeStream(adaptor,"rule wRDIV");
		RewriteRuleSubtreeStream stream_wPOW=new RewriteRuleSubtreeStream(adaptor,"rule wPOW");
		RewriteRuleSubtreeStream stream_wTRANS=new RewriteRuleSubtreeStream(adaptor,"rule wTRANS");
		RewriteRuleSubtreeStream stream_wMINUS=new RewriteRuleSubtreeStream(adaptor,"rule wMINUS");
		RewriteRuleSubtreeStream stream_wMLDIV=new RewriteRuleSubtreeStream(adaptor,"rule wMLDIV");
		RewriteRuleSubtreeStream stream_wMTIMES=new RewriteRuleSubtreeStream(adaptor,"rule wMTIMES");
		RewriteRuleSubtreeStream stream_wLDIV=new RewriteRuleSubtreeStream(adaptor,"rule wLDIV");
		RewriteRuleSubtreeStream stream_wCTRANS=new RewriteRuleSubtreeStream(adaptor,"rule wCTRANS");
		RewriteRuleSubtreeStream stream_wTIMES=new RewriteRuleSubtreeStream(adaptor,"rule wTIMES");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:772:20: ( wPLUS -> wPLUS | wMINUS -> wMINUS | wMTIMES -> wMTIMES | wTIMES -> wTIMES | wMRDIV -> wMRDIV | wRDIV -> wRDIV | wMLDIV -> wMLDIV | wLDIV -> wLDIV | wMPOW -> wMPOW | wPOW -> wPOW | wCTRANS -> CTRANS | wTRANS -> wTRANS )
			int alt155=12;
			switch ( input.LA(1) ) {
			case PLUS:
				{
				alt155=1;
				}
				break;
			case MINUS:
				{
				alt155=2;
				}
				break;
			case MTIMES:
				{
				alt155=3;
				}
				break;
			case TIMES:
				{
				alt155=4;
				}
				break;
			case MRDIV:
				{
				alt155=5;
				}
				break;
			case RDIV:
				{
				alt155=6;
				}
				break;
			case MLDIV:
				{
				alt155=7;
				}
				break;
			case LDIV:
				{
				alt155=8;
				}
				break;
			case MPOW:
				{
				alt155=9;
				}
				break;
			case POW:
				{
				alt155=10;
				}
				break;
			case CTRANS:
				{
				alt155=11;
				}
				break;
			case TRANS:
				{
				alt155=12;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 155, 0, input);
				throw nvae;
			}
			switch (alt155) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:772:22: wPLUS
					{
					pushFollow(FOLLOW_wPLUS_in_aspectOperatorType8318);
					wPLUS627=wPLUS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wPLUS.add(wPLUS627.getTree());
					// AST REWRITE
					// elements: wPLUS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 772:28: -> wPLUS
					{
						adaptor.addChild(root_0, stream_wPLUS.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:773:22: wMINUS
					{
					pushFollow(FOLLOW_wMINUS_in_aspectOperatorType8345);
					wMINUS628=wMINUS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMINUS.add(wMINUS628.getTree());
					// AST REWRITE
					// elements: wMINUS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 773:29: -> wMINUS
					{
						adaptor.addChild(root_0, stream_wMINUS.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:774:22: wMTIMES
					{
					pushFollow(FOLLOW_wMTIMES_in_aspectOperatorType8372);
					wMTIMES629=wMTIMES();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMTIMES.add(wMTIMES629.getTree());
					// AST REWRITE
					// elements: wMTIMES
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 774:30: -> wMTIMES
					{
						adaptor.addChild(root_0, stream_wMTIMES.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:775:22: wTIMES
					{
					pushFollow(FOLLOW_wTIMES_in_aspectOperatorType8399);
					wTIMES630=wTIMES();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wTIMES.add(wTIMES630.getTree());
					// AST REWRITE
					// elements: wTIMES
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 775:29: -> wTIMES
					{
						adaptor.addChild(root_0, stream_wTIMES.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:776:22: wMRDIV
					{
					pushFollow(FOLLOW_wMRDIV_in_aspectOperatorType8426);
					wMRDIV631=wMRDIV();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMRDIV.add(wMRDIV631.getTree());
					// AST REWRITE
					// elements: wMRDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 776:29: -> wMRDIV
					{
						adaptor.addChild(root_0, stream_wMRDIV.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:777:22: wRDIV
					{
					pushFollow(FOLLOW_wRDIV_in_aspectOperatorType8453);
					wRDIV632=wRDIV();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wRDIV.add(wRDIV632.getTree());
					// AST REWRITE
					// elements: wRDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 777:28: -> wRDIV
					{
						adaptor.addChild(root_0, stream_wRDIV.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:778:22: wMLDIV
					{
					pushFollow(FOLLOW_wMLDIV_in_aspectOperatorType8480);
					wMLDIV633=wMLDIV();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMLDIV.add(wMLDIV633.getTree());
					// AST REWRITE
					// elements: wMLDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 778:29: -> wMLDIV
					{
						adaptor.addChild(root_0, stream_wMLDIV.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 8 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:779:22: wLDIV
					{
					pushFollow(FOLLOW_wLDIV_in_aspectOperatorType8507);
					wLDIV634=wLDIV();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wLDIV.add(wLDIV634.getTree());
					// AST REWRITE
					// elements: wLDIV
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 779:28: -> wLDIV
					{
						adaptor.addChild(root_0, stream_wLDIV.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 9 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:780:22: wMPOW
					{
					pushFollow(FOLLOW_wMPOW_in_aspectOperatorType8534);
					wMPOW635=wMPOW();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wMPOW.add(wMPOW635.getTree());
					// AST REWRITE
					// elements: wMPOW
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 780:28: -> wMPOW
					{
						adaptor.addChild(root_0, stream_wMPOW.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 10 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:781:22: wPOW
					{
					pushFollow(FOLLOW_wPOW_in_aspectOperatorType8561);
					wPOW636=wPOW();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wPOW.add(wPOW636.getTree());
					// AST REWRITE
					// elements: wPOW
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 781:27: -> wPOW
					{
						adaptor.addChild(root_0, stream_wPOW.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 11 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:782:22: wCTRANS
					{
					pushFollow(FOLLOW_wCTRANS_in_aspectOperatorType8588);
					wCTRANS637=wCTRANS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wCTRANS.add(wCTRANS637.getTree());
					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 782:30: -> CTRANS
					{
						adaptor.addChild(root_0, (Object)adaptor.create(CTRANS, "CTRANS"));
					}


					retval.tree = root_0;
					}

					}
					break;
				case 12 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:783:22: wTRANS
					{
					pushFollow(FOLLOW_wTRANS_in_aspectOperatorType8615);
					wTRANS638=wTRANS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wTRANS.add(wTRANS638.getTree());
					// AST REWRITE
					// elements: wTRANS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 783:29: -> wTRANS
					{
						adaptor.addChild(root_0, stream_wTRANS.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectOperatorType"


	public static class aspectOperator_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectOperator"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:1: aspectOperator : wOPERATOR LPAREN aspectOperatorType ( COLON aspectFullSignature ( COMMA aspectFullSignature )* )? RPAREN -> ^( ASPECTOPERATOR aspectOperatorType ( aspectFullSignature )* ) ;
	public final MatlabParser.aspectOperator_return aspectOperator() throws RecognitionException {
		MatlabParser.aspectOperator_return retval = new MatlabParser.aspectOperator_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN640=null;
		Token COLON642=null;
		Token COMMA644=null;
		Token RPAREN646=null;
		ParserRuleReturnScope wOPERATOR639 =null;
		ParserRuleReturnScope aspectOperatorType641 =null;
		ParserRuleReturnScope aspectFullSignature643 =null;
		ParserRuleReturnScope aspectFullSignature645 =null;

		Object LPAREN640_tree=null;
		Object COLON642_tree=null;
		Object COMMA644_tree=null;
		Object RPAREN646_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wOPERATOR=new RewriteRuleSubtreeStream(adaptor,"rule wOPERATOR");
		RewriteRuleSubtreeStream stream_aspectFullSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectFullSignature");
		RewriteRuleSubtreeStream stream_aspectOperatorType=new RewriteRuleSubtreeStream(adaptor,"rule aspectOperatorType");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:16: ( wOPERATOR LPAREN aspectOperatorType ( COLON aspectFullSignature ( COMMA aspectFullSignature )* )? RPAREN -> ^( ASPECTOPERATOR aspectOperatorType ( aspectFullSignature )* ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:18: wOPERATOR LPAREN aspectOperatorType ( COLON aspectFullSignature ( COMMA aspectFullSignature )* )? RPAREN
			{
			pushFollow(FOLLOW_wOPERATOR_in_aspectOperator8647);
			wOPERATOR639=wOPERATOR();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wOPERATOR.add(wOPERATOR639.getTree());
			LPAREN640=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectOperator8649); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN640);

			pushFollow(FOLLOW_aspectOperatorType_in_aspectOperator8651);
			aspectOperatorType641=aspectOperatorType();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectOperatorType.add(aspectOperatorType641.getTree());
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:54: ( COLON aspectFullSignature ( COMMA aspectFullSignature )* )?
			int alt157=2;
			int LA157_0 = input.LA(1);
			if ( (LA157_0==COLON) ) {
				alt157=1;
			}
			switch (alt157) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:55: COLON aspectFullSignature ( COMMA aspectFullSignature )*
					{
					COLON642=(Token)match(input,COLON,FOLLOW_COLON_in_aspectOperator8654); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COLON.add(COLON642);

					pushFollow(FOLLOW_aspectFullSignature_in_aspectOperator8656);
					aspectFullSignature643=aspectFullSignature();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature643.getTree());
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:81: ( COMMA aspectFullSignature )*
					loop156:
					while (true) {
						int alt156=2;
						int LA156_0 = input.LA(1);
						if ( (LA156_0==COMMA) ) {
							alt156=1;
						}

						switch (alt156) {
						case 1 :
							// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:82: COMMA aspectFullSignature
							{
							COMMA644=(Token)match(input,COMMA,FOLLOW_COMMA_in_aspectOperator8659); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA644);

							pushFollow(FOLLOW_aspectFullSignature_in_aspectOperator8661);
							aspectFullSignature645=aspectFullSignature();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_aspectFullSignature.add(aspectFullSignature645.getTree());
							}
							break;

						default :
							break loop156;
						}
					}

					}
					break;

			}

			RPAREN646=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectOperator8667); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN646);

			// AST REWRITE
			// elements: aspectFullSignature, aspectOperatorType
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 786:119: -> ^( ASPECTOPERATOR aspectOperatorType ( aspectFullSignature )* )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:122: ^( ASPECTOPERATOR aspectOperatorType ( aspectFullSignature )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTOPERATOR, "ASPECTOPERATOR"), root_1);
				adaptor.addChild(root_1, stream_aspectOperatorType.nextTree());
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:786:158: ( aspectFullSignature )*
				while ( stream_aspectFullSignature.hasNext() ) {
					adaptor.addChild(root_1, stream_aspectFullSignature.nextTree());
				}
				stream_aspectFullSignature.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectOperator"


	public static class aspectWithin_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectWithin"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:788:1: aspectWithin : wWITHIN LPAREN aspectScopeType COLON aspectIdentifier RPAREN -> ^( ASPECTWITHIN aspectScopeType aspectIdentifier ) ;
	public final MatlabParser.aspectWithin_return aspectWithin() throws RecognitionException {
		MatlabParser.aspectWithin_return retval = new MatlabParser.aspectWithin_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN648=null;
		Token COLON650=null;
		Token RPAREN652=null;
		ParserRuleReturnScope wWITHIN647 =null;
		ParserRuleReturnScope aspectScopeType649 =null;
		ParserRuleReturnScope aspectIdentifier651 =null;

		Object LPAREN648_tree=null;
		Object COLON650_tree=null;
		Object RPAREN652_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,"token COLON");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectScopeType=new RewriteRuleSubtreeStream(adaptor,"rule aspectScopeType");
		RewriteRuleSubtreeStream stream_wWITHIN=new RewriteRuleSubtreeStream(adaptor,"rule wWITHIN");
		RewriteRuleSubtreeStream stream_aspectIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule aspectIdentifier");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:788:14: ( wWITHIN LPAREN aspectScopeType COLON aspectIdentifier RPAREN -> ^( ASPECTWITHIN aspectScopeType aspectIdentifier ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:788:16: wWITHIN LPAREN aspectScopeType COLON aspectIdentifier RPAREN
			{
			pushFollow(FOLLOW_wWITHIN_in_aspectWithin8689);
			wWITHIN647=wWITHIN();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wWITHIN.add(wWITHIN647.getTree());
			LPAREN648=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectWithin8691); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN648);

			pushFollow(FOLLOW_aspectScopeType_in_aspectWithin8693);
			aspectScopeType649=aspectScopeType();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectScopeType.add(aspectScopeType649.getTree());
			COLON650=(Token)match(input,COLON,FOLLOW_COLON_in_aspectWithin8695); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COLON.add(COLON650);

			pushFollow(FOLLOW_aspectIdentifier_in_aspectWithin8697);
			aspectIdentifier651=aspectIdentifier();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectIdentifier.add(aspectIdentifier651.getTree());
			RPAREN652=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectWithin8699); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN652);

			// AST REWRITE
			// elements: aspectScopeType, aspectIdentifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 788:77: -> ^( ASPECTWITHIN aspectScopeType aspectIdentifier )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:788:80: ^( ASPECTWITHIN aspectScopeType aspectIdentifier )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTWITHIN, "ASPECTWITHIN"), root_1);
				adaptor.addChild(root_1, stream_aspectScopeType.nextTree());
				adaptor.addChild(root_1, stream_aspectIdentifier.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectWithin"


	public static class aspectScopeType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectScopeType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:790:1: aspectScopeType : ( wFUNCTION -> wFUNCTION | wSCRIPT -> wSCRIPT | wCLASS -> wCLASS | wASPECT -> wASPECT | wLOOP -> wLOOP | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT );
	public final MatlabParser.aspectScopeType_return aspectScopeType() throws RecognitionException {
		MatlabParser.aspectScopeType_return retval = new MatlabParser.aspectScopeType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wFUNCTION653 =null;
		ParserRuleReturnScope wSCRIPT654 =null;
		ParserRuleReturnScope wCLASS655 =null;
		ParserRuleReturnScope wASPECT656 =null;
		ParserRuleReturnScope wLOOP657 =null;
		ParserRuleReturnScope wSTAR658 =null;
		ParserRuleReturnScope wDOTDOT659 =null;

		RewriteRuleSubtreeStream stream_wCLASS=new RewriteRuleSubtreeStream(adaptor,"rule wCLASS");
		RewriteRuleSubtreeStream stream_wASPECT=new RewriteRuleSubtreeStream(adaptor,"rule wASPECT");
		RewriteRuleSubtreeStream stream_wDOTDOT=new RewriteRuleSubtreeStream(adaptor,"rule wDOTDOT");
		RewriteRuleSubtreeStream stream_wSTAR=new RewriteRuleSubtreeStream(adaptor,"rule wSTAR");
		RewriteRuleSubtreeStream stream_wFUNCTION=new RewriteRuleSubtreeStream(adaptor,"rule wFUNCTION");
		RewriteRuleSubtreeStream stream_wLOOP=new RewriteRuleSubtreeStream(adaptor,"rule wLOOP");
		RewriteRuleSubtreeStream stream_wSCRIPT=new RewriteRuleSubtreeStream(adaptor,"rule wSCRIPT");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:790:17: ( wFUNCTION -> wFUNCTION | wSCRIPT -> wSCRIPT | wCLASS -> wCLASS | wASPECT -> wASPECT | wLOOP -> wLOOP | wSTAR -> wSTAR | wDOTDOT -> wDOTDOT )
			int alt158=7;
			int LA158_0 = input.LA(1);
			if ( (LA158_0==FUNCTION) ) {
				alt158=1;
			}
			else if ( (LA158_0==ID) && (((Keyword_IdFollows("aspect"))||(Keyword_IdFollows("class"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("script"))))) {
				int LA158_2 = input.LA(2);
				if ( ((Keyword_IdFollows("script"))) ) {
					alt158=2;
				}
				else if ( ((Keyword_IdFollows("class"))) ) {
					alt158=3;
				}
				else if ( ((Keyword_IdFollows("aspect"))) ) {
					alt158=4;
				}
				else if ( ((Keyword_IdFollows("loop"))) ) {
					alt158=5;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 158, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA158_0==MTIMES) ) {
				alt158=6;
			}
			else if ( (LA158_0==DOTDOT) ) {
				alt158=7;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 158, 0, input);
				throw nvae;
			}

			switch (alt158) {
				case 1 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:790:19: wFUNCTION
					{
					pushFollow(FOLLOW_wFUNCTION_in_aspectScopeType8718);
					wFUNCTION653=wFUNCTION();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wFUNCTION.add(wFUNCTION653.getTree());
					// AST REWRITE
					// elements: wFUNCTION
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 790:29: -> wFUNCTION
					{
						adaptor.addChild(root_0, stream_wFUNCTION.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:791:19: wSCRIPT
					{
					pushFollow(FOLLOW_wSCRIPT_in_aspectScopeType8742);
					wSCRIPT654=wSCRIPT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSCRIPT.add(wSCRIPT654.getTree());
					// AST REWRITE
					// elements: wSCRIPT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 791:27: -> wSCRIPT
					{
						adaptor.addChild(root_0, stream_wSCRIPT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:792:19: wCLASS
					{
					pushFollow(FOLLOW_wCLASS_in_aspectScopeType8766);
					wCLASS655=wCLASS();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wCLASS.add(wCLASS655.getTree());
					// AST REWRITE
					// elements: wCLASS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 792:26: -> wCLASS
					{
						adaptor.addChild(root_0, stream_wCLASS.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:793:19: wASPECT
					{
					pushFollow(FOLLOW_wASPECT_in_aspectScopeType8790);
					wASPECT656=wASPECT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wASPECT.add(wASPECT656.getTree());
					// AST REWRITE
					// elements: wASPECT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 793:27: -> wASPECT
					{
						adaptor.addChild(root_0, stream_wASPECT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:794:19: wLOOP
					{
					pushFollow(FOLLOW_wLOOP_in_aspectScopeType8814);
					wLOOP657=wLOOP();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wLOOP.add(wLOOP657.getTree());
					// AST REWRITE
					// elements: wLOOP
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 794:25: -> wLOOP
					{
						adaptor.addChild(root_0, stream_wLOOP.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 6 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:795:19: wSTAR
					{
					pushFollow(FOLLOW_wSTAR_in_aspectScopeType8838);
					wSTAR658=wSTAR();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wSTAR.add(wSTAR658.getTree());
					// AST REWRITE
					// elements: wSTAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 795:25: -> wSTAR
					{
						adaptor.addChild(root_0, stream_wSTAR.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 7 :
					// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:796:19: wDOTDOT
					{
					pushFollow(FOLLOW_wDOTDOT_in_aspectScopeType8862);
					wDOTDOT659=wDOTDOT();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wDOTDOT.add(wDOTDOT659.getTree());
					// AST REWRITE
					// elements: wDOTDOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 796:27: -> wDOTDOT
					{
						adaptor.addChild(root_0, stream_wDOTDOT.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectScopeType"


	public static class aspectDimension_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectDimension"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:799:1: aspectDimension : wDIMENSION LPAREN aspectDimensionSignature RPAREN -> ^( ASPECTDIMENSION aspectDimensionSignature ) ;
	public final MatlabParser.aspectDimension_return aspectDimension() throws RecognitionException {
		MatlabParser.aspectDimension_return retval = new MatlabParser.aspectDimension_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN661=null;
		Token RPAREN663=null;
		ParserRuleReturnScope wDIMENSION660 =null;
		ParserRuleReturnScope aspectDimensionSignature662 =null;

		Object LPAREN661_tree=null;
		Object RPAREN663_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_aspectDimensionSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectDimensionSignature");
		RewriteRuleSubtreeStream stream_wDIMENSION=new RewriteRuleSubtreeStream(adaptor,"rule wDIMENSION");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:799:17: ( wDIMENSION LPAREN aspectDimensionSignature RPAREN -> ^( ASPECTDIMENSION aspectDimensionSignature ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:799:19: wDIMENSION LPAREN aspectDimensionSignature RPAREN
			{
			pushFollow(FOLLOW_wDIMENSION_in_aspectDimension8891);
			wDIMENSION660=wDIMENSION();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wDIMENSION.add(wDIMENSION660.getTree());
			LPAREN661=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectDimension8893); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN661);

			pushFollow(FOLLOW_aspectDimensionSignature_in_aspectDimension8895);
			aspectDimensionSignature662=aspectDimensionSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectDimensionSignature.add(aspectDimensionSignature662.getTree());
			RPAREN663=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectDimension8897); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN663);

			// AST REWRITE
			// elements: aspectDimensionSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 799:69: -> ^( ASPECTDIMENSION aspectDimensionSignature )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:799:72: ^( ASPECTDIMENSION aspectDimensionSignature )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTDIMENSION, "ASPECTDIMENSION"), root_1);
				adaptor.addChild(root_1, stream_aspectDimensionSignature.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectDimension"


	public static class aspectIsType_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aspectIsType"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:801:1: aspectIsType : wISTYPE LPAREN aspectTypeSignature RPAREN -> ^( ASPECTISTYPE aspectTypeSignature ) ;
	public final MatlabParser.aspectIsType_return aspectIsType() throws RecognitionException {
		MatlabParser.aspectIsType_return retval = new MatlabParser.aspectIsType_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LPAREN665=null;
		Token RPAREN667=null;
		ParserRuleReturnScope wISTYPE664 =null;
		ParserRuleReturnScope aspectTypeSignature666 =null;

		Object LPAREN665_tree=null;
		Object RPAREN667_tree=null;
		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,"token LPAREN");
		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_wISTYPE=new RewriteRuleSubtreeStream(adaptor,"rule wISTYPE");
		RewriteRuleSubtreeStream stream_aspectTypeSignature=new RewriteRuleSubtreeStream(adaptor,"rule aspectTypeSignature");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:801:14: ( wISTYPE LPAREN aspectTypeSignature RPAREN -> ^( ASPECTISTYPE aspectTypeSignature ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:801:16: wISTYPE LPAREN aspectTypeSignature RPAREN
			{
			pushFollow(FOLLOW_wISTYPE_in_aspectIsType8913);
			wISTYPE664=wISTYPE();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_wISTYPE.add(wISTYPE664.getTree());
			LPAREN665=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_aspectIsType8915); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN665);

			pushFollow(FOLLOW_aspectTypeSignature_in_aspectIsType8917);
			aspectTypeSignature666=aspectTypeSignature();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aspectTypeSignature.add(aspectTypeSignature666.getTree());
			RPAREN667=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_aspectIsType8919); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN667);

			// AST REWRITE
			// elements: aspectTypeSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 801:58: -> ^( ASPECTISTYPE aspectTypeSignature )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:801:61: ^( ASPECTISTYPE aspectTypeSignature )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASPECTISTYPE, "ASPECTISTYPE"), root_1);
				adaptor.addChild(root_1, stream_aspectTypeSignature.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aspectIsType"


	public static class wID_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wID"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:805:1: wID : ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wID_return wID() throws RecognitionException {
		MatlabParser.wID_return retval = new MatlabParser.wID_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID668=null;

		Object ID668_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:805:5: ( ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:805:7: ID
			{
			ID668=(Token)match(input,ID,FOLLOW_ID_in_wID8938); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID668);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 805:10: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:805:13: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wID"


	public static class wREAL_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wREAL"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:807:1: wREAL : REAL -> ^( NAME[\"\"] ID[$REAL] ) ;
	public final MatlabParser.wREAL_return wREAL() throws RecognitionException {
		MatlabParser.wREAL_return retval = new MatlabParser.wREAL_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REAL669=null;

		Object REAL669_tree=null;
		RewriteRuleTokenStream stream_REAL=new RewriteRuleTokenStream(adaptor,"token REAL");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:807:7: ( REAL -> ^( NAME[\"\"] ID[$REAL] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:807:9: REAL
			{
			REAL669=(Token)match(input,REAL,FOLLOW_REAL_in_wREAL8956); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REAL.add(REAL669);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 807:14: -> ^( NAME[\"\"] ID[$REAL] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:807:17: ^( NAME[\"\"] ID[$REAL] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, REAL669));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wREAL"


	public static class wASPECT_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wASPECT"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:809:1: wASPECT :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wASPECT_return wASPECT() throws RecognitionException {
		MatlabParser.wASPECT_return retval = new MatlabParser.wASPECT_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID670=null;

		Object ID670_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:809:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:809:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("aspect"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wASPECT", "Keyword_IdFollows(\"aspect\")");
			}
			ID670=(Token)match(input,ID,FOLLOW_ID_in_wASPECT8978); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID670);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 809:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:809:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wASPECT"


	public static class wACTIONS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wACTIONS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:811:1: wACTIONS :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wACTIONS_return wACTIONS() throws RecognitionException {
		MatlabParser.wACTIONS_return retval = new MatlabParser.wACTIONS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID671=null;

		Object ID671_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:811:10: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:811:12: {...}? => ID
			{
			if ( !((Keyword_IdFollows("actions"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wACTIONS", "Keyword_IdFollows(\"actions\")");
			}
			ID671=(Token)match(input,ID,FOLLOW_ID_in_wACTIONS8999); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID671);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 811:49: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:811:52: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wACTIONS"


	public static class wPATTERNS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wPATTERNS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:813:1: wPATTERNS :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wPATTERNS_return wPATTERNS() throws RecognitionException {
		MatlabParser.wPATTERNS_return retval = new MatlabParser.wPATTERNS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID672=null;

		Object ID672_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:813:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:813:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("patterns"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wPATTERNS", "Keyword_IdFollows(\"patterns\")");
			}
			ID672=(Token)match(input,ID,FOLLOW_ID_in_wPATTERNS9020); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID672);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 813:51: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:813:54: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wPATTERNS"


	public static class wBEFORE_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wBEFORE"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:815:1: wBEFORE :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wBEFORE_return wBEFORE() throws RecognitionException {
		MatlabParser.wBEFORE_return retval = new MatlabParser.wBEFORE_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID673=null;

		Object ID673_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:815:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:815:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("before"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wBEFORE", "Keyword_IdFollows(\"before\")");
			}
			ID673=(Token)match(input,ID,FOLLOW_ID_in_wBEFORE9041); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID673);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 815:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:815:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wBEFORE"


	public static class wAFTER_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wAFTER"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:817:1: wAFTER :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wAFTER_return wAFTER() throws RecognitionException {
		MatlabParser.wAFTER_return retval = new MatlabParser.wAFTER_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID674=null;

		Object ID674_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:817:8: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:817:10: {...}? => ID
			{
			if ( !((Keyword_IdFollows("after"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wAFTER", "Keyword_IdFollows(\"after\")");
			}
			ID674=(Token)match(input,ID,FOLLOW_ID_in_wAFTER9062); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID674);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 817:45: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:817:48: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wAFTER"


	public static class wAROUND_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wAROUND"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:819:1: wAROUND :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wAROUND_return wAROUND() throws RecognitionException {
		MatlabParser.wAROUND_return retval = new MatlabParser.wAROUND_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID675=null;

		Object ID675_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:819:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:819:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("around"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wAROUND", "Keyword_IdFollows(\"around\")");
			}
			ID675=(Token)match(input,ID,FOLLOW_ID_in_wAROUND9083); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID675);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 819:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:819:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wAROUND"


	public static class wGET_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wGET"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:821:1: wGET :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wGET_return wGET() throws RecognitionException {
		MatlabParser.wGET_return retval = new MatlabParser.wGET_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID676=null;

		Object ID676_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:821:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:821:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("get"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wGET", "Keyword_IdFollows(\"get\")");
			}
			ID676=(Token)match(input,ID,FOLLOW_ID_in_wGET9104); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID676);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 821:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:821:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wGET"


	public static class wSET_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wSET"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:823:1: wSET :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wSET_return wSET() throws RecognitionException {
		MatlabParser.wSET_return retval = new MatlabParser.wSET_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID677=null;

		Object ID677_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:823:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:823:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("set"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wSET", "Keyword_IdFollows(\"set\")");
			}
			ID677=(Token)match(input,ID,FOLLOW_ID_in_wSET9125); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID677);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 823:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:823:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wSET"


	public static class wCALL_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wCALL"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:825:1: wCALL :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wCALL_return wCALL() throws RecognitionException {
		MatlabParser.wCALL_return retval = new MatlabParser.wCALL_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID678=null;

		Object ID678_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:825:7: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:825:9: {...}? => ID
			{
			if ( !((Keyword_IdFollows("call"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wCALL", "Keyword_IdFollows(\"call\")");
			}
			ID678=(Token)match(input,ID,FOLLOW_ID_in_wCALL9146); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID678);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 825:43: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:825:46: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wCALL"


	public static class wEXECUTION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wEXECUTION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:827:1: wEXECUTION :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wEXECUTION_return wEXECUTION() throws RecognitionException {
		MatlabParser.wEXECUTION_return retval = new MatlabParser.wEXECUTION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID679=null;

		Object ID679_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:827:12: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:827:14: {...}? => ID
			{
			if ( !((Keyword_IdFollows("execution"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wEXECUTION", "Keyword_IdFollows(\"execution\")");
			}
			ID679=(Token)match(input,ID,FOLLOW_ID_in_wEXECUTION9167); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID679);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 827:53: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:827:56: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wEXECUTION"


	public static class wMAINEXECUTION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMAINEXECUTION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:829:1: wMAINEXECUTION :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wMAINEXECUTION_return wMAINEXECUTION() throws RecognitionException {
		MatlabParser.wMAINEXECUTION_return retval = new MatlabParser.wMAINEXECUTION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID680=null;

		Object ID680_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:829:16: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:829:18: {...}? => ID
			{
			if ( !((Keyword_IdFollows("mainexecution"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wMAINEXECUTION", "Keyword_IdFollows(\"mainexecution\")");
			}
			ID680=(Token)match(input,ID,FOLLOW_ID_in_wMAINEXECUTION9188); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID680);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 829:61: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:829:64: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMAINEXECUTION"


	public static class wLOOP_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLOOP"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:831:1: wLOOP :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wLOOP_return wLOOP() throws RecognitionException {
		MatlabParser.wLOOP_return retval = new MatlabParser.wLOOP_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID681=null;

		Object ID681_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:831:7: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:831:9: {...}? => ID
			{
			if ( !((Keyword_IdFollows("loop"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wLOOP", "Keyword_IdFollows(\"loop\")");
			}
			ID681=(Token)match(input,ID,FOLLOW_ID_in_wLOOP9209); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID681);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 831:43: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:831:46: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLOOP"


	public static class wLOOPBODY_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLOOPBODY"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:833:1: wLOOPBODY :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wLOOPBODY_return wLOOPBODY() throws RecognitionException {
		MatlabParser.wLOOPBODY_return retval = new MatlabParser.wLOOPBODY_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID682=null;

		Object ID682_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:833:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:833:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("loopbody"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wLOOPBODY", "Keyword_IdFollows(\"loopbody\")");
			}
			ID682=(Token)match(input,ID,FOLLOW_ID_in_wLOOPBODY9230); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID682);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 833:51: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:833:54: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLOOPBODY"


	public static class wLOOPHEAD_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLOOPHEAD"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:835:1: wLOOPHEAD :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wLOOPHEAD_return wLOOPHEAD() throws RecognitionException {
		MatlabParser.wLOOPHEAD_return retval = new MatlabParser.wLOOPHEAD_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID683=null;

		Object ID683_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:835:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:835:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("loophead"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wLOOPHEAD", "Keyword_IdFollows(\"loophead\")");
			}
			ID683=(Token)match(input,ID,FOLLOW_ID_in_wLOOPHEAD9251); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID683);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 835:51: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:835:54: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLOOPHEAD"


	public static class wANNOTATE_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wANNOTATE"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:837:1: wANNOTATE :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wANNOTATE_return wANNOTATE() throws RecognitionException {
		MatlabParser.wANNOTATE_return retval = new MatlabParser.wANNOTATE_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID684=null;

		Object ID684_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:837:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:837:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("annotate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wANNOTATE", "Keyword_IdFollows(\"annotate\")");
			}
			ID684=(Token)match(input,ID,FOLLOW_ID_in_wANNOTATE9272); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID684);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 837:51: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:837:54: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wANNOTATE"


	public static class wOPERATOR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wOPERATOR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:839:1: wOPERATOR :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wOPERATOR_return wOPERATOR() throws RecognitionException {
		MatlabParser.wOPERATOR_return retval = new MatlabParser.wOPERATOR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID685=null;

		Object ID685_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:839:11: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:839:13: {...}? => ID
			{
			if ( !((Keyword_IdFollows("op"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wOPERATOR", "Keyword_IdFollows(\"op\")");
			}
			ID685=(Token)match(input,ID,FOLLOW_ID_in_wOPERATOR9293); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID685);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 839:45: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:839:48: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wOPERATOR"


	public static class wWITHIN_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wWITHIN"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:841:1: wWITHIN :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wWITHIN_return wWITHIN() throws RecognitionException {
		MatlabParser.wWITHIN_return retval = new MatlabParser.wWITHIN_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID686=null;

		Object ID686_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:841:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:841:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("within"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wWITHIN", "Keyword_IdFollows(\"within\")");
			}
			ID686=(Token)match(input,ID,FOLLOW_ID_in_wWITHIN9314); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID686);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 841:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:841:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wWITHIN"


	public static class wDIMENSION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wDIMENSION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:843:1: wDIMENSION :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wDIMENSION_return wDIMENSION() throws RecognitionException {
		MatlabParser.wDIMENSION_return retval = new MatlabParser.wDIMENSION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID687=null;

		Object ID687_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:843:12: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:843:14: {...}? => ID
			{
			if ( !((Keyword_IdFollows("dimension"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wDIMENSION", "Keyword_IdFollows(\"dimension\")");
			}
			ID687=(Token)match(input,ID,FOLLOW_ID_in_wDIMENSION9335); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID687);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 843:53: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:843:56: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wDIMENSION"


	public static class wISTYPE_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wISTYPE"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:845:1: wISTYPE :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wISTYPE_return wISTYPE() throws RecognitionException {
		MatlabParser.wISTYPE_return retval = new MatlabParser.wISTYPE_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID688=null;

		Object ID688_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:845:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:845:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("istype"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wISTYPE", "Keyword_IdFollows(\"istype\")");
			}
			ID688=(Token)match(input,ID,FOLLOW_ID_in_wISTYPE9356); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID688);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 845:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:845:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wISTYPE"


	public static class wSTAR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wSTAR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:847:1: wSTAR : MTIMES -> ^( NAME[\"\"] ID[$MTIMES] ) ;
	public final MatlabParser.wSTAR_return wSTAR() throws RecognitionException {
		MatlabParser.wSTAR_return retval = new MatlabParser.wSTAR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MTIMES689=null;

		Object MTIMES689_tree=null;
		RewriteRuleTokenStream stream_MTIMES=new RewriteRuleTokenStream(adaptor,"token MTIMES");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:847:7: ( MTIMES -> ^( NAME[\"\"] ID[$MTIMES] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:847:9: MTIMES
			{
			MTIMES689=(Token)match(input,MTIMES,FOLLOW_MTIMES_in_wSTAR9374); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MTIMES.add(MTIMES689);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 847:16: -> ^( NAME[\"\"] ID[$MTIMES] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:847:19: ^( NAME[\"\"] ID[$MTIMES] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MTIMES689));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wSTAR"


	public static class wFUNCTION_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wFUNCTION"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:849:1: wFUNCTION : FUNCTION -> ^( NAME[\"\"] ID[$FUNCTION] ) ;
	public final MatlabParser.wFUNCTION_return wFUNCTION() throws RecognitionException {
		MatlabParser.wFUNCTION_return retval = new MatlabParser.wFUNCTION_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FUNCTION690=null;

		Object FUNCTION690_tree=null;
		RewriteRuleTokenStream stream_FUNCTION=new RewriteRuleTokenStream(adaptor,"token FUNCTION");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:849:11: ( FUNCTION -> ^( NAME[\"\"] ID[$FUNCTION] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:849:13: FUNCTION
			{
			FUNCTION690=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_wFUNCTION9393); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FUNCTION.add(FUNCTION690);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 849:22: -> ^( NAME[\"\"] ID[$FUNCTION] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:849:25: ^( NAME[\"\"] ID[$FUNCTION] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, FUNCTION690));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wFUNCTION"


	public static class wSCRIPT_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wSCRIPT"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:851:1: wSCRIPT :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wSCRIPT_return wSCRIPT() throws RecognitionException {
		MatlabParser.wSCRIPT_return retval = new MatlabParser.wSCRIPT_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID691=null;

		Object ID691_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:851:9: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:851:11: {...}? => ID
			{
			if ( !((Keyword_IdFollows("script"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wSCRIPT", "Keyword_IdFollows(\"script\")");
			}
			ID691=(Token)match(input,ID,FOLLOW_ID_in_wSCRIPT9415); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID691);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 851:47: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:851:50: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wSCRIPT"


	public static class wLOOPS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLOOPS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:853:1: wLOOPS :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wLOOPS_return wLOOPS() throws RecognitionException {
		MatlabParser.wLOOPS_return retval = new MatlabParser.wLOOPS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID692=null;

		Object ID692_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:853:8: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:853:10: {...}? => ID
			{
			if ( !((Keyword_IdFollows("loops"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wLOOPS", "Keyword_IdFollows(\"loops\")");
			}
			ID692=(Token)match(input,ID,FOLLOW_ID_in_wLOOPS9436); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID692);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 853:45: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:853:48: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLOOPS"


	public static class wCLASS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wCLASS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:855:1: wCLASS :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wCLASS_return wCLASS() throws RecognitionException {
		MatlabParser.wCLASS_return retval = new MatlabParser.wCLASS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID693=null;

		Object ID693_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:855:8: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:855:10: {...}? => ID
			{
			if ( !((Keyword_IdFollows("class"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wCLASS", "Keyword_IdFollows(\"class\")");
			}
			ID693=(Token)match(input,ID,FOLLOW_ID_in_wCLASS9457); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID693);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 855:45: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:855:48: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wCLASS"


	public static class wDOTDOT_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wDOTDOT"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:857:1: wDOTDOT : DOTDOT -> ^( NAME[\"\"] ID[$DOTDOT] ) ;
	public final MatlabParser.wDOTDOT_return wDOTDOT() throws RecognitionException {
		MatlabParser.wDOTDOT_return retval = new MatlabParser.wDOTDOT_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token DOTDOT694=null;

		Object DOTDOT694_tree=null;
		RewriteRuleTokenStream stream_DOTDOT=new RewriteRuleTokenStream(adaptor,"token DOTDOT");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:857:9: ( DOTDOT -> ^( NAME[\"\"] ID[$DOTDOT] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:857:11: DOTDOT
			{
			DOTDOT694=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_wDOTDOT9475); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_DOTDOT.add(DOTDOT694);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 857:18: -> ^( NAME[\"\"] ID[$DOTDOT] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:857:21: ^( NAME[\"\"] ID[$DOTDOT] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, DOTDOT694));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wDOTDOT"


	public static class wFOR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wFOR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:859:1: wFOR : FOR -> ^( NAME[\"\"] ID[$FOR] ) ;
	public final MatlabParser.wFOR_return wFOR() throws RecognitionException {
		MatlabParser.wFOR_return retval = new MatlabParser.wFOR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token FOR695=null;

		Object FOR695_tree=null;
		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,"token FOR");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:859:6: ( FOR -> ^( NAME[\"\"] ID[$FOR] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:859:8: FOR
			{
			FOR695=(Token)match(input,FOR,FOLLOW_FOR_in_wFOR9494); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_FOR.add(FOR695);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 859:13: -> ^( NAME[\"\"] ID[$FOR] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:859:16: ^( NAME[\"\"] ID[$FOR] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, FOR695));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wFOR"


	public static class wWHILE_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wWHILE"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:861:1: wWHILE : WHILE -> ^( NAME[\"\"] ID[$WHILE] ) ;
	public final MatlabParser.wWHILE_return wWHILE() throws RecognitionException {
		MatlabParser.wWHILE_return retval = new MatlabParser.wWHILE_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token WHILE696=null;

		Object WHILE696_tree=null;
		RewriteRuleTokenStream stream_WHILE=new RewriteRuleTokenStream(adaptor,"token WHILE");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:861:8: ( WHILE -> ^( NAME[\"\"] ID[$WHILE] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:861:10: WHILE
			{
			WHILE696=(Token)match(input,WHILE,FOLLOW_WHILE_in_wWHILE9514); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_WHILE.add(WHILE696);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 861:17: -> ^( NAME[\"\"] ID[$WHILE] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:861:20: ^( NAME[\"\"] ID[$WHILE] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, WHILE696));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wWHILE"


	public static class wPLUS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wPLUS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:863:1: wPLUS : PLUS -> ^( NAME[\"\"] ID[$PLUS] ) ;
	public final MatlabParser.wPLUS_return wPLUS() throws RecognitionException {
		MatlabParser.wPLUS_return retval = new MatlabParser.wPLUS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLUS697=null;

		Object PLUS697_tree=null;
		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,"token PLUS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:863:7: ( PLUS -> ^( NAME[\"\"] ID[$PLUS] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:863:9: PLUS
			{
			PLUS697=(Token)match(input,PLUS,FOLLOW_PLUS_in_wPLUS9534); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PLUS.add(PLUS697);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 863:14: -> ^( NAME[\"\"] ID[$PLUS] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:863:17: ^( NAME[\"\"] ID[$PLUS] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, PLUS697));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wPLUS"


	public static class wMINUS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMINUS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:865:1: wMINUS : MINUS -> ^( NAME[\"\"] ID[$MINUS] ) ;
	public final MatlabParser.wMINUS_return wMINUS() throws RecognitionException {
		MatlabParser.wMINUS_return retval = new MatlabParser.wMINUS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MINUS698=null;

		Object MINUS698_tree=null;
		RewriteRuleTokenStream stream_MINUS=new RewriteRuleTokenStream(adaptor,"token MINUS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:865:8: ( MINUS -> ^( NAME[\"\"] ID[$MINUS] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:865:10: MINUS
			{
			MINUS698=(Token)match(input,MINUS,FOLLOW_MINUS_in_wMINUS9553); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MINUS.add(MINUS698);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 865:16: -> ^( NAME[\"\"] ID[$MINUS] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:865:19: ^( NAME[\"\"] ID[$MINUS] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MINUS698));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMINUS"


	public static class wMTIMES_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMTIMES"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:867:1: wMTIMES : MTIMES -> ^( NAME[\"\"] ID[$MTIMES] ) ;
	public final MatlabParser.wMTIMES_return wMTIMES() throws RecognitionException {
		MatlabParser.wMTIMES_return retval = new MatlabParser.wMTIMES_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MTIMES699=null;

		Object MTIMES699_tree=null;
		RewriteRuleTokenStream stream_MTIMES=new RewriteRuleTokenStream(adaptor,"token MTIMES");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:867:9: ( MTIMES -> ^( NAME[\"\"] ID[$MTIMES] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:867:11: MTIMES
			{
			MTIMES699=(Token)match(input,MTIMES,FOLLOW_MTIMES_in_wMTIMES9572); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MTIMES.add(MTIMES699);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 867:18: -> ^( NAME[\"\"] ID[$MTIMES] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:867:21: ^( NAME[\"\"] ID[$MTIMES] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MTIMES699));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMTIMES"


	public static class wTIMES_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wTIMES"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:869:1: wTIMES : TIMES -> ^( NAME[\"\"] ID[$TIMES] ) ;
	public final MatlabParser.wTIMES_return wTIMES() throws RecognitionException {
		MatlabParser.wTIMES_return retval = new MatlabParser.wTIMES_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TIMES700=null;

		Object TIMES700_tree=null;
		RewriteRuleTokenStream stream_TIMES=new RewriteRuleTokenStream(adaptor,"token TIMES");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:869:8: ( TIMES -> ^( NAME[\"\"] ID[$TIMES] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:869:10: TIMES
			{
			TIMES700=(Token)match(input,TIMES,FOLLOW_TIMES_in_wTIMES9591); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TIMES.add(TIMES700);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 869:16: -> ^( NAME[\"\"] ID[$TIMES] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:869:19: ^( NAME[\"\"] ID[$TIMES] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, TIMES700));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wTIMES"


	public static class wMRDIV_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMRDIV"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:871:1: wMRDIV : MRDIV -> ^( NAME[\"\"] ID[$MRDIV] ) ;
	public final MatlabParser.wMRDIV_return wMRDIV() throws RecognitionException {
		MatlabParser.wMRDIV_return retval = new MatlabParser.wMRDIV_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MRDIV701=null;

		Object MRDIV701_tree=null;
		RewriteRuleTokenStream stream_MRDIV=new RewriteRuleTokenStream(adaptor,"token MRDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:871:8: ( MRDIV -> ^( NAME[\"\"] ID[$MRDIV] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:871:10: MRDIV
			{
			MRDIV701=(Token)match(input,MRDIV,FOLLOW_MRDIV_in_wMRDIV9610); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MRDIV.add(MRDIV701);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 871:16: -> ^( NAME[\"\"] ID[$MRDIV] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:871:19: ^( NAME[\"\"] ID[$MRDIV] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MRDIV701));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMRDIV"


	public static class wRDIV_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wRDIV"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:873:1: wRDIV : RDIV -> ^( NAME[\"\"] ID[$RDIV] ) ;
	public final MatlabParser.wRDIV_return wRDIV() throws RecognitionException {
		MatlabParser.wRDIV_return retval = new MatlabParser.wRDIV_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token RDIV702=null;

		Object RDIV702_tree=null;
		RewriteRuleTokenStream stream_RDIV=new RewriteRuleTokenStream(adaptor,"token RDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:873:7: ( RDIV -> ^( NAME[\"\"] ID[$RDIV] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:873:9: RDIV
			{
			RDIV702=(Token)match(input,RDIV,FOLLOW_RDIV_in_wRDIV9629); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RDIV.add(RDIV702);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 873:14: -> ^( NAME[\"\"] ID[$RDIV] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:873:17: ^( NAME[\"\"] ID[$RDIV] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, RDIV702));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wRDIV"


	public static class wMLDIV_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMLDIV"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:875:1: wMLDIV : MLDIV -> ^( NAME[\"\"] ID[$MLDIV] ) ;
	public final MatlabParser.wMLDIV_return wMLDIV() throws RecognitionException {
		MatlabParser.wMLDIV_return retval = new MatlabParser.wMLDIV_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MLDIV703=null;

		Object MLDIV703_tree=null;
		RewriteRuleTokenStream stream_MLDIV=new RewriteRuleTokenStream(adaptor,"token MLDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:875:8: ( MLDIV -> ^( NAME[\"\"] ID[$MLDIV] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:875:10: MLDIV
			{
			MLDIV703=(Token)match(input,MLDIV,FOLLOW_MLDIV_in_wMLDIV9648); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MLDIV.add(MLDIV703);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 875:16: -> ^( NAME[\"\"] ID[$MLDIV] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:875:19: ^( NAME[\"\"] ID[$MLDIV] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MLDIV703));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMLDIV"


	public static class wLDIV_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wLDIV"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:877:1: wLDIV : LDIV -> ^( NAME[\"\"] ID[$LDIV] ) ;
	public final MatlabParser.wLDIV_return wLDIV() throws RecognitionException {
		MatlabParser.wLDIV_return retval = new MatlabParser.wLDIV_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LDIV704=null;

		Object LDIV704_tree=null;
		RewriteRuleTokenStream stream_LDIV=new RewriteRuleTokenStream(adaptor,"token LDIV");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:877:7: ( LDIV -> ^( NAME[\"\"] ID[$LDIV] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:877:9: LDIV
			{
			LDIV704=(Token)match(input,LDIV,FOLLOW_LDIV_in_wLDIV9667); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LDIV.add(LDIV704);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 877:14: -> ^( NAME[\"\"] ID[$LDIV] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:877:17: ^( NAME[\"\"] ID[$LDIV] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, LDIV704));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wLDIV"


	public static class wMPOW_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wMPOW"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:879:1: wMPOW : MPOW -> ^( NAME[\"\"] ID[$MPOW] ) ;
	public final MatlabParser.wMPOW_return wMPOW() throws RecognitionException {
		MatlabParser.wMPOW_return retval = new MatlabParser.wMPOW_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MPOW705=null;

		Object MPOW705_tree=null;
		RewriteRuleTokenStream stream_MPOW=new RewriteRuleTokenStream(adaptor,"token MPOW");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:879:7: ( MPOW -> ^( NAME[\"\"] ID[$MPOW] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:879:9: MPOW
			{
			MPOW705=(Token)match(input,MPOW,FOLLOW_MPOW_in_wMPOW9686); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_MPOW.add(MPOW705);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 879:14: -> ^( NAME[\"\"] ID[$MPOW] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:879:17: ^( NAME[\"\"] ID[$MPOW] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, MPOW705));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wMPOW"


	public static class wPOW_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wPOW"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:881:1: wPOW : POW -> ^( NAME[\"\"] ID[$POW] ) ;
	public final MatlabParser.wPOW_return wPOW() throws RecognitionException {
		MatlabParser.wPOW_return retval = new MatlabParser.wPOW_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token POW706=null;

		Object POW706_tree=null;
		RewriteRuleTokenStream stream_POW=new RewriteRuleTokenStream(adaptor,"token POW");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:881:6: ( POW -> ^( NAME[\"\"] ID[$POW] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:881:8: POW
			{
			POW706=(Token)match(input,POW,FOLLOW_POW_in_wPOW9705); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_POW.add(POW706);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 881:12: -> ^( NAME[\"\"] ID[$POW] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:881:15: ^( NAME[\"\"] ID[$POW] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, POW706));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wPOW"


	public static class wTRANS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wTRANS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:883:1: wTRANS : TRANS -> ^( NAME[\"\"] ID[$TRANS] ) ;
	public final MatlabParser.wTRANS_return wTRANS() throws RecognitionException {
		MatlabParser.wTRANS_return retval = new MatlabParser.wTRANS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token TRANS707=null;

		Object TRANS707_tree=null;
		RewriteRuleTokenStream stream_TRANS=new RewriteRuleTokenStream(adaptor,"token TRANS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:883:8: ( TRANS -> ^( NAME[\"\"] ID[$TRANS] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:883:10: TRANS
			{
			TRANS707=(Token)match(input,TRANS,FOLLOW_TRANS_in_wTRANS9724); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_TRANS.add(TRANS707);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 883:16: -> ^( NAME[\"\"] ID[$TRANS] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:883:19: ^( NAME[\"\"] ID[$TRANS] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, TRANS707));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wTRANS"


	public static class wCTRANS_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wCTRANS"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:885:1: wCTRANS : CTRANS -> ^( NAME[\"\"] ID[$CTRANS] ) ;
	public final MatlabParser.wCTRANS_return wCTRANS() throws RecognitionException {
		MatlabParser.wCTRANS_return retval = new MatlabParser.wCTRANS_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token CTRANS708=null;

		Object CTRANS708_tree=null;
		RewriteRuleTokenStream stream_CTRANS=new RewriteRuleTokenStream(adaptor,"token CTRANS");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:885:9: ( CTRANS -> ^( NAME[\"\"] ID[$CTRANS] ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:885:11: CTRANS
			{
			CTRANS708=(Token)match(input,CTRANS,FOLLOW_CTRANS_in_wCTRANS9743); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_CTRANS.add(CTRANS708);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 885:18: -> ^( NAME[\"\"] ID[$CTRANS] )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:885:21: ^( NAME[\"\"] ID[$CTRANS] )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, (Object)adaptor.create(ID, CTRANS708));
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wCTRANS"


	public static class wVAR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wVAR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:887:1: wVAR :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wVAR_return wVAR() throws RecognitionException {
		MatlabParser.wVAR_return retval = new MatlabParser.wVAR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID709=null;

		Object ID709_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:887:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:887:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("var"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wVAR", "Keyword_IdFollows(\"var\")");
			}
			ID709=(Token)match(input,ID,FOLLOW_ID_in_wVAR9765); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID709);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 887:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:887:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wVAR"


	public static class wSTR_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wSTR"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:889:1: wSTR :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wSTR_return wSTR() throws RecognitionException {
		MatlabParser.wSTR_return retval = new MatlabParser.wSTR_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID710=null;

		Object ID710_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:889:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:889:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("str"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wSTR", "Keyword_IdFollows(\"str\")");
			}
			ID710=(Token)match(input,ID,FOLLOW_ID_in_wSTR9786); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID710);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 889:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:889:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wSTR"


	public static class wNUM_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wNUM"
	// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:891:1: wNUM :{...}? => ID -> ^( NAME[\"\"] ID ) ;
	public final MatlabParser.wNUM_return wNUM() throws RecognitionException {
		MatlabParser.wNUM_return retval = new MatlabParser.wNUM_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ID711=null;

		Object ID711_tree=null;
		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,"token ID");

		try {
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:891:6: ({...}? => ID -> ^( NAME[\"\"] ID ) )
			// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:891:8: {...}? => ID
			{
			if ( !((Keyword_IdFollows("num"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wNUM", "Keyword_IdFollows(\"num\")");
			}
			ID711=(Token)match(input,ID,FOLLOW_ID_in_wNUM9807); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_ID.add(ID711);

			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 891:41: -> ^( NAME[\"\"] ID )
			{
				// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:891:44: ^( NAME[\"\"] ID )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NAME, ""), root_1);
				adaptor.addChild(root_1, stream_ID.nextNode());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wNUM"

	// $ANTLR start synpred1_MatlabParser
	public final void synpred1_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:16: ( openFunctionFile )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:71:17: openFunctionFile
		{
		pushFollow(FOLLOW_openFunctionFile_in_synpred1_MatlabParser487);
		openFunctionFile();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred1_MatlabParser

	// $ANTLR start synpred2_MatlabParser
	public final void synpred2_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:13: ( assignment )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:229:14: assignment
		{
		pushFollow(FOLLOW_assignment_in_synpred2_MatlabParser2193);
		assignment();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred2_MatlabParser

	// $ANTLR start synpred3_MatlabParser
	public final void synpred3_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:230:13: ( action )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:230:14: action
		{
		pushFollow(FOLLOW_action_in_synpred3_MatlabParser2216);
		action();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred3_MatlabParser

	// $ANTLR start synpred4_MatlabParser
	public final void synpred4_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:231:7: ( simpleCommand )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:231:8: simpleCommand
		{
		pushFollow(FOLLOW_simpleCommand_in_synpred4_MatlabParser2233);
		simpleCommand();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred4_MatlabParser

	// $ANTLR start synpred5_MatlabParser
	public final void synpred5_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:232:7: ( abortCommand )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:232:8: abortCommand
		{
		pushFollow(FOLLOW_abortCommand_in_synpred5_MatlabParser2250);
		abortCommand();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred5_MatlabParser

	// $ANTLR start synpred6_MatlabParser
	public final void synpred6_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:14: ( LPAREN var ASSIGN expression COMMA )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:347:15: LPAREN var ASSIGN expression COMMA
		{
		match(input,LPAREN,FOLLOW_LPAREN_in_synpred6_MatlabParser3422); if (state.failed) return;

		pushFollow(FOLLOW_var_in_synpred6_MatlabParser3424);
		var();
		state._fsp--;
		if (state.failed) return;

		match(input,ASSIGN,FOLLOW_ASSIGN_in_synpred6_MatlabParser3426); if (state.failed) return;

		pushFollow(FOLLOW_expression_in_synpred6_MatlabParser3428);
		expression();
		state._fsp--;
		if (state.failed) return;

		match(input,COMMA,FOLLOW_COMMA_in_synpred6_MatlabParser3430); if (state.failed) return;

		}

	}
	// $ANTLR end synpred6_MatlabParser

	// $ANTLR start synpred7_MatlabParser
	public final void synpred7_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:5: ( DOT LPAREN )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:476:6: DOT LPAREN
		{
		match(input,DOT,FOLLOW_DOT_in_synpred7_MatlabParser4955); if (state.failed) return;

		match(input,LPAREN,FOLLOW_LPAREN_in_synpred7_MatlabParser4957); if (state.failed) return;

		}

	}
	// $ANTLR end synpred7_MatlabParser

	// $ANTLR start synpred8_MatlabParser
	public final void synpred8_MatlabParser_fragment() throws RecognitionException {
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:10: ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )
		// D:\\!USERS\\SAMUEL\\DOCUMENTS\\IdeaProjects\\MatlabParser\\src\\Matlab\\Recognizer\\MatlabParser.g3:545:11: NOT ( COMMA | SEMICOLON | EOL | RSQUARE )
		{
		match(input,NOT,FOLLOW_NOT_in_synpred8_MatlabParser5508); if (state.failed) return;

		if ( input.LA(1)==COMMA||input.LA(1)==EOL||(input.LA(1) >= RSQUARE && input.LA(1) <= SEMICOLON) ) {
			input.consume();
			state.errorRecovery=false;
			state.failed=false;
		}
		else {
			if (state.backtracking>0) {state.failed=true; return;}
			MismatchedSetException mse = new MismatchedSetException(null,input);
			throw mse;
		}
		}

	}
	// $ANTLR end synpred8_MatlabParser

	// Delegated rules

	public final boolean synpred5_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred5_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred4_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred4_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred6_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred6_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred2_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred2_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred3_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred3_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred8_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred8_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred7_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred7_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred1_MatlabParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred1_MatlabParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}


	protected DFA1 dfa1 = new DFA1(this);
	protected DFA22 dfa22 = new DFA22(this);
	protected DFA51 dfa51 = new DFA51(this);
	protected DFA101 dfa101 = new DFA101(this);
	protected DFA130 dfa130 = new DFA130(this);
	static final String DFA1_eotS =
		"\12\uffff";
	static final String DFA1_eofS =
		"\1\5\5\uffff\1\5\3\uffff";
	static final String DFA1_minS =
		"\1\5\5\uffff\1\5\3\uffff";
	static final String DFA1_maxS =
		"\1\137\5\uffff\1\137\3\uffff";
	static final String DFA1_acceptS =
		"\1\uffff\5\1\1\uffff\1\2\1\3\1\4";
	static final String DFA1_specialS =
		"\1\0\11\uffff}>";
	static final String[] DFA1_transitionS = {
			"\1\11\1\uffff\1\4\2\uffff\1\5\2\uffff\1\10\1\uffff\2\5\1\uffff\1\5\15"+
			"\uffff\1\3\1\6\1\uffff\1\5\1\uffff\1\5\1\7\1\5\2\uffff\1\1\1\5\1\2\1"+
			"\uffff\1\2\7\uffff\2\2\2\uffff\1\2\4\uffff\1\2\4\uffff\2\5\1\2\2\uffff"+
			"\1\4\3\uffff\1\2\1\5\2\uffff\1\5\4\uffff\1\5\1\uffff\1\2\1\uffff\1\5"+
			"\2\uffff\1\5\1\uffff\1\5",
			"",
			"",
			"",
			"",
			"",
			"\1\11\1\uffff\1\5\2\uffff\1\5\2\uffff\1\10\1\uffff\2\5\1\uffff\1\5\15"+
			"\uffff\1\5\1\6\1\uffff\1\5\1\uffff\1\5\1\7\1\5\2\uffff\3\5\1\uffff\1"+
			"\5\7\uffff\2\5\2\uffff\1\5\4\uffff\1\5\4\uffff\3\5\2\uffff\1\5\3\uffff"+
			"\2\5\2\uffff\1\5\4\uffff\1\5\1\uffff\1\5\1\uffff\1\5\2\uffff\1\5\1\uffff"+
			"\1\5",
			"",
			"",
			""
	};

	static final short[] DFA1_eot = DFA.unpackEncodedString(DFA1_eotS);
	static final short[] DFA1_eof = DFA.unpackEncodedString(DFA1_eofS);
	static final char[] DFA1_min = DFA.unpackEncodedStringToUnsignedChars(DFA1_minS);
	static final char[] DFA1_max = DFA.unpackEncodedStringToUnsignedChars(DFA1_maxS);
	static final short[] DFA1_accept = DFA.unpackEncodedString(DFA1_acceptS);
	static final short[] DFA1_special = DFA.unpackEncodedString(DFA1_specialS);
	static final short[][] DFA1_transition;

	static {
		int numStates = DFA1_transitionS.length;
		DFA1_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA1_transition[i] = DFA.unpackEncodedString(DFA1_transitionS[i]);
		}
	}

	protected class DFA1 extends DFA {

		public DFA1(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 1;
			this.eot = DFA1_eot;
			this.eof = DFA1_eof;
			this.min = DFA1_min;
			this.max = DFA1_max;
			this.accept = DFA1_accept;
			this.special = DFA1_special;
			this.transition = DFA1_transition;
		}
		@Override
		public String getDescription() {
			return "57:8: public file : ( scriptFile -> scriptFile | functionFile -> functionFile | classFile -> classFile | aspectFile -> aspectFile );";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA1_0 = input.LA(1);
						 
						int index1_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA1_0==ID) && (((Command_IsEnabled())||(True())))) {s = 1;}
						else if ( (LA1_0==IMAGINARY||LA1_0==LCURLY||(LA1_0 >= LPAREN && LA1_0 <= LSQUARE)||LA1_0==MINUS||LA1_0==NOT||LA1_0==PLUS||LA1_0==REAL||LA1_0==STRING) && ((True()))) {s = 2;}
						else if ( (LA1_0==END) && (((Index_IsActive())&&(True())))) {s = 3;}
						else if ( (LA1_0==AT||LA1_0==QUESTION) && ((True()))) {s = 4;}
						else if ( (LA1_0==EOF||LA1_0==BREAK||(LA1_0 >= COMMA && LA1_0 <= COMMAND)||LA1_0==CONTINUE||LA1_0==EXCLAMATION||LA1_0==FOR||LA1_0==GLOBAL||LA1_0==IF||(LA1_0 >= PARFOR && LA1_0 <= PERSISTENT)||LA1_0==RETURN||LA1_0==SEMICOLON||LA1_0==SPMD||LA1_0==SWITCH||LA1_0==TRY||LA1_0==WHILE) ) {s = 5;}
						else if ( (LA1_0==EOL) ) {s = 6;}
						else if ( (LA1_0==FUNCTION) ) {s = 7;}
						else if ( (LA1_0==CLASSDEF) ) {s = 8;}
						else if ( (LA1_0==ASPECT) ) {s = 9;}
						 
						input.seek(index1_0);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 1, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA22_eotS =
		"\4\uffff";
	static final String DFA22_eofS =
		"\2\2\2\uffff";
	static final String DFA22_minS =
		"\2\41\2\uffff";
	static final String DFA22_maxS =
		"\2\46\2\uffff";
	static final String DFA22_acceptS =
		"\2\uffff\1\2\1\1";
	static final String DFA22_specialS =
		"\4\uffff}>";
	static final String[] DFA22_transitionS = {
			"\1\1\4\uffff\1\3",
			"\1\1\4\uffff\1\3",
			"",
			""
	};

	static final short[] DFA22_eot = DFA.unpackEncodedString(DFA22_eotS);
	static final short[] DFA22_eof = DFA.unpackEncodedString(DFA22_eofS);
	static final char[] DFA22_min = DFA.unpackEncodedStringToUnsignedChars(DFA22_minS);
	static final char[] DFA22_max = DFA.unpackEncodedStringToUnsignedChars(DFA22_maxS);
	static final short[] DFA22_accept = DFA.unpackEncodedString(DFA22_acceptS);
	static final short[] DFA22_special = DFA.unpackEncodedString(DFA22_specialS);
	static final short[][] DFA22_transition;

	static {
		int numStates = DFA22_transitionS.length;
		DFA22_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA22_transition[i] = DFA.unpackEncodedString(DFA22_transitionS[i]);
		}
	}

	protected class DFA22 extends DFA {

		public DFA22(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 22;
			this.eot = DFA22_eot;
			this.eof = DFA22_eof;
			this.min = DFA22_min;
			this.max = DFA22_max;
			this.accept = DFA22_accept;
			this.special = DFA22_special;
			this.transition = DFA22_transition;
		}
		@Override
		public String getDescription() {
			return "()* loopback of 123:32: ( ( EOL )* closeFunction )*";
		}
	}

	static final String DFA51_eotS =
		"\75\uffff";
	static final String DFA51_eofS =
		"\75\uffff";
	static final String DFA51_minS =
		"\1\52\1\6\1\52\1\40\2\uffff\1\7\1\6\1\17\1\uffff\2\52\1\7\1\40\1\17\1"+
		"\52\1\12\26\17\1\12\25\17";
	static final String DFA51_maxS =
		"\1\67\1\121\1\120\1\52\2\uffff\1\120\1\6\1\121\1\uffff\2\52\1\120\1\52"+
		"\1\120\1\52\1\137\26\120\1\137\25\120";
	static final String DFA51_acceptS =
		"\4\uffff\1\1\1\3\3\uffff\1\2\63\uffff";
	static final String DFA51_specialS =
		"\75\uffff}>";
	static final String[] DFA51_transitionS = {
			"\1\1\14\uffff\1\2",
			"\1\3\10\uffff\1\5\13\uffff\1\4\4\uffff\2\5\24\uffff\1\5\32\uffff\1\5",
			"\1\6\45\uffff\1\7",
			"\1\11\11\uffff\1\10",
			"",
			"",
			"\1\12\7\uffff\1\13\32\uffff\1\14\45\uffff\1\7",
			"\1\15",
			"\1\11\13\uffff\1\4\4\uffff\2\11\24\uffff\1\11\32\uffff\1\11",
			"",
			"\1\16",
			"\1\14",
			"\1\17\7\uffff\1\13\32\uffff\1\14\45\uffff\1\7",
			"\1\11\11\uffff\1\10",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\21",
			"\1\23\1\24\1\25\1\26\4\uffff\1\27\13\uffff\1\30\1\31\1\32\4\uffff\1"+
			"\33\1\34\1\35\2\uffff\1\22\1\36\27\uffff\1\37\1\40\1\41\10\uffff\1\42"+
			"\7\uffff\1\43\3\uffff\1\44\2\uffff\1\45\1\uffff\1\46",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\20\16\uffff\1\14\45\uffff\1\7",
			"\1\51\1\52\1\53\1\54\4\uffff\1\55\13\uffff\1\56\1\57\1\60\4\uffff\1"+
			"\61\1\62\1\63\2\uffff\1\50\1\64\27\uffff\1\65\1\66\1\67\10\uffff\1\70"+
			"\7\uffff\1\71\3\uffff\1\72\2\uffff\1\73\1\uffff\1\74",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7",
			"\1\13\13\uffff\1\47\16\uffff\1\14\45\uffff\1\7"
	};

	static final short[] DFA51_eot = DFA.unpackEncodedString(DFA51_eotS);
	static final short[] DFA51_eof = DFA.unpackEncodedString(DFA51_eofS);
	static final char[] DFA51_min = DFA.unpackEncodedStringToUnsignedChars(DFA51_minS);
	static final char[] DFA51_max = DFA.unpackEncodedStringToUnsignedChars(DFA51_maxS);
	static final short[] DFA51_accept = DFA.unpackEncodedString(DFA51_acceptS);
	static final short[] DFA51_special = DFA.unpackEncodedString(DFA51_specialS);
	static final short[][] DFA51_transition;

	static {
		int numStates = DFA51_transitionS.length;
		DFA51_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA51_transition[i] = DFA.unpackEncodedString(DFA51_transitionS[i]);
		}
	}

	protected class DFA51 extends DFA {

		public DFA51(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 51;
			this.eot = DFA51_eot;
			this.eof = DFA51_eof;
			this.min = DFA51_min;
			this.max = DFA51_max;
			this.accept = DFA51_accept;
			this.special = DFA51_special;
			this.transition = DFA51_transition;
		}
		@Override
		public String getDescription() {
			return "196:1: methodSignature : ( ( outputPortion )? methodName1 ( inputPortion )? -> ( outputPortion )? methodName1 ( inputPortion )? | outputPortion methodName2 ( inputPortion )? -> ( outputPortion )? methodName2 ( inputPortion )? | methodName3 ( inputPortion )? -> methodName3 ( inputPortion )? );";
		}
	}

	static final String DFA101_eotS =
		"\102\uffff";
	static final String DFA101_eofS =
		"\102\uffff";
	static final String DFA101_minS =
		"\1\4\45\uffff\3\0\23\uffff\1\0\5\uffff";
	static final String DFA101_maxS =
		"\1\137\45\uffff\3\0\23\uffff\1\0\5\uffff";
	static final String DFA101_acceptS =
		"\1\uffff\1\6\2\uffff\1\6\1\uffff\1\6\12\uffff\1\6\1\uffff\1\6\16\uffff"+
		"\1\6\6\uffff\1\6\23\uffff\1\4\1\3\1\5\1\1\1\2";
	static final String DFA101_specialS =
		"\1\0\45\uffff\1\1\1\2\1\3\23\uffff\1\4\5\uffff}>";
	static final String[] DFA101_transitionS = {
			"\1\23\1\uffff\1\1\1\50\2\uffff\2\51\2\uffff\1\23\1\1\1\51\1\uffff\1\51"+
			"\1\6\7\uffff\1\74\2\uffff\2\51\3\23\1\51\1\uffff\1\51\1\uffff\1\51\2"+
			"\23\1\1\1\51\1\42\1\uffff\1\46\1\6\6\uffff\1\47\1\42\2\23\1\21\4\6\1"+
			"\4\1\23\1\uffff\1\23\3\51\1\21\1\uffff\1\6\1\4\1\uffff\1\51\1\6\1\42"+
			"\1\51\1\23\1\6\3\23\2\uffff\1\51\1\uffff\1\42\1\uffff\1\51\2\6\1\51\1"+
			"\uffff\1\51",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\uffff",
			"\1\uffff",
			"\1\uffff",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\uffff",
			"",
			"",
			"",
			"",
			""
	};

	static final short[] DFA101_eot = DFA.unpackEncodedString(DFA101_eotS);
	static final short[] DFA101_eof = DFA.unpackEncodedString(DFA101_eofS);
	static final char[] DFA101_min = DFA.unpackEncodedStringToUnsignedChars(DFA101_minS);
	static final char[] DFA101_max = DFA.unpackEncodedStringToUnsignedChars(DFA101_maxS);
	static final short[] DFA101_accept = DFA.unpackEncodedString(DFA101_acceptS);
	static final short[] DFA101_special = DFA.unpackEncodedString(DFA101_specialS);
	static final short[][] DFA101_transition;

	static {
		int numStates = DFA101_transitionS.length;
		DFA101_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA101_transition[i] = DFA.unpackEncodedString(DFA101_transitionS[i]);
		}
	}

	protected class DFA101 extends DFA {

		public DFA101(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 101;
			this.eot = DFA101_eot;
			this.eof = DFA101_eof;
			this.min = DFA101_min;
			this.max = DFA101_max;
			this.accept = DFA101_accept;
			this.special = DFA101_special;
			this.transition = DFA101_transition;
		}
		@Override
		public String getDescription() {
			return "()* loopback of 476:5: ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )*";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA101_0 = input.LA(1);
						 
						int index101_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA101_0==ASSIGN||LA101_0==COMMA||LA101_0==ID) ) {s = 1;}
						else if ( (LA101_0==NOT||LA101_0==QUESTION) && (((Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 4;}
						else if ( (LA101_0==CTRANS||LA101_0==LDIV||(LA101_0 >= MLDIV && LA101_0 <= MTIMES)||LA101_0==POW||LA101_0==RDIV||LA101_0==RSQUARE||(LA101_0 >= TIMES && LA101_0 <= TRANS)) ) {s = 6;}
						else if ( (LA101_0==MINUS||LA101_0==PLUS) && (((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 17;}
						else if ( (LA101_0==AND||LA101_0==COLON||(LA101_0 >= END && LA101_0 <= EQ)||(LA101_0 >= GT && LA101_0 <= GTEQ)||(LA101_0 >= LT && LA101_0 <= LTEQ)||LA101_0==NOTEQ||LA101_0==OR||LA101_0==RPAREN||(LA101_0 >= SEMICOLON && LA101_0 <= SHORTOR)) ) {s = 19;}
						else if ( (LA101_0==IMAGINARY||LA101_0==LSQUARE||LA101_0==REAL||LA101_0==STRING) && (((Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 34;}
						else if ( (LA101_0==LCURLY) && ((((Chain_MayAddCurlyBrace())&&(!Balance_InCreationOrStore_SpacesOnLeft()))||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 38;}
						else if ( (LA101_0==LPAREN) && ((((!Balance_InCreationOrStore_SpacesOnLeft())&&(Chain_MayAddParenthesis()))||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 39;}
						else if ( (LA101_0==AT) && ((((!Balance_InCreationOrStore_SpacesOnLeft())&&(Chain_MayAddAtBase()))||(Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 40;}
						else if ( ((LA101_0 >= BREAK && LA101_0 <= CASE)||LA101_0==COMMAND||LA101_0==CONTINUE||(LA101_0 >= ELSE && LA101_0 <= ELSEIF)||LA101_0==EXCLAMATION||LA101_0==FOR||LA101_0==GLOBAL||LA101_0==IF||(LA101_0 >= OTHERWISE && LA101_0 <= PERSISTENT)||LA101_0==RCURLY||LA101_0==RETURN||LA101_0==SPMD||LA101_0==SWITCH||LA101_0==TRY||LA101_0==WHILE) ) {s = 41;}
						else if ( (LA101_0==DOT) && ((Chain_MayAddDotName()))) {s = 60;}
						 
						input.seek(index101_0);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA101_38 = input.LA(1);
						 
						int index101_38 = input.index();
						input.rewind();
						s = -1;
						if ( (((Chain_MayAddCurlyBrace())&&(!Balance_InCreationOrStore_SpacesOnLeft()))) ) {s = 61;}
						else if ( (((Separator_CommaFollowsOrSpacesPrecede())||(True()))) ) {s = 41;}
						 
						input.seek(index101_38);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA101_39 = input.LA(1);
						 
						int index101_39 = input.index();
						input.rewind();
						s = -1;
						if ( (((!Balance_InCreationOrStore_SpacesOnLeft())&&(Chain_MayAddParenthesis()))) ) {s = 62;}
						else if ( (((Separator_CommaFollowsOrSpacesPrecede())||(True()))) ) {s = 41;}
						 
						input.seek(index101_39);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA101_40 = input.LA(1);
						 
						int index101_40 = input.index();
						input.rewind();
						s = -1;
						if ( (((!Balance_InCreationOrStore_SpacesOnLeft())&&(Chain_MayAddAtBase()))) ) {s = 63;}
						else if ( (((Separator_CommaFollowsOrSpacesPrecede())||(True()))) ) {s = 41;}
						 
						input.seek(index101_40);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA101_60 = input.LA(1);
						 
						int index101_60 = input.index();
						input.rewind();
						s = -1;
						if ( (((Chain_MayAddDotExpression())&&synpred7_MatlabParser())) ) {s = 64;}
						else if ( ((Chain_MayAddDotName())) ) {s = 65;}
						 
						input.seek(index101_60);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 101, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA130_eotS =
		"\u00be\uffff";
	static final String DFA130_eofS =
		"\u00be\uffff";
	static final String DFA130_minS =
		"\1\52\1\uffff\1\4\1\uffff\1\23\1\uffff\5\16\3\uffff\1\34\1\0\2\34\1\0"+
		"\2\34\3\67\1\34\6\uffff\3\17\1\34\1\16\3\17\1\34\3\67\3\117\1\0\1\34\3"+
		"\17\1\117\2\34\4\17\1\uffff\1\0\1\34\1\0\1\34\4\17\2\0\3\17\1\117\1\34"+
		"\1\0\3\17\1\34\4\17\1\34\1\17\1\34\2\uffff\3\17\1\34\1\0\4\17\1\34\1\0"+
		"\1\34\3\17\1\34\4\17\2\34\1\16\5\17\2\34\4\17\1\34\12\17\1\34\1\17\1\34"+
		"\6\17\1\34\3\17\1\34\4\17\1\34\3\17\1\34\7\17\1\34\4\17\1\34\12\17\1\34"+
		"\3\17\1\34\6\17";
	static final String DFA130_maxS =
		"\1\66\1\uffff\1\121\1\uffff\1\137\1\uffff\3\117\2\16\3\uffff\1\76\1\0"+
		"\1\117\1\76\1\0\2\76\3\117\1\120\6\uffff\3\117\1\120\4\117\1\120\6\117"+
		"\1\0\4\120\1\117\1\76\4\120\1\117\1\uffff\1\0\1\117\1\0\4\120\1\117\2"+
		"\0\3\120\1\117\1\115\1\0\3\117\4\120\1\117\1\115\1\117\1\115\2\uffff\3"+
		"\117\1\120\1\0\3\120\1\117\1\115\1\0\1\115\7\120\1\117\1\115\1\76\1\117"+
		"\5\120\1\76\4\120\1\117\1\115\11\120\1\117\1\115\1\117\1\115\3\120\3\117"+
		"\1\120\3\117\4\120\1\117\1\115\3\120\1\115\13\120\1\117\1\115\11\120\1"+
		"\117\1\115\3\120\1\115\6\120";
	static final String DFA130_acceptS =
		"\1\uffff\1\1\1\uffff\1\2\1\uffff\1\7\5\uffff\1\14\1\15\1\16\13\uffff\1"+
		"\3\1\4\1\10\1\11\1\12\1\17\33\uffff\1\13\33\uffff\1\5\1\6\146\uffff";
	static final String DFA130_specialS =
		"\2\uffff\1\125\1\uffff\1\162\1\uffff\1\126\1\57\1\2\1\116\1\135\3\uffff"+
		"\1\72\1\155\1\137\1\u008d\1\131\1\0\1\124\1\u0098\1\u0080\1\70\1\3\6\uffff"+
		"\1\u009e\1\56\1\13\1\u00ab\1\103\1\6\1\164\1\7\1\37\1\160\1\36\1\41\1"+
		"\u0082\1\102\1\u008b\1\163\1\4\1\73\1\105\1\u0083\1\u009f\1\5\1\46\1\134"+
		"\1\u00a1\1\62\1\45\1\uffff\1\123\1\42\1\u0081\1\40\1\120\1\33\1\127\1"+
		"\u009a\1\u009b\1\34\1\74\1\106\1\u0084\1\u009c\1\u0088\1\67\1\121\1\1"+
		"\1\157\1\u00ac\1\142\1\165\1\u00a4\1\16\1\21\1\20\1\174\2\uffff\1\31\1"+
		"\77\1\u00a2\1\47\1\32\1\122\1\35\1\130\1\u0097\1\u0086\1\55\1\u0089\1"+
		"\60\1\100\1\176\1\50\1\143\1\u00a3\1\63\1\u009d\1\22\1\71\1\u008a\1\107"+
		"\1\144\1\u008c\1\u0095\1\43\1\117\1\51\1\145\1\166\1\u00a5\1\14\1\u0087"+
		"\1\65\1\11\1\75\1\61\1\101\1\177\1\133\1\167\1\u00a6\1\u00a0\1\23\1\u00ad"+
		"\1\175\1\110\1\147\1\u008e\1\17\1\64\1\u0099\1\52\1\u0085\1\15\1\132\1"+
		"\53\1\146\1\170\1\u00a7\1\10\1\24\1\66\1\12\1\76\1\25\1\111\1\136\1\u008f"+
		"\1\u0096\1\44\1\171\1\u00a8\1\54\1\140\1\172\1\u00a9\1\161\1\26\1\104"+
		"\1\151\1\u0090\1\112\1\154\1\u0091\1\141\1\173\1\u00aa\1\156\1\27\1\113"+
		"\1\152\1\u0092\1\30\1\114\1\150\1\u0093\1\115\1\153\1\u0094}>";
	static final String[] DFA130_transitionS = {
			"\1\2\13\uffff\1\1",
			"",
			"\1\3\11\uffff\2\3\20\uffff\2\3\24\uffff\1\4\13\uffff\1\3\14\uffff\1"+
			"\3\1\uffff\1\3",
			"",
			"\1\13\10\uffff\1\10\10\uffff\1\11\1\14\3\uffff\1\6\4\uffff\1\13\7\uffff"+
			"\1\15\2\uffff\4\13\1\7\7\uffff\1\13\1\uffff\1\13\3\uffff\1\13\2\uffff"+
			"\1\5\13\uffff\2\13\2\uffff\1\12",
			"",
			"\1\16\47\uffff\1\20\30\uffff\1\17",
			"\1\21\47\uffff\1\20\30\uffff\1\22",
			"\1\23\47\uffff\1\20\30\uffff\1\17",
			"\1\24",
			"\1\24",
			"",
			"",
			"",
			"\1\27\15\uffff\1\25\14\uffff\1\30\6\uffff\1\26",
			"\1\uffff",
			"\1\41\15\uffff\1\37\14\uffff\1\42\6\uffff\1\40\20\uffff\1\43",
			"\1\46\15\uffff\1\44\14\uffff\1\47\6\uffff\1\45",
			"\1\uffff",
			"\1\52\15\uffff\1\50\14\uffff\1\30\6\uffff\1\51",
			"\1\55\15\uffff\1\53\23\uffff\1\54",
			"\1\57\27\uffff\1\56",
			"\1\57\27\uffff\1\56",
			"\1\57\27\uffff\1\56",
			"\1\62\41\uffff\1\61\16\uffff\1\60\2\uffff\1\63",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\64\47\uffff\1\65\27\uffff\1\43",
			"\1\64\47\uffff\1\65\27\uffff\1\43",
			"\1\64\47\uffff\1\65\27\uffff\1\43",
			"\1\70\15\uffff\1\72\23\uffff\1\67\16\uffff\1\66\2\uffff\1\71",
			"\1\74\100\uffff\1\73",
			"\1\13\47\uffff\1\76\27\uffff\1\75",
			"\1\13\47\uffff\1\76\27\uffff\1\75",
			"\1\13\47\uffff\1\76\27\uffff\1\75",
			"\1\101\41\uffff\1\100\16\uffff\1\77\2\uffff\1\102",
			"\1\57\27\uffff\1\103",
			"\1\57\27\uffff\1\103",
			"\1\57\27\uffff\1\103",
			"\1\104",
			"\1\104",
			"\1\104",
			"\1\uffff",
			"\1\107\41\uffff\1\106\16\uffff\1\105\2\uffff\1\110",
			"\1\111\100\uffff\1\63",
			"\1\111\100\uffff\1\63",
			"\1\111\100\uffff\1\63",
			"\1\112",
			"\1\115\15\uffff\1\113\14\uffff\1\116\6\uffff\1\114",
			"\1\121\41\uffff\1\120\16\uffff\1\117\2\uffff\1\122",
			"\1\123\100\uffff\1\124",
			"\1\125\100\uffff\1\71",
			"\1\125\100\uffff\1\71",
			"\1\64\77\uffff\1\43",
			"",
			"\1\uffff",
			"\1\132\15\uffff\1\130\14\uffff\1\133\6\uffff\1\131\20\uffff\1\134",
			"\1\uffff",
			"\1\137\41\uffff\1\136\16\uffff\1\135\2\uffff\1\140",
			"\1\141\100\uffff\1\102",
			"\1\141\100\uffff\1\102",
			"\1\141\100\uffff\1\102",
			"\1\13\77\uffff\1\142",
			"\1\uffff",
			"\1\uffff",
			"\1\143\100\uffff\1\110",
			"\1\143\100\uffff\1\110",
			"\1\143\100\uffff\1\110",
			"\1\112",
			"\1\146\41\uffff\1\145\16\uffff\1\144",
			"\1\uffff",
			"\1\64\47\uffff\1\147\27\uffff\1\43",
			"\1\64\47\uffff\1\147\27\uffff\1\43",
			"\1\64\47\uffff\1\147\27\uffff\1\43",
			"\1\152\15\uffff\1\72\23\uffff\1\151\16\uffff\1\150\2\uffff\1\153",
			"\1\154\100\uffff\1\122",
			"\1\154\100\uffff\1\122",
			"\1\154\100\uffff\1\122",
			"\1\155\77\uffff\1\156",
			"\1\161\41\uffff\1\160\16\uffff\1\157",
			"\1\155\77\uffff\1\156",
			"\1\163\15\uffff\1\72\23\uffff\1\162\16\uffff\1\157",
			"",
			"",
			"\1\164\47\uffff\1\165\27\uffff\1\134",
			"\1\164\47\uffff\1\165\27\uffff\1\134",
			"\1\164\47\uffff\1\165\27\uffff\1\134",
			"\1\170\41\uffff\1\167\16\uffff\1\166\2\uffff\1\171",
			"\1\uffff",
			"\1\172\100\uffff\1\140",
			"\1\172\100\uffff\1\140",
			"\1\172\100\uffff\1\140",
			"\1\13\77\uffff\1\142",
			"\1\175\41\uffff\1\174\16\uffff\1\173",
			"\1\uffff",
			"\1\u0080\41\uffff\1\177\16\uffff\1\176",
			"\1\111\100\uffff\1\63",
			"\1\111\100\uffff\1\63",
			"\1\111\100\uffff\1\63",
			"\1\u0083\41\uffff\1\u0082\16\uffff\1\u0081\2\uffff\1\u0084",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0087\100\uffff\1\153",
			"\1\u0087\100\uffff\1\153",
			"\1\64\77\uffff\1\43",
			"\1\u008a\41\uffff\1\u0089\16\uffff\1\u0088",
			"\1\u008d\15\uffff\1\u008b\14\uffff\1\u008e\6\uffff\1\u008c",
			"\1\74\100\uffff\1\134",
			"\1\123\100\uffff\1\124",
			"\1\123\100\uffff\1\124",
			"\1\123\100\uffff\1\124",
			"\1\125\100\uffff\1\71",
			"\1\125\100\uffff\1\71",
			"\1\u0091\15\uffff\1\u008f\14\uffff\1\u0092\6\uffff\1\u0090",
			"\1\u0095\41\uffff\1\u0094\16\uffff\1\u0093\2\uffff\1\u0096",
			"\1\u0097\100\uffff\1\171",
			"\1\u0097\100\uffff\1\171",
			"\1\u0097\100\uffff\1\171",
			"\1\164\77\uffff\1\134",
			"\1\u009a\41\uffff\1\u0099\16\uffff\1\u0098",
			"\1\141\100\uffff\1\102",
			"\1\141\100\uffff\1\102",
			"\1\141\100\uffff\1\102",
			"\1\143\100\uffff\1\110",
			"\1\143\100\uffff\1\110",
			"\1\143\100\uffff\1\110",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u009b\100\uffff\1\u0084",
			"\1\155\77\uffff\1\156",
			"\1\u009e\41\uffff\1\u009d\16\uffff\1\u009c",
			"\1\155\77\uffff\1\156",
			"\1\u00a0\15\uffff\1\72\23\uffff\1\u009f\16\uffff\1\u009c",
			"\1\154\100\uffff\1\122",
			"\1\154\100\uffff\1\122",
			"\1\154\100\uffff\1\122",
			"\1\155\47\uffff\1\147\27\uffff\1\156",
			"\1\155\47\uffff\1\147\27\uffff\1\156",
			"\1\155\47\uffff\1\147\27\uffff\1\156",
			"\1\u00a2\41\uffff\1\u00a1\16\uffff\1\150\2\uffff\1\u0086",
			"\1\164\47\uffff\1\u00a3\27\uffff\1\134",
			"\1\164\47\uffff\1\u00a3\27\uffff\1\134",
			"\1\164\47\uffff\1\u00a3\27\uffff\1\134",
			"\1\u00a6\41\uffff\1\u00a5\16\uffff\1\u00a4\2\uffff\1\u00a7",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\164\77\uffff\1\134",
			"\1\u00ab\41\uffff\1\u00aa\16\uffff\1\u00a9",
			"\1\172\100\uffff\1\140",
			"\1\172\100\uffff\1\140",
			"\1\172\100\uffff\1\140",
			"\1\u00ae\41\uffff\1\u00ad\16\uffff\1\u00ac",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0087\100\uffff\1\153",
			"\1\u0087\100\uffff\1\153",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u0085\100\uffff\1\u0086",
			"\1\u00b1\41\uffff\1\u00b0\16\uffff\1\u00af\2\uffff\1\u00b2",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\164\77\uffff\1\134",
			"\1\u00b6\41\uffff\1\u00b5\16\uffff\1\u00b4",
			"\1\u0097\100\uffff\1\171",
			"\1\u0097\100\uffff\1\171",
			"\1\u0097\100\uffff\1\171",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u009b\100\uffff\1\u0084",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\164\77\uffff\1\134",
			"\1\u00ba\41\uffff\1\u00b9\16\uffff\1\u00b8",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00a8\100\uffff\1\u0096",
			"\1\u00bd\41\uffff\1\u00bc\16\uffff\1\u00bb",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b3\100\uffff\1\u00a7",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\u00b7\100\uffff\1\u00b2",
			"\1\u00b7\100\uffff\1\u00b2"
	};

	static final short[] DFA130_eot = DFA.unpackEncodedString(DFA130_eotS);
	static final short[] DFA130_eof = DFA.unpackEncodedString(DFA130_eofS);
	static final char[] DFA130_min = DFA.unpackEncodedStringToUnsignedChars(DFA130_minS);
	static final char[] DFA130_max = DFA.unpackEncodedStringToUnsignedChars(DFA130_maxS);
	static final short[] DFA130_accept = DFA.unpackEncodedString(DFA130_acceptS);
	static final short[] DFA130_special = DFA.unpackEncodedString(DFA130_specialS);
	static final short[][] DFA130_transition;

	static {
		int numStates = DFA130_transitionS.length;
		DFA130_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA130_transition[i] = DFA.unpackEncodedString(DFA130_transitionS[i]);
		}
	}

	protected class DFA130 extends DFA {

		public DFA130(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 130;
			this.eot = DFA130_eot;
			this.eof = DFA130_eof;
			this.min = DFA130_min;
			this.max = DFA130_max;
			this.accept = DFA130_accept;
			this.special = DFA130_special;
			this.transition = DFA130_transition;
		}
		@Override
		public String getDescription() {
			return "686:1: aspectAtom : ( aspectParenthesis -> aspectParenthesis | aspectName -> aspectName | aspectGet -> aspectGet | aspectSet -> aspectSet | aspectCall -> aspectCall | aspectExecution -> aspectExecution | aspectMainExecution -> aspectMainExecution | aspectLoop -> aspectLoop | aspectLoopHead -> aspectLoopHead | aspectLoopBody -> aspectLoopBody | aspectAnnotate -> aspectAnnotate | aspectOperator -> aspectOperator | aspectWithin -> aspectWithin | aspectDimension -> aspectDimension | aspectIsType -> aspectIsType );";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA130_19 = input.LA(1);
						 
						int index130_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_19==ID) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 40;}
						else if ( (LA130_19==MTIMES) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 41;}
						else if ( (LA130_19==DOTDOT) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 42;}
						else if ( (LA130_19==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 24;}
						 
						input.seek(index130_19);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA130_76 = input.LA(1);
						 
						int index130_76 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_76==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA130_76==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA130_76==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index130_76);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA130_8 = input.LA(1);
						 
						int index130_8 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_8==COLON) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 19;}
						else if ( (LA130_8==RPAREN) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 15;}
						else if ( (LA130_8==LPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 16;}
						 
						input.seek(index130_8);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA130_24 = input.LA(1);
						 
						int index130_24 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_24==REAL) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 48;}
						else if ( (LA130_24==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 49;}
						else if ( (LA130_24==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 50;}
						else if ( (LA130_24==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						 
						input.seek(index130_24);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA130_47 = input.LA(1);
						 
						int index130_47 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_47==REAL) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 69;}
						else if ( (LA130_47==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 70;}
						else if ( (LA130_47==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 71;}
						else if ( (LA130_47==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						 
						input.seek(index130_47);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA130_52 = input.LA(1);
						 
						int index130_52 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_52==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 75;}
						else if ( (LA130_52==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 76;}
						else if ( (LA130_52==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 77;}
						else if ( (LA130_52==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 78;}
						 
						input.seek(index130_52);
						if ( s>=0 ) return s;
						break;

					case 6 : 
						int LA130_36 = input.LA(1);
						 
						int index130_36 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_36==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 61;}
						else if ( (LA130_36==LSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 62;}
						else if ( (LA130_36==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index130_36);
						if ( s>=0 ) return s;
						break;

					case 7 : 
						int LA130_38 = input.LA(1);
						 
						int index130_38 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_38==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 61;}
						else if ( (LA130_38==LSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 62;}
						else if ( (LA130_38==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index130_38);
						if ( s>=0 ) return s;
						break;

					case 8 : 
						int LA130_150 = input.LA(1);
						 
						int index130_150 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_150==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA130_150==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						 
						input.seek(index130_150);
						if ( s>=0 ) return s;
						break;

					case 9 : 
						int LA130_124 = input.LA(1);
						 
						int index130_124 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_124==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						else if ( (LA130_124==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						 
						input.seek(index130_124);
						if ( s>=0 ) return s;
						break;

					case 10 : 
						int LA130_153 = input.LA(1);
						 
						int index130_153 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_153==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						else if ( (LA130_153==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						 
						input.seek(index130_153);
						if ( s>=0 ) return s;
						break;

					case 11 : 
						int LA130_33 = input.LA(1);
						 
						int index130_33 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_33==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA130_33==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA130_33==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 53;}
						 
						input.seek(index130_33);
						if ( s>=0 ) return s;
						break;

					case 12 : 
						int LA130_121 = input.LA(1);
						 
						int index130_121 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_121==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA130_121==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						 
						input.seek(index130_121);
						if ( s>=0 ) return s;
						break;

					case 13 : 
						int LA130_144 = input.LA(1);
						 
						int index130_144 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_144==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA130_144==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA130_144==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 163;}
						 
						input.seek(index130_144);
						if ( s>=0 ) return s;
						break;

					case 14 : 
						int LA130_82 = input.LA(1);
						 
						int index130_82 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_82==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA130_82==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						 
						input.seek(index130_82);
						if ( s>=0 ) return s;
						break;

					case 15 : 
						int LA130_139 = input.LA(1);
						 
						int index130_139 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_139==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA130_139==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA130_139==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index130_139);
						if ( s>=0 ) return s;
						break;

					case 16 : 
						int LA130_84 = input.LA(1);
						 
						int index130_84 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_84==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA130_84==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						 
						input.seek(index130_84);
						if ( s>=0 ) return s;
						break;

					case 17 : 
						int LA130_83 = input.LA(1);
						 
						int index130_83 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_83==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 111;}
						else if ( (LA130_83==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 112;}
						else if ( (LA130_83==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 113;}
						 
						input.seek(index130_83);
						if ( s>=0 ) return s;
						break;

					case 18 : 
						int LA130_108 = input.LA(1);
						 
						int index130_108 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_108==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 136;}
						else if ( (LA130_108==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 137;}
						else if ( (LA130_108==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 138;}
						 
						input.seek(index130_108);
						if ( s>=0 ) return s;
						break;

					case 19 : 
						int LA130_133 = input.LA(1);
						 
						int index130_133 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_133==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 156;}
						else if ( (LA130_133==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 157;}
						else if ( (LA130_133==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 158;}
						 
						input.seek(index130_133);
						if ( s>=0 ) return s;
						break;

					case 20 : 
						int LA130_151 = input.LA(1);
						 
						int index130_151 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_151==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 169;}
						else if ( (LA130_151==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 170;}
						else if ( (LA130_151==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 171;}
						 
						input.seek(index130_151);
						if ( s>=0 ) return s;
						break;

					case 21 : 
						int LA130_155 = input.LA(1);
						 
						int index130_155 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_155==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 172;}
						else if ( (LA130_155==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 173;}
						else if ( (LA130_155==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 174;}
						 
						input.seek(index130_155);
						if ( s>=0 ) return s;
						break;

					case 22 : 
						int LA130_168 = input.LA(1);
						 
						int index130_168 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_168==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 180;}
						else if ( (LA130_168==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 181;}
						else if ( (LA130_168==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 182;}
						 
						input.seek(index130_168);
						if ( s>=0 ) return s;
						break;

					case 23 : 
						int LA130_179 = input.LA(1);
						 
						int index130_179 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_179==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 184;}
						else if ( (LA130_179==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 185;}
						else if ( (LA130_179==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 186;}
						 
						input.seek(index130_179);
						if ( s>=0 ) return s;
						break;

					case 24 : 
						int LA130_183 = input.LA(1);
						 
						int index130_183 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_183==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 187;}
						else if ( (LA130_183==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 188;}
						else if ( (LA130_183==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 189;}
						 
						input.seek(index130_183);
						if ( s>=0 ) return s;
						break;

					case 25 : 
						int LA130_88 = input.LA(1);
						 
						int index130_88 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_88==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA130_88==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA130_88==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 117;}
						 
						input.seek(index130_88);
						if ( s>=0 ) return s;
						break;

					case 26 : 
						int LA130_92 = input.LA(1);
						 
						int index130_92 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("call"))) ) {s = 86;}
						else if ( ((Keyword_IdFollows("execution"))) ) {s = 87;}
						 
						input.seek(index130_92);
						if ( s>=0 ) return s;
						break;

					case 27 : 
						int LA130_64 = input.LA(1);
						 
						int index130_64 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_64==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						else if ( (LA130_64==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						 
						input.seek(index130_64);
						if ( s>=0 ) return s;
						break;

					case 28 : 
						int LA130_68 = input.LA(1);
						 
						int index130_68 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						 
						input.seek(index130_68);
						if ( s>=0 ) return s;
						break;

					case 29 : 
						int LA130_94 = input.LA(1);
						 
						int index130_94 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_94==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						else if ( (LA130_94==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						 
						input.seek(index130_94);
						if ( s>=0 ) return s;
						break;

					case 30 : 
						int LA130_41 = input.LA(1);
						 
						int index130_41 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_41==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 67;}
						else if ( (LA130_41==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index130_41);
						if ( s>=0 ) return s;
						break;

					case 31 : 
						int LA130_39 = input.LA(1);
						 
						int index130_39 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_39==REAL) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 63;}
						else if ( (LA130_39==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 64;}
						else if ( (LA130_39==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 65;}
						else if ( (LA130_39==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						 
						input.seek(index130_39);
						if ( s>=0 ) return s;
						break;

					case 32 : 
						int LA130_62 = input.LA(1);
						 
						int index130_62 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_62==REAL) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 93;}
						else if ( (LA130_62==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 94;}
						else if ( (LA130_62==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 95;}
						else if ( (LA130_62==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						 
						input.seek(index130_62);
						if ( s>=0 ) return s;
						break;

					case 33 : 
						int LA130_42 = input.LA(1);
						 
						int index130_42 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_42==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 67;}
						else if ( (LA130_42==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index130_42);
						if ( s>=0 ) return s;
						break;

					case 34 : 
						int LA130_60 = input.LA(1);
						 
						int index130_60 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_60==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 88;}
						else if ( (LA130_60==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 89;}
						else if ( (LA130_60==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 90;}
						else if ( (LA130_60==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 91;}
						else if ( (LA130_60==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						 
						input.seek(index130_60);
						if ( s>=0 ) return s;
						break;

					case 35 : 
						int LA130_115 = input.LA(1);
						 
						int index130_115 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_115==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						else if ( (LA130_115==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 85;}
						 
						input.seek(index130_115);
						if ( s>=0 ) return s;
						break;

					case 36 : 
						int LA130_160 = input.LA(1);
						 
						int index130_160 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_160==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						else if ( (LA130_160==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 135;}
						 
						input.seek(index130_160);
						if ( s>=0 ) return s;
						break;

					case 37 : 
						int LA130_57 = input.LA(1);
						 
						int index130_57 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_57==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA130_57==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						 
						input.seek(index130_57);
						if ( s>=0 ) return s;
						break;

					case 38 : 
						int LA130_53 = input.LA(1);
						 
						int index130_53 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_53==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 79;}
						else if ( (LA130_53==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 80;}
						else if ( (LA130_53==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 81;}
						else if ( (LA130_53==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						 
						input.seek(index130_53);
						if ( s>=0 ) return s;
						break;

					case 39 : 
						int LA130_91 = input.LA(1);
						 
						int index130_91 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_91==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 118;}
						else if ( (LA130_91==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 119;}
						else if ( (LA130_91==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 120;}
						else if ( (LA130_91==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						 
						input.seek(index130_91);
						if ( s>=0 ) return s;
						break;

					case 40 : 
						int LA130_103 = input.LA(1);
						 
						int index130_103 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_103==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 129;}
						else if ( (LA130_103==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 130;}
						else if ( (LA130_103==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 131;}
						else if ( (LA130_103==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						 
						input.seek(index130_103);
						if ( s>=0 ) return s;
						break;

					case 41 : 
						int LA130_117 = input.LA(1);
						 
						int index130_117 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_117==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 147;}
						else if ( (LA130_117==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 148;}
						else if ( (LA130_117==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 149;}
						else if ( (LA130_117==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						 
						input.seek(index130_117);
						if ( s>=0 ) return s;
						break;

					case 42 : 
						int LA130_142 = input.LA(1);
						 
						int index130_142 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_142==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 104;}
						else if ( (LA130_142==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 161;}
						else if ( (LA130_142==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 162;}
						else if ( (LA130_142==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						 
						input.seek(index130_142);
						if ( s>=0 ) return s;
						break;

					case 43 : 
						int LA130_146 = input.LA(1);
						 
						int index130_146 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_146==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 164;}
						else if ( (LA130_146==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 165;}
						else if ( (LA130_146==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 166;}
						else if ( (LA130_146==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						 
						input.seek(index130_146);
						if ( s>=0 ) return s;
						break;

					case 44 : 
						int LA130_163 = input.LA(1);
						 
						int index130_163 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_163==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 175;}
						else if ( (LA130_163==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 176;}
						else if ( (LA130_163==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 177;}
						else if ( (LA130_163==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						 
						input.seek(index130_163);
						if ( s>=0 ) return s;
						break;

					case 45 : 
						int LA130_98 = input.LA(1);
						 
						int index130_98 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("op"))) ) {s = 11;}
						 
						input.seek(index130_98);
						if ( s>=0 ) return s;
						break;

					case 46 : 
						int LA130_32 = input.LA(1);
						 
						int index130_32 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_32==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA130_32==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA130_32==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 53;}
						 
						input.seek(index130_32);
						if ( s>=0 ) return s;
						break;

					case 47 : 
						int LA130_7 = input.LA(1);
						 
						int index130_7 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_7==COLON) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 17;}
						else if ( (LA130_7==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("istype"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 18;}
						else if ( (LA130_7==LPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 16;}
						 
						input.seek(index130_7);
						if ( s>=0 ) return s;
						break;

					case 48 : 
						int LA130_100 = input.LA(1);
						 
						int index130_100 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_100==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						else if ( (LA130_100==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						 
						input.seek(index130_100);
						if ( s>=0 ) return s;
						break;

					case 49 : 
						int LA130_126 = input.LA(1);
						 
						int index130_126 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_126==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						else if ( (LA130_126==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						 
						input.seek(index130_126);
						if ( s>=0 ) return s;
						break;

					case 50 : 
						int LA130_56 = input.LA(1);
						 
						int index130_56 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_56==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 85;}
						else if ( (LA130_56==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						 
						input.seek(index130_56);
						if ( s>=0 ) return s;
						break;

					case 51 : 
						int LA130_106 = input.LA(1);
						 
						int index130_106 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_106==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 135;}
						else if ( (LA130_106==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						 
						input.seek(index130_106);
						if ( s>=0 ) return s;
						break;

					case 52 : 
						int LA130_140 = input.LA(1);
						 
						int index130_140 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_140==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA130_140==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA130_140==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index130_140);
						if ( s>=0 ) return s;
						break;

					case 53 : 
						int LA130_123 = input.LA(1);
						 
						int index130_123 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_123==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						else if ( (LA130_123==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						 
						input.seek(index130_123);
						if ( s>=0 ) return s;
						break;

					case 54 : 
						int LA130_152 = input.LA(1);
						 
						int index130_152 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_152==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						else if ( (LA130_152==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						 
						input.seek(index130_152);
						if ( s>=0 ) return s;
						break;

					case 55 : 
						int LA130_74 = input.LA(1);
						 
						int index130_74 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						 
						input.seek(index130_74);
						if ( s>=0 ) return s;
						break;

					case 56 : 
						int LA130_23 = input.LA(1);
						 
						int index130_23 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_23==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 46;}
						else if ( (LA130_23==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index130_23);
						if ( s>=0 ) return s;
						break;

					case 57 : 
						int LA130_109 = input.LA(1);
						 
						int index130_109 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_109==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 139;}
						else if ( (LA130_109==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 140;}
						else if ( (LA130_109==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 141;}
						else if ( (LA130_109==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 142;}
						 
						input.seek(index130_109);
						if ( s>=0 ) return s;
						break;

					case 58 : 
						int LA130_14 = input.LA(1);
						 
						int index130_14 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_14==ID) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 21;}
						else if ( (LA130_14==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 22;}
						else if ( (LA130_14==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 23;}
						else if ( (LA130_14==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 24;}
						 
						input.seek(index130_14);
						if ( s>=0 ) return s;
						break;

					case 59 : 
						int LA130_48 = input.LA(1);
						 
						int index130_48 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_48==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						else if ( (LA130_48==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						 
						input.seek(index130_48);
						if ( s>=0 ) return s;
						break;

					case 60 : 
						int LA130_69 = input.LA(1);
						 
						int index130_69 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_69==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						else if ( (LA130_69==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						 
						input.seek(index130_69);
						if ( s>=0 ) return s;
						break;

					case 61 : 
						int LA130_125 = input.LA(1);
						 
						int index130_125 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_125==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						else if ( (LA130_125==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						 
						input.seek(index130_125);
						if ( s>=0 ) return s;
						break;

					case 62 : 
						int LA130_154 = input.LA(1);
						 
						int index130_154 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_154==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						else if ( (LA130_154==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						 
						input.seek(index130_154);
						if ( s>=0 ) return s;
						break;

					case 63 : 
						int LA130_89 = input.LA(1);
						 
						int index130_89 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_89==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA130_89==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA130_89==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 117;}
						 
						input.seek(index130_89);
						if ( s>=0 ) return s;
						break;

					case 64 : 
						int LA130_101 = input.LA(1);
						 
						int index130_101 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_101==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						else if ( (LA130_101==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						 
						input.seek(index130_101);
						if ( s>=0 ) return s;
						break;

					case 65 : 
						int LA130_127 = input.LA(1);
						 
						int index130_127 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_127==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						else if ( (LA130_127==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						 
						input.seek(index130_127);
						if ( s>=0 ) return s;
						break;

					case 66 : 
						int LA130_44 = input.LA(1);
						 
						int index130_44 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_44==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 68;}
						 
						input.seek(index130_44);
						if ( s>=0 ) return s;
						break;

					case 67 : 
						int LA130_35 = input.LA(1);
						 
						int index130_35 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_35==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 59;}
						else if ( (LA130_35==COLON) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 60;}
						 
						input.seek(index130_35);
						if ( s>=0 ) return s;
						break;

					case 68 : 
						int LA130_169 = input.LA(1);
						 
						int index130_169 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_169==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						else if ( (LA130_169==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						 
						input.seek(index130_169);
						if ( s>=0 ) return s;
						break;

					case 69 : 
						int LA130_49 = input.LA(1);
						 
						int index130_49 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_49==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						else if ( (LA130_49==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						 
						input.seek(index130_49);
						if ( s>=0 ) return s;
						break;

					case 70 : 
						int LA130_70 = input.LA(1);
						 
						int index130_70 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_70==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						else if ( (LA130_70==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						 
						input.seek(index130_70);
						if ( s>=0 ) return s;
						break;

					case 71 : 
						int LA130_111 = input.LA(1);
						 
						int index130_111 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_111==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 84;}
						else if ( (LA130_111==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 83;}
						 
						input.seek(index130_111);
						if ( s>=0 ) return s;
						break;

					case 72 : 
						int LA130_136 = input.LA(1);
						 
						int index130_136 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_136==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						else if ( (LA130_136==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						 
						input.seek(index130_136);
						if ( s>=0 ) return s;
						break;

					case 73 : 
						int LA130_156 = input.LA(1);
						 
						int index130_156 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_156==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						else if ( (LA130_156==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						 
						input.seek(index130_156);
						if ( s>=0 ) return s;
						break;

					case 74 : 
						int LA130_172 = input.LA(1);
						 
						int index130_172 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_172==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						else if ( (LA130_172==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						 
						input.seek(index130_172);
						if ( s>=0 ) return s;
						break;

					case 75 : 
						int LA130_180 = input.LA(1);
						 
						int index130_180 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_180==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						else if ( (LA130_180==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						 
						input.seek(index130_180);
						if ( s>=0 ) return s;
						break;

					case 76 : 
						int LA130_184 = input.LA(1);
						 
						int index130_184 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_184==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						else if ( (LA130_184==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						 
						input.seek(index130_184);
						if ( s>=0 ) return s;
						break;

					case 77 : 
						int LA130_187 = input.LA(1);
						 
						int index130_187 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_187==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						else if ( (LA130_187==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						 
						input.seek(index130_187);
						if ( s>=0 ) return s;
						break;

					case 78 : 
						int LA130_9 = input.LA(1);
						 
						int index130_9 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_9==COLON) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 20;}
						 
						input.seek(index130_9);
						if ( s>=0 ) return s;
						break;

					case 79 : 
						int LA130_116 = input.LA(1);
						 
						int index130_116 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_116==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 143;}
						else if ( (LA130_116==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 144;}
						else if ( (LA130_116==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 145;}
						else if ( (LA130_116==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 146;}
						 
						input.seek(index130_116);
						if ( s>=0 ) return s;
						break;

					case 80 : 
						int LA130_63 = input.LA(1);
						 
						int index130_63 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_63==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						else if ( (LA130_63==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						 
						input.seek(index130_63);
						if ( s>=0 ) return s;
						break;

					case 81 : 
						int LA130_75 = input.LA(1);
						 
						int index130_75 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_75==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA130_75==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA130_75==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index130_75);
						if ( s>=0 ) return s;
						break;

					case 82 : 
						int LA130_93 = input.LA(1);
						 
						int index130_93 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_93==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						else if ( (LA130_93==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						 
						input.seek(index130_93);
						if ( s>=0 ) return s;
						break;

					case 83 : 
						int LA130_59 = input.LA(1);
						 
						int index130_59 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("call"))) ) {s = 86;}
						else if ( ((Keyword_IdFollows("execution"))) ) {s = 87;}
						else if ( ((Keyword_IdFollows("annotate"))) ) {s = 58;}
						 
						input.seek(index130_59);
						if ( s>=0 ) return s;
						break;

					case 84 : 
						int LA130_20 = input.LA(1);
						 
						int index130_20 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_20==ID) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 43;}
						else if ( (LA130_20==MTIMES) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 44;}
						else if ( (LA130_20==DOTDOT) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 45;}
						 
						input.seek(index130_20);
						if ( s>=0 ) return s;
						break;

					case 85 : 
						int LA130_2 = input.LA(1);
						 
						int index130_2 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_2==AND||(LA130_2 >= COLON && LA130_2 <= COMMA)||(LA130_2 >= END && LA130_2 <= EOL)||LA130_2==OR||LA130_2==RPAREN||LA130_2==SEMICOLON) ) {s = 3;}
						else if ( (LA130_2==LPAREN) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("mainexecution"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("op"))||(Keyword_IdFollows("execution"))||(Keyword_IdFollows("dimension"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("annotate"))))) {s = 4;}
						 
						input.seek(index130_2);
						if ( s>=0 ) return s;
						break;

					case 86 : 
						int LA130_6 = input.LA(1);
						 
						int index130_6 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_6==COLON) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 14;}
						else if ( (LA130_6==RPAREN) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 15;}
						else if ( (LA130_6==LPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 16;}
						 
						input.seek(index130_6);
						if ( s>=0 ) return s;
						break;

					case 87 : 
						int LA130_65 = input.LA(1);
						 
						int index130_65 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_65==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 97;}
						else if ( (LA130_65==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 66;}
						 
						input.seek(index130_65);
						if ( s>=0 ) return s;
						break;

					case 88 : 
						int LA130_95 = input.LA(1);
						 
						int index130_95 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_95==COMMA) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 122;}
						else if ( (LA130_95==RSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 96;}
						 
						input.seek(index130_95);
						if ( s>=0 ) return s;
						break;

					case 89 : 
						int LA130_18 = input.LA(1);
						 
						int index130_18 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						else if ( ((Keyword_IdFollows("op"))) ) {s = 11;}
						else if ( ((Keyword_IdFollows("istype"))) ) {s = 30;}
						 
						input.seek(index130_18);
						if ( s>=0 ) return s;
						break;

					case 90 : 
						int LA130_145 = input.LA(1);
						 
						int index130_145 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_145==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA130_145==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA130_145==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 163;}
						 
						input.seek(index130_145);
						if ( s>=0 ) return s;
						break;

					case 91 : 
						int LA130_129 = input.LA(1);
						 
						int index130_129 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_129==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						else if ( (LA130_129==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						 
						input.seek(index130_129);
						if ( s>=0 ) return s;
						break;

					case 92 : 
						int LA130_54 = input.LA(1);
						 
						int index130_54 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_54==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 83;}
						else if ( (LA130_54==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 84;}
						 
						input.seek(index130_54);
						if ( s>=0 ) return s;
						break;

					case 93 : 
						int LA130_10 = input.LA(1);
						 
						int index130_10 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_10==COLON) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 20;}
						 
						input.seek(index130_10);
						if ( s>=0 ) return s;
						break;

					case 94 : 
						int LA130_157 = input.LA(1);
						 
						int index130_157 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_157==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						else if ( (LA130_157==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						 
						input.seek(index130_157);
						if ( s>=0 ) return s;
						break;

					case 95 : 
						int LA130_16 = input.LA(1);
						 
						int index130_16 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_16==ID) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 31;}
						else if ( (LA130_16==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 32;}
						else if ( (LA130_16==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 33;}
						else if ( (LA130_16==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 34;}
						else if ( (LA130_16==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						 
						input.seek(index130_16);
						if ( s>=0 ) return s;
						break;

					case 96 : 
						int LA130_164 = input.LA(1);
						 
						int index130_164 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_164==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						else if ( (LA130_164==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						 
						input.seek(index130_164);
						if ( s>=0 ) return s;
						break;

					case 97 : 
						int LA130_175 = input.LA(1);
						 
						int index130_175 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_175==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						else if ( (LA130_175==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						 
						input.seek(index130_175);
						if ( s>=0 ) return s;
						break;

					case 98 : 
						int LA130_79 = input.LA(1);
						 
						int index130_79 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_79==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						else if ( (LA130_79==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						 
						input.seek(index130_79);
						if ( s>=0 ) return s;
						break;

					case 99 : 
						int LA130_104 = input.LA(1);
						 
						int index130_104 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_104==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						else if ( (LA130_104==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						 
						input.seek(index130_104);
						if ( s>=0 ) return s;
						break;

					case 100 : 
						int LA130_112 = input.LA(1);
						 
						int index130_112 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_112==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 84;}
						else if ( (LA130_112==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 83;}
						 
						input.seek(index130_112);
						if ( s>=0 ) return s;
						break;

					case 101 : 
						int LA130_118 = input.LA(1);
						 
						int index130_118 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_118==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						else if ( (LA130_118==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						 
						input.seek(index130_118);
						if ( s>=0 ) return s;
						break;

					case 102 : 
						int LA130_147 = input.LA(1);
						 
						int index130_147 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_147==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						else if ( (LA130_147==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						 
						input.seek(index130_147);
						if ( s>=0 ) return s;
						break;

					case 103 : 
						int LA130_137 = input.LA(1);
						 
						int index130_137 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_137==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						else if ( (LA130_137==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						 
						input.seek(index130_137);
						if ( s>=0 ) return s;
						break;

					case 104 : 
						int LA130_185 = input.LA(1);
						 
						int index130_185 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_185==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						else if ( (LA130_185==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						 
						input.seek(index130_185);
						if ( s>=0 ) return s;
						break;

					case 105 : 
						int LA130_170 = input.LA(1);
						 
						int index130_170 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_170==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						else if ( (LA130_170==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						 
						input.seek(index130_170);
						if ( s>=0 ) return s;
						break;

					case 106 : 
						int LA130_181 = input.LA(1);
						 
						int index130_181 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_181==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						else if ( (LA130_181==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						 
						input.seek(index130_181);
						if ( s>=0 ) return s;
						break;

					case 107 : 
						int LA130_188 = input.LA(1);
						 
						int index130_188 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_188==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						else if ( (LA130_188==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						 
						input.seek(index130_188);
						if ( s>=0 ) return s;
						break;

					case 108 : 
						int LA130_173 = input.LA(1);
						 
						int index130_173 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_173==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						else if ( (LA130_173==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						 
						input.seek(index130_173);
						if ( s>=0 ) return s;
						break;

					case 109 : 
						int LA130_15 = input.LA(1);
						 
						int index130_15 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						else if ( ((Keyword_IdFollows("istype"))) ) {s = 30;}
						 
						input.seek(index130_15);
						if ( s>=0 ) return s;
						break;

					case 110 : 
						int LA130_178 = input.LA(1);
						 
						int index130_178 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_178==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA130_178==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						 
						input.seek(index130_178);
						if ( s>=0 ) return s;
						break;

					case 111 : 
						int LA130_77 = input.LA(1);
						 
						int index130_77 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_77==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA130_77==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA130_77==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index130_77);
						if ( s>=0 ) return s;
						break;

					case 112 : 
						int LA130_40 = input.LA(1);
						 
						int index130_40 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_40==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 67;}
						else if ( (LA130_40==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index130_40);
						if ( s>=0 ) return s;
						break;

					case 113 : 
						int LA130_167 = input.LA(1);
						 
						int index130_167 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_167==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA130_167==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						 
						input.seek(index130_167);
						if ( s>=0 ) return s;
						break;

					case 114 : 
						int LA130_4 = input.LA(1);
						 
						int index130_4 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_4==RPAREN) && ((Keyword_IdFollows("mainexecution")))) {s = 5;}
						else if ( (LA130_4==ID) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("execution"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("annotate"))))) {s = 6;}
						else if ( (LA130_4==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("istype"))||(Keyword_IdFollows("execution"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("annotate"))))) {s = 7;}
						else if ( (LA130_4==DOTDOT) && (((Keyword_IdFollows("istype"))||(Keyword_IdFollows("execution"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))||(Keyword_IdFollows("annotate"))))) {s = 8;}
						else if ( (LA130_4==FOR) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 9;}
						else if ( (LA130_4==WHILE) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 10;}
						else if ( (LA130_4==CTRANS||LA130_4==LDIV||(LA130_4 >= MINUS && LA130_4 <= MRDIV)||LA130_4==PLUS||LA130_4==POW||LA130_4==RDIV||(LA130_4 >= TIMES && LA130_4 <= TRANS)) && ((Keyword_IdFollows("op")))) {s = 11;}
						else if ( (LA130_4==FUNCTION) && ((Keyword_IdFollows("within")))) {s = 12;}
						else if ( (LA130_4==LSQUARE) && ((Keyword_IdFollows("dimension")))) {s = 13;}
						 
						input.seek(index130_4);
						if ( s>=0 ) return s;
						break;

					case 115 : 
						int LA130_46 = input.LA(1);
						 
						int index130_46 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("within"))) ) {s = 12;}
						 
						input.seek(index130_46);
						if ( s>=0 ) return s;
						break;

					case 116 : 
						int LA130_37 = input.LA(1);
						 
						int index130_37 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_37==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 61;}
						else if ( (LA130_37==LSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 62;}
						else if ( (LA130_37==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index130_37);
						if ( s>=0 ) return s;
						break;

					case 117 : 
						int LA130_80 = input.LA(1);
						 
						int index130_80 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_80==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						else if ( (LA130_80==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						 
						input.seek(index130_80);
						if ( s>=0 ) return s;
						break;

					case 118 : 
						int LA130_119 = input.LA(1);
						 
						int index130_119 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_119==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						else if ( (LA130_119==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						 
						input.seek(index130_119);
						if ( s>=0 ) return s;
						break;

					case 119 : 
						int LA130_130 = input.LA(1);
						 
						int index130_130 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_130==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						else if ( (LA130_130==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						 
						input.seek(index130_130);
						if ( s>=0 ) return s;
						break;

					case 120 : 
						int LA130_148 = input.LA(1);
						 
						int index130_148 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_148==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						else if ( (LA130_148==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						 
						input.seek(index130_148);
						if ( s>=0 ) return s;
						break;

					case 121 : 
						int LA130_161 = input.LA(1);
						 
						int index130_161 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_161==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						else if ( (LA130_161==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						 
						input.seek(index130_161);
						if ( s>=0 ) return s;
						break;

					case 122 : 
						int LA130_165 = input.LA(1);
						 
						int index130_165 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_165==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						else if ( (LA130_165==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						 
						input.seek(index130_165);
						if ( s>=0 ) return s;
						break;

					case 123 : 
						int LA130_176 = input.LA(1);
						 
						int index130_176 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_176==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						else if ( (LA130_176==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						 
						input.seek(index130_176);
						if ( s>=0 ) return s;
						break;

					case 124 : 
						int LA130_85 = input.LA(1);
						 
						int index130_85 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_85==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 111;}
						else if ( (LA130_85==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 114;}
						else if ( (LA130_85==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 115;}
						else if ( (LA130_85==ID) && ((Keyword_IdFollows("annotate")))) {s = 58;}
						 
						input.seek(index130_85);
						if ( s>=0 ) return s;
						break;

					case 125 : 
						int LA130_135 = input.LA(1);
						 
						int index130_135 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_135==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 156;}
						else if ( (LA130_135==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 159;}
						else if ( (LA130_135==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 160;}
						else if ( (LA130_135==ID) && ((Keyword_IdFollows("annotate")))) {s = 58;}
						 
						input.seek(index130_135);
						if ( s>=0 ) return s;
						break;

					case 126 : 
						int LA130_102 = input.LA(1);
						 
						int index130_102 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_102==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						else if ( (LA130_102==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						 
						input.seek(index130_102);
						if ( s>=0 ) return s;
						break;

					case 127 : 
						int LA130_128 = input.LA(1);
						 
						int index130_128 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_128==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						else if ( (LA130_128==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						 
						input.seek(index130_128);
						if ( s>=0 ) return s;
						break;

					case 128 : 
						int LA130_22 = input.LA(1);
						 
						int index130_22 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_22==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 46;}
						else if ( (LA130_22==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index130_22);
						if ( s>=0 ) return s;
						break;

					case 129 : 
						int LA130_61 = input.LA(1);
						 
						int index130_61 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						else if ( ((Keyword_IdFollows("op"))) ) {s = 11;}
						else if ( ((Keyword_IdFollows("within"))) ) {s = 12;}
						 
						input.seek(index130_61);
						if ( s>=0 ) return s;
						break;

					case 130 : 
						int LA130_43 = input.LA(1);
						 
						int index130_43 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_43==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 68;}
						 
						input.seek(index130_43);
						if ( s>=0 ) return s;
						break;

					case 131 : 
						int LA130_50 = input.LA(1);
						 
						int index130_50 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_50==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 73;}
						else if ( (LA130_50==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 51;}
						 
						input.seek(index130_50);
						if ( s>=0 ) return s;
						break;

					case 132 : 
						int LA130_71 = input.LA(1);
						 
						int index130_71 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_71==COMMA) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 99;}
						else if ( (LA130_71==RSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 72;}
						 
						input.seek(index130_71);
						if ( s>=0 ) return s;
						break;

					case 133 : 
						int LA130_143 = input.LA(1);
						 
						int index130_143 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_143==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA130_143==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA130_143==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 163;}
						 
						input.seek(index130_143);
						if ( s>=0 ) return s;
						break;

					case 134 : 
						int LA130_97 = input.LA(1);
						 
						int index130_97 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_97==REAL) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 123;}
						else if ( (LA130_97==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 124;}
						else if ( (LA130_97==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 125;}
						 
						input.seek(index130_97);
						if ( s>=0 ) return s;
						break;

					case 135 : 
						int LA130_122 = input.LA(1);
						 
						int index130_122 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_122==REAL) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 152;}
						else if ( (LA130_122==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 153;}
						else if ( (LA130_122==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 154;}
						 
						input.seek(index130_122);
						if ( s>=0 ) return s;
						break;

					case 136 : 
						int LA130_73 = input.LA(1);
						 
						int index130_73 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_73==REAL) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 100;}
						else if ( (LA130_73==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 101;}
						else if ( (LA130_73==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 102;}
						 
						input.seek(index130_73);
						if ( s>=0 ) return s;
						break;

					case 137 : 
						int LA130_99 = input.LA(1);
						 
						int index130_99 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_99==REAL) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 126;}
						else if ( (LA130_99==MTIMES) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 127;}
						else if ( (LA130_99==DOTDOT) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 128;}
						 
						input.seek(index130_99);
						if ( s>=0 ) return s;
						break;

					case 138 : 
						int LA130_110 = input.LA(1);
						 
						int index130_110 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_110==COLON) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 60;}
						else if ( (LA130_110==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						 
						input.seek(index130_110);
						if ( s>=0 ) return s;
						break;

					case 139 : 
						int LA130_45 = input.LA(1);
						 
						int index130_45 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_45==RPAREN) && (((Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("loop"))))) {s = 68;}
						 
						input.seek(index130_45);
						if ( s>=0 ) return s;
						break;

					case 140 : 
						int LA130_113 = input.LA(1);
						 
						int index130_113 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_113==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 84;}
						else if ( (LA130_113==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 83;}
						 
						input.seek(index130_113);
						if ( s>=0 ) return s;
						break;

					case 141 : 
						int LA130_17 = input.LA(1);
						 
						int index130_17 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_17==ID) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 36;}
						else if ( (LA130_17==MTIMES) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 37;}
						else if ( (LA130_17==DOTDOT) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("loopbody"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("loophead"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))||(Keyword_IdFollows("loop"))))) {s = 38;}
						else if ( (LA130_17==LSQUARE) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 39;}
						 
						input.seek(index130_17);
						if ( s>=0 ) return s;
						break;

					case 142 : 
						int LA130_138 = input.LA(1);
						 
						int index130_138 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_138==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						else if ( (LA130_138==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						 
						input.seek(index130_138);
						if ( s>=0 ) return s;
						break;

					case 143 : 
						int LA130_158 = input.LA(1);
						 
						int index130_158 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_158==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						else if ( (LA130_158==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						 
						input.seek(index130_158);
						if ( s>=0 ) return s;
						break;

					case 144 : 
						int LA130_171 = input.LA(1);
						 
						int index130_171 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_171==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						else if ( (LA130_171==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						 
						input.seek(index130_171);
						if ( s>=0 ) return s;
						break;

					case 145 : 
						int LA130_174 = input.LA(1);
						 
						int index130_174 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_174==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						else if ( (LA130_174==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						 
						input.seek(index130_174);
						if ( s>=0 ) return s;
						break;

					case 146 : 
						int LA130_182 = input.LA(1);
						 
						int index130_182 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_182==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						else if ( (LA130_182==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						 
						input.seek(index130_182);
						if ( s>=0 ) return s;
						break;

					case 147 : 
						int LA130_186 = input.LA(1);
						 
						int index130_186 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_186==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						else if ( (LA130_186==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						 
						input.seek(index130_186);
						if ( s>=0 ) return s;
						break;

					case 148 : 
						int LA130_189 = input.LA(1);
						 
						int index130_189 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_189==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						else if ( (LA130_189==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						 
						input.seek(index130_189);
						if ( s>=0 ) return s;
						break;

					case 149 : 
						int LA130_114 = input.LA(1);
						 
						int index130_114 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_114==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						else if ( (LA130_114==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 85;}
						 
						input.seek(index130_114);
						if ( s>=0 ) return s;
						break;

					case 150 : 
						int LA130_159 = input.LA(1);
						 
						int index130_159 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_159==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						else if ( (LA130_159==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 135;}
						 
						input.seek(index130_159);
						if ( s>=0 ) return s;
						break;

					case 151 : 
						int LA130_96 = input.LA(1);
						 
						int index130_96 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_96==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 98;}
						else if ( (LA130_96==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index130_96);
						if ( s>=0 ) return s;
						break;

					case 152 : 
						int LA130_21 = input.LA(1);
						 
						int index130_21 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_21==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("within"))||(Keyword_IdFollows("get"))))) {s = 46;}
						else if ( (LA130_21==LSQUARE) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 47;}
						 
						input.seek(index130_21);
						if ( s>=0 ) return s;
						break;

					case 153 : 
						int LA130_141 = input.LA(1);
						 
						int index130_141 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_141==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA130_141==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						else if ( (LA130_141==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 103;}
						 
						input.seek(index130_141);
						if ( s>=0 ) return s;
						break;

					case 154 : 
						int LA130_66 = input.LA(1);
						 
						int index130_66 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_66==RPAREN) && (((Keyword_IdFollows("op"))||(Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 98;}
						else if ( (LA130_66==COMMA) && ((Keyword_IdFollows("op")))) {s = 11;}
						 
						input.seek(index130_66);
						if ( s>=0 ) return s;
						break;

					case 155 : 
						int LA130_67 = input.LA(1);
						 
						int index130_67 = input.index();
						input.rewind();
						s = -1;
						if ( ((Keyword_IdFollows("get"))) ) {s = 25;}
						else if ( ((Keyword_IdFollows("set"))) ) {s = 26;}
						else if ( ((Keyword_IdFollows("loop"))) ) {s = 27;}
						else if ( ((Keyword_IdFollows("loophead"))) ) {s = 28;}
						else if ( ((Keyword_IdFollows("loopbody"))) ) {s = 29;}
						else if ( ((Keyword_IdFollows("within"))) ) {s = 12;}
						 
						input.seek(index130_67);
						if ( s>=0 ) return s;
						break;

					case 156 : 
						int LA130_72 = input.LA(1);
						 
						int index130_72 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_72==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 74;}
						 
						input.seek(index130_72);
						if ( s>=0 ) return s;
						break;

					case 157 : 
						int LA130_107 = input.LA(1);
						 
						int index130_107 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_107==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA130_107==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						 
						input.seek(index130_107);
						if ( s>=0 ) return s;
						break;

					case 158 : 
						int LA130_31 = input.LA(1);
						 
						int index130_31 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_31==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 52;}
						else if ( (LA130_31==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 35;}
						else if ( (LA130_31==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 53;}
						 
						input.seek(index130_31);
						if ( s>=0 ) return s;
						break;

					case 159 : 
						int LA130_51 = input.LA(1);
						 
						int index130_51 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_51==RPAREN) && (((Keyword_IdFollows("set"))||(Keyword_IdFollows("get"))))) {s = 74;}
						 
						input.seek(index130_51);
						if ( s>=0 ) return s;
						break;

					case 160 : 
						int LA130_132 = input.LA(1);
						 
						int index130_132 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_132==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA130_132==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						 
						input.seek(index130_132);
						if ( s>=0 ) return s;
						break;

					case 161 : 
						int LA130_55 = input.LA(1);
						 
						int index130_55 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_55==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 85;}
						else if ( (LA130_55==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						 
						input.seek(index130_55);
						if ( s>=0 ) return s;
						break;

					case 162 : 
						int LA130_90 = input.LA(1);
						 
						int index130_90 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_90==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 116;}
						else if ( (LA130_90==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 92;}
						else if ( (LA130_90==LSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 117;}
						 
						input.seek(index130_90);
						if ( s>=0 ) return s;
						break;

					case 163 : 
						int LA130_105 = input.LA(1);
						 
						int index130_105 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_105==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 135;}
						else if ( (LA130_105==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						 
						input.seek(index130_105);
						if ( s>=0 ) return s;
						break;

					case 164 : 
						int LA130_81 = input.LA(1);
						 
						int index130_81 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_81==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 108;}
						else if ( (LA130_81==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 82;}
						 
						input.seek(index130_81);
						if ( s>=0 ) return s;
						break;

					case 165 : 
						int LA130_120 = input.LA(1);
						 
						int index130_120 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_120==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 151;}
						else if ( (LA130_120==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 121;}
						 
						input.seek(index130_120);
						if ( s>=0 ) return s;
						break;

					case 166 : 
						int LA130_131 = input.LA(1);
						 
						int index130_131 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_131==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 155;}
						else if ( (LA130_131==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 132;}
						 
						input.seek(index130_131);
						if ( s>=0 ) return s;
						break;

					case 167 : 
						int LA130_149 = input.LA(1);
						 
						int index130_149 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_149==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 168;}
						else if ( (LA130_149==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 150;}
						 
						input.seek(index130_149);
						if ( s>=0 ) return s;
						break;

					case 168 : 
						int LA130_162 = input.LA(1);
						 
						int index130_162 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_162==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 133;}
						else if ( (LA130_162==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 134;}
						 
						input.seek(index130_162);
						if ( s>=0 ) return s;
						break;

					case 169 : 
						int LA130_166 = input.LA(1);
						 
						int index130_166 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_166==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 179;}
						else if ( (LA130_166==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 167;}
						 
						input.seek(index130_166);
						if ( s>=0 ) return s;
						break;

					case 170 : 
						int LA130_177 = input.LA(1);
						 
						int index130_177 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_177==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 183;}
						else if ( (LA130_177==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 178;}
						 
						input.seek(index130_177);
						if ( s>=0 ) return s;
						break;

					case 171 : 
						int LA130_34 = input.LA(1);
						 
						int index130_34 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_34==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 54;}
						else if ( (LA130_34==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 55;}
						else if ( (LA130_34==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 56;}
						else if ( (LA130_34==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 57;}
						else if ( (LA130_34==ID) && ((Keyword_IdFollows("annotate")))) {s = 58;}
						 
						input.seek(index130_34);
						if ( s>=0 ) return s;
						break;

					case 172 : 
						int LA130_78 = input.LA(1);
						 
						int index130_78 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_78==REAL) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 104;}
						else if ( (LA130_78==MTIMES) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 105;}
						else if ( (LA130_78==DOTDOT) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 106;}
						else if ( (LA130_78==RSQUARE) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))||(Keyword_IdFollows("annotate"))))) {s = 107;}
						else if ( (LA130_78==ID) && ((Keyword_IdFollows("annotate")))) {s = 58;}
						 
						input.seek(index130_78);
						if ( s>=0 ) return s;
						break;

					case 173 : 
						int LA130_134 = input.LA(1);
						 
						int index130_134 = input.index();
						input.rewind();
						s = -1;
						if ( (LA130_134==RPAREN) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 110;}
						else if ( (LA130_134==COMMA) && (((Keyword_IdFollows("execution"))||(Keyword_IdFollows("call"))))) {s = 109;}
						 
						input.seek(index130_134);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 130, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	public static final BitSet FOLLOW_scriptFile_in_file387 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_functionFile_in_file398 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_classFile_in_file409 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectFile_in_file420 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_statements_in_scriptFile438 = new BitSet(new long[]{0x0000000000000000L});
	public static final BitSet FOLLOW_EOF_in_scriptFile440 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_statement_in_statements462 = new BitSet(new long[]{0x84C05CAB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_xEOS_in_statements466 = new BitSet(new long[]{0x84C05CAB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_openFunctionFile_in_functionFile491 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_closeFunctionFile_in_functionFile503 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_openFunctionFile523 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_openFunctions_in_openFunctionFile527 = new BitSet(new long[]{0x0000000000000000L});
	public static final BitSet FOLLOW_EOF_in_openFunctionFile529 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_openFunction_in_openFunctions548 = new BitSet(new long[]{0x0000004000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_openFunction566 = new BitSet(new long[]{0x0080040000000000L});
	public static final BitSet FOLLOW_functionSignature_in_openFunction568 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_openBody_in_openFunction570 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_outputPortion_in_functionSignature592 = new BitSet(new long[]{0x0000040100000000L});
	public static final BitSet FOLLOW_functionName_in_functionSignature594 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_functionSignature597 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_functionSignature623 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_functionSignature626 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_output_in_outputPortion652 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_outputPortion654 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_outputVector_in_outputPortion667 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_outputPortion669 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_output690 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_name708 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_outputVector726 = new BitSet(new long[]{0x0000040000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_vectorOutputs_in_outputVector729 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_outputVector733 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_vectorOutput_in_vectorOutputs749 = new BitSet(new long[]{0x0000040000008002L});
	public static final BitSet FOLLOW_COMMA_in_vectorOutputs756 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_vectorOutput_in_vectorOutputs760 = new BitSet(new long[]{0x0000040000008002L});
	public static final BitSet FOLLOW_name_in_vectorOutput778 = new BitSet(new long[]{0x0000000000000082L});
	public static final BitSet FOLLOW_filter_in_vectorOutput784 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_in_filter809 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_classReference_in_filter811 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xFUNCTIONID_in_functionName824 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_inputPortion842 = new BitSet(new long[]{0x8000040000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_parameters_in_inputPortion845 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_inputPortion849 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parameter_in_parameters865 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_parameters868 = new BitSet(new long[]{0x8000040000000000L});
	public static final BitSet FOLLOW_parameter_in_parameters870 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_parameterName_in_parameter888 = new BitSet(new long[]{0x0000000000000082L});
	public static final BitSet FOLLOW_filter_in_parameter894 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xPARAMETERID_in_parameterName919 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xEOS_in_openBody938 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_openItems_in_openBody940 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_openItem_in_openItems959 = new BitSet(new long[]{0x84C05CAB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_xEOS_in_openItems963 = new BitSet(new long[]{0x84C05CAB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statement_in_openItem981 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_closeFunctionFile997 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_closeFunctions_in_closeFunctionFile1001 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOL_in_closeFunctionFile1004 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOF_in_closeFunctionFile1008 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_closeFunction_in_closeFunctions1026 = new BitSet(new long[]{0x0000004200000002L});
	public static final BitSet FOLLOW_EOL_in_closeFunctions1030 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_closeFunction_in_closeFunctions1034 = new BitSet(new long[]{0x0000004200000002L});
	public static final BitSet FOLLOW_FUNCTION_in_closeFunction1052 = new BitSet(new long[]{0x0080040000000000L});
	public static final BitSet FOLLOW_functionSignature_in_closeFunction1054 = new BitSet(new long[]{0x0000000300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_closeBody_in_closeFunction1056 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_closeFunction1058 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xEOS_in_closeBody1081 = new BitSet(new long[]{0x84C05CEB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_closeItems_in_closeBody1083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_closeItem_in_closeItems1102 = new BitSet(new long[]{0x84C05CEB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_xEOS_in_closeItems1106 = new BitSet(new long[]{0x84C05CEB00058482L,0x00000000A5426270L});
	public static final BitSet FOLLOW_nestedFunction_in_closeItem1124 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_statement_in_closeItem1142 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_nestedFunction1159 = new BitSet(new long[]{0x0080040000000000L});
	public static final BitSet FOLLOW_functionSignature_in_nestedFunction1161 = new BitSet(new long[]{0x0000000300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_closeBody_in_nestedFunction1163 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_nestedFunction1165 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_classFile1191 = new BitSet(new long[]{0x0000000200002000L});
	public static final BitSet FOLLOW_classDef_in_classFile1195 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_EOL_in_classFile1198 = new BitSet(new long[]{0x0000004200000000L});
	public static final BitSet FOLLOW_closeFunctions_in_classFile1203 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOL_in_classFile1206 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOF_in_classFile1212 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CLASSDEF_in_classDef1235 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_annotationPortion_in_classDef1238 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_name_in_classDef1242 = new BitSet(new long[]{0x0100000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_genealogyPortion_in_classDef1245 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_classDef1249 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_sections_in_classDef1251 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_classDef1253 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_annotationPortion1285 = new BitSet(new long[]{0x8000040000000000L});
	public static final BitSet FOLLOW_attributes_in_annotationPortion1287 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_annotationPortion1289 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_attribute_in_attributes1302 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_attributes1305 = new BitSet(new long[]{0x8000040000000000L});
	public static final BitSet FOLLOW_attribute_in_attributes1307 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_NOT_in_attribute1325 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_name_in_attribute1327 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_attribute1359 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_attribute1397 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_attribute1399 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_attribute1401 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LT_in_genealogyPortion1425 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_baseClasses_in_genealogyPortion1427 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_classReference_in_baseClasses1440 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_AND_in_baseClasses1443 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_classReference_in_baseClasses1445 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_fullClassName_in_classReference1463 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_fullClassName1481 = new BitSet(new long[]{0x0000000008000002L});
	public static final BitSet FOLLOW_DOT_in_fullClassName1487 = new BitSet(new long[]{0x00000CE1C0043C00L,0x00000000A4404038L});
	public static final BitSet FOLLOW_xANYID_in_fullClassName1489 = new BitSet(new long[]{0x0000000008000002L});
	public static final BitSet FOLLOW_section_in_sections1515 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_sections1519 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_eventSection_in_section1537 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_propertySection_in_section1547 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_methodSection_in_section1557 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumerationSection_in_section1567 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xEVENTS_in_eventSection1584 = new BitSet(new long[]{0x0040040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_annotationPortion_in_eventSection1587 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_events_in_eventSection1591 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_eventSection1593 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_event_in_events1620 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_events1624 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_name_in_event1642 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_event1644 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xPROPERTIES_in_propertySection1664 = new BitSet(new long[]{0x0040040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_annotationPortion_in_propertySection1667 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_properties_in_propertySection1671 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_propertySection1673 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_property_in_properties1700 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_properties1704 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_name_in_property1722 = new BitSet(new long[]{0x00000000000000C2L});
	public static final BitSet FOLLOW_filter_in_property1725 = new BitSet(new long[]{0x0000000000000042L});
	public static final BitSet FOLLOW_ASSIGN_in_property1730 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_property1732 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xMETHODS_in_methodSection1764 = new BitSet(new long[]{0x00C0044300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_annotationPortion_in_methodSection1767 = new BitSet(new long[]{0x0080044300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_methods_in_methodSection1771 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_methodSection1773 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_method_in_methods1800 = new BitSet(new long[]{0x0080044200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_methods1804 = new BitSet(new long[]{0x0080044200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_regularMethod_in_method1822 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_externalMethod_in_method1834 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_regularMethod1851 = new BitSet(new long[]{0x0080040000000000L});
	public static final BitSet FOLLOW_methodSignature_in_regularMethod1853 = new BitSet(new long[]{0x0000000300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_closeBody_in_regularMethod1855 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_regularMethod1857 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_outputPortion_in_methodSignature1888 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_methodName1_in_methodSignature1892 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_methodSignature1895 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_outputPortion_in_methodSignature1915 = new BitSet(new long[]{0x0000040100000000L});
	public static final BitSet FOLLOW_methodName2_in_methodSignature1917 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_methodSignature1920 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_methodName3_in_methodSignature1940 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_inputPortion_in_methodSignature1943 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_methodName11967 = new BitSet(new long[]{0x0000000008000000L});
	public static final BitSet FOLLOW_DOT_in_methodName11969 = new BitSet(new long[]{0x0000040100000000L});
	public static final BitSet FOLLOW_xFUNCTIONID_in_methodName11971 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xFUNCTIONID_in_methodName21991 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_methodName32009 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_methodSignature_in_externalMethod2027 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_externalMethod2029 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xENUMERATION_in_enumerationSection2049 = new BitSet(new long[]{0x0040040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_annotationPortion_in_enumerationSection2052 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_enumerations_in_enumerationSection2056 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_enumerationSection2058 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumeration_in_enumerations2085 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_enumerations2089 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_name_in_enumeration2107 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_call_in_enumeration2110 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_call2140 = new BitSet(new long[]{0x84C0540100000080L,0x000000000100A240L});
	public static final BitSet FOLLOW_expressions_in_call2143 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_call2147 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expressions2167 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_expressions2170 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_expressions2172 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_assignment_in_statement2197 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_action_in_statement2220 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simpleCommand_in_statement2237 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_abortCommand_in_statement2254 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_standardCommand_in_statement2266 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_bang_in_statement2278 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_breakDef_in_statement2296 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_continueDef_in_statement2314 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_forDef_in_statement2332 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_global_in_statement2350 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ifDef_in_statement2368 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parfor_in_statement2386 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_persistent_in_statement2404 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_returnDef_in_statement2422 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_spmd_in_statement2434 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_switchDef_in_statement2452 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_tryDef_in_statement2470 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_whileDef_in_statement2488 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assignmentCore_in_assignment2516 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_chain_in_assignmentCore2529 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_assignmentCore2531 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_assignmentCore2533 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_assignmentCore2535 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_storage_in_assignmentCore2557 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_assignmentCore2559 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_assignmentCore2561 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_assignmentCore2563 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_storage2595 = new BitSet(new long[]{0x8000040000008000L,0x0000000000000200L});
	public static final BitSet FOLLOW_COMMA_in_storage2598 = new BitSet(new long[]{0x8000040000000000L,0x0000000000000200L});
	public static final BitSet FOLLOW_slots_in_storage2602 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_COMMA_in_storage2605 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_storage2609 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_slot_in_slots2631 = new BitSet(new long[]{0x8000040000008002L,0x0000000000000200L});
	public static final BitSet FOLLOW_COMMA_in_slots2638 = new BitSet(new long[]{0x8000040000000000L,0x0000000000000200L});
	public static final BitSet FOLLOW_slot_in_slots2642 = new BitSet(new long[]{0x8000040000008002L,0x0000000000000200L});
	public static final BitSet FOLLOW_chain_in_slot2660 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_metaclass_in_slot2670 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOT_in_slot2680 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_action2711 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_action2713 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_simpleCommand2738 = new BitSet(new long[]{0xFF3FBFFDFFF77FF0L,0xFFFFFFFFEFFC73FFL,0x0000001FFFFFFFFFL});
	public static final BitSet FOLLOW_simpleTexts_in_simpleCommand2740 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_simpleCommand2742 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simpleText_in_simpleTexts2769 = new BitSet(new long[]{0xFF3FBFFDFFF77FF2L,0xFFFFFFFFEFFC73FFL,0x0000001FFFFFFFFFL});
	public static final BitSet FOLLOW_simpleText_in_simpleTexts2775 = new BitSet(new long[]{0xFF3FBFFDFFF77FF2L,0xFFFFFFFFEFFC73FFL,0x0000001FFFFFFFFFL});
	public static final BitSet FOLLOW_simpleBlock_in_simpleText2801 = new BitSet(new long[]{0xFF3FBFFDFFF77FF2L,0xFFFFFFFFEFFC73FFL,0x0000001FFFFFFFFFL});
	public static final BitSet FOLLOW_simpleBlock_in_simpleText2820 = new BitSet(new long[]{0xFF3FBFFDFFF77FF2L,0xFFFFFFFFEFFC73FFL,0x0000001FFFFFFFFFL});
	public static final BitSet FOLLOW_STRING_in_simpleBlock2848 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_set_in_simpleBlock2857 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_abortCommand2926 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMAND_in_standardCommand2943 = new BitSet(new long[]{0x0000000000100000L,0x0000000002000000L});
	public static final BitSet FOLLOW_standardTexts_in_standardCommand2945 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_standardCommand2947 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_standardText_in_standardTexts2985 = new BitSet(new long[]{0x0000000000100002L,0x0000000002000000L});
	public static final BitSet FOLLOW_standardText_in_standardTexts2991 = new BitSet(new long[]{0x0000000000100002L,0x0000000002000000L});
	public static final BitSet FOLLOW_standardBlock_in_standardText3017 = new BitSet(new long[]{0x0000000000100002L,0x0000000002000000L});
	public static final BitSet FOLLOW_standardBlock_in_standardText3036 = new BitSet(new long[]{0x0000000000100002L,0x0000000002000000L});
	public static final BitSet FOLLOW_STRINGBLOCK_in_standardBlock3065 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DEFAULTBLOCK_in_standardBlock3074 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EXCLAMATION_in_bang3093 = new BitSet(new long[]{0x0002000000000000L});
	public static final BitSet FOLLOW_LINE_in_bang3095 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_xEOL_in_bang3099 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_BREAK_in_breakDef3121 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_breakDef3123 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CONTINUE_in_continueDef3142 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_continueDef3144 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FOR_in_forDef3163 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_forHead_in_forDef3165 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_forDef3167 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_forDef3169 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_forDef3171 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_forHead3195 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_forHead3197 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_forHead3199 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_forHead3211 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_forHead3213 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_forHead3215 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_forHead3217 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_forHead3219 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_GLOBAL_in_global3238 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_global3241 = new BitSet(new long[]{0x0000040200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_global3245 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ifPart_in_ifDef3269 = new BitSet(new long[]{0x00000001C0000000L});
	public static final BitSet FOLLOW_elseIfPart_in_ifDef3272 = new BitSet(new long[]{0x00000001C0000000L});
	public static final BitSet FOLLOW_elsePart_in_ifDef3277 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_ifDef3281 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_ifDef3283 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IF_in_ifPart3313 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_ifPart3315 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_ifPart3317 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ELSEIF_in_elseIfPart3339 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_elseIfPart3341 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_elseIfPart3343 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ELSE_in_elsePart3365 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_elsePart3367 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PARFOR_in_parfor3389 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_parforHead_in_parfor3391 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_parfor3393 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_parfor3395 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_parfor3397 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parforHead3434 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_parforHead3436 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_parforHead3438 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parforHead3440 = new BitSet(new long[]{0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_parforHead3442 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parforHead3444 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_parforHead3446 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parforHead3464 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_parforHead3466 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_parforHead3468 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parforHead3470 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_parforHead3472 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_parforHead3487 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_parforHead3489 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parforHead3491 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERSISTENT_in_persistent3513 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_persistent3516 = new BitSet(new long[]{0x0000040200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_persistent3520 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RETURN_in_returnDef3544 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_returnDef3546 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SPMD_in_spmd3565 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_spmdHead_in_spmd3576 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_spmd3580 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_spmd3582 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_spmd3584 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_spmdHead3611 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_spmdHead3613 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_spmdHead3616 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_spmdHead3618 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_spmdHead3622 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_switchPart_in_switchDef3640 = new BitSet(new long[]{0x0000000100000800L,0x0000000000000008L});
	public static final BitSet FOLLOW_casePart_in_switchDef3643 = new BitSet(new long[]{0x0000000100000800L,0x0000000000000008L});
	public static final BitSet FOLLOW_otherwisePart_in_switchDef3648 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_switchDef3652 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_switchDef3654 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SWITCH_in_switchPart3684 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_switchPart3686 = new BitSet(new long[]{0x0000000200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_switchPart3689 = new BitSet(new long[]{0x0000000200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_CASE_in_casePart3708 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_casePart3710 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_casePart3712 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_casePart3714 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OTHERWISE_in_otherwisePart3736 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_otherwisePart3738 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_tryPart_in_tryDef3760 = new BitSet(new long[]{0x0000000100001000L});
	public static final BitSet FOLLOW_catchPart_in_tryDef3763 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_tryDef3767 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_tryDef3769 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TRY_in_tryPart3794 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_tryPart3796 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CATCH_in_catchPart3816 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_capturePortion_in_catchPart3830 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_catchPart3834 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_capturePortion3859 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_capturePortion3861 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WHILE_in_whileDef3876 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_whileDef3878 = new BitSet(new long[]{0x84C05CAB00058480L,0x00000000A5426270L});
	public static final BitSet FOLLOW_statements_in_whileDef3880 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_whileDef3882 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_whileDef3884 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression11_in_expression3910 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression10_in_expression113926 = new BitSet(new long[]{0x0000000000000002L,0x0000000000080000L});
	public static final BitSet FOLLOW_SHORTOR_in_expression113943 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression10_in_expression113947 = new BitSet(new long[]{0x0000000000000002L,0x0000000000080000L});
	public static final BitSet FOLLOW_expression09_in_expression103973 = new BitSet(new long[]{0x0000000000000002L,0x0000000000040000L});
	public static final BitSet FOLLOW_SHORTAND_in_expression103990 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression09_in_expression103994 = new BitSet(new long[]{0x0000000000000002L,0x0000000000040000L});
	public static final BitSet FOLLOW_expression08_in_expression094020 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000004L});
	public static final BitSet FOLLOW_OR_in_expression094037 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression08_in_expression094041 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000004L});
	public static final BitSet FOLLOW_expression07_in_expression084067 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_AND_in_expression084084 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression07_in_expression084088 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_expression06_in_expression074114 = new BitSet(new long[]{0x0300030400000002L,0x0000000000000001L});
	public static final BitSet FOLLOW_operator06_in_expression074133 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression06_in_expression074137 = new BitSet(new long[]{0x0300030400000002L,0x0000000000000001L});
	public static final BitSet FOLLOW_LT_in_operator064161 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LTEQ_in_operator064174 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_GT_in_operator064187 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_GTEQ_in_operator064200 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EQ_in_operator064213 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOTEQ_in_operator064226 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression05_in_expression064247 = new BitSet(new long[]{0x0000000000004002L});
	public static final BitSet FOLLOW_COLON_in_expression064273 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression05_in_expression064277 = new BitSet(new long[]{0x0000000000004002L});
	public static final BitSet FOLLOW_expression04_in_expression054304 = new BitSet(new long[]{0x0400000000000002L,0x0000000000000040L});
	public static final BitSet FOLLOW_operator04_in_expression054326 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression04_in_expression054330 = new BitSet(new long[]{0x0400000000000002L,0x0000000000000040L});
	public static final BitSet FOLLOW_PLUS_in_operator044354 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_operator044367 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression03_in_expression044388 = new BitSet(new long[]{0x6800800000000002L,0x0000000008001000L});
	public static final BitSet FOLLOW_operator03_in_expression044407 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression03_in_expression044411 = new BitSet(new long[]{0x6800800000000002L,0x0000000008001000L});
	public static final BitSet FOLLOW_TIMES_in_operator034435 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RDIV_in_operator034448 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LDIV_in_operator034461 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MTIMES_in_operator034474 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MRDIV_in_operator034487 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MLDIV_in_operator034500 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_operator02_in_expression034520 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression03_in_expression034524 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression02_in_expression034544 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_operator024562 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_operator024576 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOT_in_operator024590 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression00_in_expression024611 = new BitSet(new long[]{0x1000000000080002L,0x0000000010000100L});
	public static final BitSet FOLLOW_operator01_in_expression024646 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression01_in_expression024650 = new BitSet(new long[]{0x1000000000080002L,0x0000000010000100L});
	public static final BitSet FOLLOW_TRANS_in_expression024675 = new BitSet(new long[]{0x1000000000080002L,0x0000000010000100L});
	public static final BitSet FOLLOW_CTRANS_in_expression024696 = new BitSet(new long[]{0x1000000000080002L,0x0000000010000100L});
	public static final BitSet FOLLOW_POW_in_operator014724 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MPOW_in_operator014737 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_operator02_in_expression014757 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression01_in_expression014761 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression00_in_expression014781 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_atom_in_expression004799 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_chain_in_atom4814 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_real_in_atom4827 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_imaginary_in_atom4837 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_stringDef_in_atom4847 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_regularArray_in_atom4857 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cellArray_in_atom4867 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_parenthesized_in_atom4877 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_end_in_atom4887 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_functionHandle_in_atom4897 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_anonymousFunction_in_atom4907 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_metaclass_in_atom4917 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_var_in_chain4942 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_dotExpressionOperator_in_chain4963 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_dotNameOperator_in_chain4984 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_parenthesisOperator_in_chain5005 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_curlyBraceOperator_in_chain5029 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_atBaseOperator_in_chain5050 = new BitSet(new long[]{0x0040400008000082L});
	public static final BitSet FOLLOW_name_in_var5079 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOT_in_dotExpressionOperator5105 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_dotExpressionOperator5107 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_dotExpressionOperator5109 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_dotExpressionOperator5111 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOT_in_dotNameOperator5131 = new BitSet(new long[]{0x00000CE1C0043C00L,0x00000000A4404038L});
	public static final BitSet FOLLOW_anyName_in_dotNameOperator5133 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xANYID_in_anyName5150 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesisOperator5179 = new BitSet(new long[]{0x84C0540100004080L,0x000000000100A240L});
	public static final BitSet FOLLOW_arguments_in_parenthesisOperator5182 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesisOperator5186 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_argument_in_arguments5206 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_arguments5209 = new BitSet(new long[]{0x84C0540100004080L,0x0000000001002240L});
	public static final BitSet FOLLOW_argument_in_arguments5211 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_expression_in_argument5229 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COLON_in_argument5240 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LCURLY_in_curlyBraceOperator5268 = new BitSet(new long[]{0x84C0540100004080L,0x0000000001002240L});
	public static final BitSet FOLLOW_arguments_in_curlyBraceOperator5270 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_RCURLY_in_curlyBraceOperator5272 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_in_atBaseOperator5295 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_classReference_in_atBaseOperator5297 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REAL_in_real5316 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IMAGINARY_in_imaginary5331 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_STRING_in_stringDef5346 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_regularArray5368 = new BitSet(new long[]{0x84C0540300008080L,0x0000000001022240L});
	public static final BitSet FOLLOW_rows_in_regularArray5370 = new BitSet(new long[]{0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_regularArray5372 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_row_in_rows5399 = new BitSet(new long[]{0x0000000200000002L,0x0000000000020000L});
	public static final BitSet FOLLOW_SEMICOLON_in_rows5403 = new BitSet(new long[]{0x84C0540300008080L,0x0000000001022240L});
	public static final BitSet FOLLOW_EOL_in_rows5407 = new BitSet(new long[]{0x84C0540300008080L,0x0000000001022240L});
	public static final BitSet FOLLOW_row_in_rows5410 = new BitSet(new long[]{0x0000000200000002L,0x0000000000020000L});
	public static final BitSet FOLLOW_COMMA_in_row5429 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_columns_in_row5433 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_row5436 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_row5452 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_column_in_columns5478 = new BitSet(new long[]{0x84C0540100008082L,0x0000000001002240L});
	public static final BitSet FOLLOW_COMMA_in_columns5485 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_column_in_columns5489 = new BitSet(new long[]{0x84C0540100008082L,0x0000000001002240L});
	public static final BitSet FOLLOW_NOT_in_column5528 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_column5551 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LCURLY_in_cellArray5575 = new BitSet(new long[]{0x84C0540300008080L,0x0000000001022240L});
	public static final BitSet FOLLOW_rows_in_cellArray5577 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_RCURLY_in_cellArray5579 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_parenthesized5613 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_parenthesized5615 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_parenthesized5617 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_END_in_end5639 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_AT_in_functionHandle5654 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_functionReference_in_functionHandle5656 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_fullFunctioName_in_functionReference5674 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xID_in_fullFunctioName5692 = new BitSet(new long[]{0x0000000008000002L});
	public static final BitSet FOLLOW_DOT_in_fullFunctioName5695 = new BitSet(new long[]{0x00000CE1C0043C00L,0x00000000A4404038L});
	public static final BitSet FOLLOW_xANYID_in_fullFunctioName5697 = new BitSet(new long[]{0x0000000008000002L});
	public static final BitSet FOLLOW_AT_in_anonymousFunction5724 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_inputPortion_in_anonymousFunction5726 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_anonymousFunction5728 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_QUESTION_in_metaclass5753 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_classReference_in_metaclass5755 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SEMICOLON_in_xEOS5774 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_xEOS5785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_xEOS5796 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_xEOL5812 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xID5826 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xANYID5839 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_BREAK_in_xANYID5851 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CASE_in_xANYID5864 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CATCH_in_xANYID5877 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CLASSDEF_in_xANYID5890 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CONTINUE_in_xANYID5903 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ELSE_in_xANYID5916 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ELSEIF_in_xANYID5929 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_END_in_xANYID5942 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FOR_in_xANYID5955 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_xANYID5968 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_GLOBAL_in_xANYID5981 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IF_in_xANYID5994 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OTHERWISE_in_xANYID6007 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PARFOR_in_xANYID6020 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERSISTENT_in_xANYID6033 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RETURN_in_xANYID6046 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SPMD_in_xANYID6059 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SWITCH_in_xANYID6072 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TRY_in_xANYID6085 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WHILE_in_xANYID6098 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xFUNCTIONID6116 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_END_in_xFUNCTIONID6127 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xPARAMETERID6144 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOT_in_xPARAMETERID6156 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xEVENTS6177 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xPROPERTIES6193 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xMETHODS6209 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_xENUMERATION6225 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_EOL_in_aspectFile6241 = new BitSet(new long[]{0x0000000200000020L});
	public static final BitSet FOLLOW_aspectDef_in_aspectFile6245 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOL_in_aspectFile6248 = new BitSet(new long[]{0x0000000200000000L});
	public static final BitSet FOLLOW_EOF_in_aspectFile6252 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ASPECT_in_aspectDef6270 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_name_in_aspectDef6272 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectDef6274 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectSections_in_aspectDef6276 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_aspectDef6278 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectSection_in_aspectSections6301 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectSections6305 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_eventSection_in_aspectSection6323 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_propertySection_in_aspectSection6336 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_methodSection_in_aspectSection6352 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_enumerationSection_in_aspectSection6368 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectPatternSection_in_aspectSection6381 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectActionSection_in_aspectSection6394 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wACTIONS_in_aspectActionSection6417 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectActions_in_aspectActionSection6419 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_aspectActionSection6421 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectAction_in_aspectActions6443 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectActions6447 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectActionSignature_in_aspectAction6465 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectActionBody_in_aspectAction6467 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_aspectAction6469 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_aspectActionSignature6490 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectActionSignature6492 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_aspectActionType_in_aspectActionSignature6494 = new BitSet(new long[]{0x8040040000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectActionSignature6497 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression_in_aspectActionSignature6501 = new BitSet(new long[]{0x0000000000004002L});
	public static final BitSet FOLLOW_COLON_in_aspectActionSignature6504 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_inputPortion_in_aspectActionSignature6506 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wBEFORE_in_aspectActionType6530 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wAFTER_in_aspectActionType6555 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wAROUND_in_aspectActionType6568 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_closeBody_in_aspectActionBody6586 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wPATTERNS_in_aspectPatternSection6604 = new BitSet(new long[]{0x0000040300008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_aspectPatterns_in_aspectPatternSection6606 = new BitSet(new long[]{0x0000000100000000L});
	public static final BitSet FOLLOW_END_in_aspectPatternSection6608 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectPattern_in_aspectPatterns6630 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectPatterns6634 = new BitSet(new long[]{0x0000040200008002L,0x0000000000020000L});
	public static final BitSet FOLLOW_name_in_aspectPattern6652 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectPattern6654 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression_in_aspectPattern6656 = new BitSet(new long[]{0x0000000200008000L,0x0000000000020000L});
	public static final BitSet FOLLOW_xEOS_in_aspectPattern6658 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectExpression04_in_aspectExpression6677 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectExpression03_in_aspectExpression046693 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000004L});
	public static final BitSet FOLLOW_OR_in_aspectExpression046710 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression03_in_aspectExpression046714 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000004L});
	public static final BitSet FOLLOW_aspectExpression02_in_aspectExpression036740 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_AND_in_aspectExpression036757 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression02_in_aspectExpression036761 = new BitSet(new long[]{0x0000000000000012L});
	public static final BitSet FOLLOW_NOT_in_aspectExpression026784 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression02_in_aspectExpression026788 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectExpression01_in_aspectExpression026813 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectAtom_in_aspectExpression016837 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectParenthesis_in_aspectAtom6850 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectName_in_aspectAtom6869 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectGet_in_aspectAtom6888 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectSet_in_aspectAtom6907 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectCall_in_aspectAtom6926 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectExecution_in_aspectAtom6945 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectMainExecution_in_aspectAtom6964 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectLoop_in_aspectAtom6983 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectLoopHead_in_aspectAtom7002 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectLoopBody_in_aspectAtom7021 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectAnnotate_in_aspectAtom7040 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectOperator_in_aspectAtom7059 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectWithin_in_aspectAtom7078 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectDimension_in_aspectAtom7097 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectIsType_in_aspectAtom7116 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_aspectParenthesis7140 = new BitSet(new long[]{0x8040040000000000L});
	public static final BitSet FOLLOW_aspectExpression_in_aspectParenthesis7142 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectParenthesis7144 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_name_in_aspectName7157 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wID_in_aspectIdentifier7175 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectIdentifier7200 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectIdentifier7225 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wID_in_aspectTypeSignature7255 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectTypeSignature7287 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectTypeSignature7319 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wREAL_in_aspectPartSignature7356 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectPartSignature7384 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectPartSignature7412 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_aspectDimensionSignature7445 = new BitSet(new long[]{0x4000000010000000L,0x0000000000012000L});
	public static final BitSet FOLLOW_aspectPartSignature_in_aspectDimensionSignature7448 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_COMMA_in_aspectDimensionSignature7451 = new BitSet(new long[]{0x4000000010000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_aspectPartSignature_in_aspectDimensionSignature7453 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_aspectDimensionSignature7459 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectTypeSignature_in_aspectFullSignature7479 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectTypeSignature_in_aspectFullSignature7511 = new BitSet(new long[]{0x0080000000000000L});
	public static final BitSet FOLLOW_aspectDimensionSignature_in_aspectFullSignature7513 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectDimensionSignature_in_aspectFullSignature7548 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wGET_in_aspectGet7586 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectGet7588 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectGet7590 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectGet7593 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectGet7595 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectGet7599 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSET_in_aspectSet7621 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectSet7623 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectSet7625 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectSet7628 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectSet7630 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectSet7634 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectInput7657 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_aspectInput7660 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectInput7662 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectOutput7683 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_COMMA_in_aspectOutput7686 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectOutput7688 = new BitSet(new long[]{0x0000000000008002L});
	public static final BitSet FOLLOW_wCALL_in_aspectCall7709 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectCall7711 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectCall7713 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectCall7715 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectInput_in_aspectCall7717 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectCall7719 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectCall7722 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectOutput_in_aspectCall7724 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectCall7728 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wEXECUTION_in_aspectExecution7763 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectExecution7765 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectExecution7767 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectExecution7769 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectInput_in_aspectExecution7771 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectExecution7773 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectExecution7776 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectOutput_in_aspectExecution7778 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectExecution7782 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMAINEXECUTION_in_aspectMainExecution7817 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectMainExecution7819 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectMainExecution7821 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wFOR_in_aspectLoopType7834 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wWHILE_in_aspectLoopType7857 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectLoopType7880 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectLoopType7903 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLOOP_in_aspectLoop7931 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectLoop7933 = new BitSet(new long[]{0x4000042010000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_aspectLoopType_in_aspectLoop7936 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectLoop7938 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectLoop7942 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectLoop7944 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLOOPBODY_in_aspectLoopBody7965 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectLoopBody7967 = new BitSet(new long[]{0x4000042010000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_aspectLoopType_in_aspectLoopBody7970 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectLoopBody7972 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectLoopBody7976 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectLoopBody7978 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLOOPHEAD_in_aspectLoopHead7999 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectLoopHead8001 = new BitSet(new long[]{0x4000042010000000L,0x0000000080000000L});
	public static final BitSet FOLLOW_aspectLoopType_in_aspectLoopHead8004 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectLoopHead8006 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectLoopHead8010 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectLoopHead8012 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wVAR_in_aspectPartSelector8033 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTR_in_aspectPartSelector8060 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wNUM_in_aspectPartSelector8087 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectPartSelector8114 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectPartSelector8141 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectPartSelector_in_aspectSimpleSelector8173 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LSQUARE_in_aspectCompoundSelector8190 = new BitSet(new long[]{0x4000040010000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_aspectPartSelector_in_aspectCompoundSelector8193 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_COMMA_in_aspectCompoundSelector8196 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectPartSelector_in_aspectCompoundSelector8198 = new BitSet(new long[]{0x0000000000008000L,0x0000000000010000L});
	public static final BitSet FOLLOW_RSQUARE_in_aspectCompoundSelector8204 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectSimpleSelector_in_aspectSelector8223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aspectCompoundSelector_in_aspectSelector8246 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wANNOTATE_in_aspectAnnotate8274 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectAnnotate8276 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectAnnotate8278 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectAnnotate8280 = new BitSet(new long[]{0x4080040010000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_aspectSelector_in_aspectAnnotate8283 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_aspectAnnotate8286 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectSelector_in_aspectAnnotate8288 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectAnnotate8294 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectAnnotate8296 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wPLUS_in_aspectOperatorType8318 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMINUS_in_aspectOperatorType8345 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMTIMES_in_aspectOperatorType8372 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wTIMES_in_aspectOperatorType8399 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMRDIV_in_aspectOperatorType8426 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wRDIV_in_aspectOperatorType8453 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMLDIV_in_aspectOperatorType8480 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLDIV_in_aspectOperatorType8507 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wMPOW_in_aspectOperatorType8534 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wPOW_in_aspectOperatorType8561 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wCTRANS_in_aspectOperatorType8588 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wTRANS_in_aspectOperatorType8615 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wOPERATOR_in_aspectOperator8647 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectOperator8649 = new BitSet(new long[]{0x7C00800000080000L,0x0000000018001140L});
	public static final BitSet FOLLOW_aspectOperatorType_in_aspectOperator8651 = new BitSet(new long[]{0x0000000000004000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COLON_in_aspectOperator8654 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectOperator8656 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_aspectOperator8659 = new BitSet(new long[]{0x4080040010000000L});
	public static final BitSet FOLLOW_aspectFullSignature_in_aspectOperator8661 = new BitSet(new long[]{0x0000000000008000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectOperator8667 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wWITHIN_in_aspectWithin8689 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectWithin8691 = new BitSet(new long[]{0x4000044010000000L});
	public static final BitSet FOLLOW_aspectScopeType_in_aspectWithin8693 = new BitSet(new long[]{0x0000000000004000L});
	public static final BitSet FOLLOW_COLON_in_aspectWithin8695 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectIdentifier_in_aspectWithin8697 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectWithin8699 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wFUNCTION_in_aspectScopeType8718 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSCRIPT_in_aspectScopeType8742 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wCLASS_in_aspectScopeType8766 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wASPECT_in_aspectScopeType8790 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wLOOP_in_aspectScopeType8814 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wSTAR_in_aspectScopeType8838 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDOTDOT_in_aspectScopeType8862 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wDIMENSION_in_aspectDimension8891 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectDimension8893 = new BitSet(new long[]{0x0080000000000000L});
	public static final BitSet FOLLOW_aspectDimensionSignature_in_aspectDimension8895 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectDimension8897 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wISTYPE_in_aspectIsType8913 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_aspectIsType8915 = new BitSet(new long[]{0x4000040010000000L});
	public static final BitSet FOLLOW_aspectTypeSignature_in_aspectIsType8917 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_RPAREN_in_aspectIsType8919 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wID8938 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REAL_in_wREAL8956 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wASPECT8978 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wACTIONS8999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wPATTERNS9020 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wBEFORE9041 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wAFTER9062 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wAROUND9083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wGET9104 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wSET9125 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wCALL9146 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wEXECUTION9167 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wMAINEXECUTION9188 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wLOOP9209 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wLOOPBODY9230 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wLOOPHEAD9251 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wANNOTATE9272 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wOPERATOR9293 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wWITHIN9314 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wDIMENSION9335 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wISTYPE9356 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MTIMES_in_wSTAR9374 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FUNCTION_in_wFUNCTION9393 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wSCRIPT9415 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wLOOPS9436 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wCLASS9457 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOTDOT_in_wDOTDOT9475 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FOR_in_wFOR9494 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WHILE_in_wWHILE9514 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_in_wPLUS9534 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_in_wMINUS9553 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MTIMES_in_wMTIMES9572 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TIMES_in_wTIMES9591 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MRDIV_in_wMRDIV9610 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_RDIV_in_wRDIV9629 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MLDIV_in_wMLDIV9648 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LDIV_in_wLDIV9667 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MPOW_in_wMPOW9686 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_POW_in_wPOW9705 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TRANS_in_wTRANS9724 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_CTRANS_in_wCTRANS9743 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wVAR9765 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wSTR9786 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_wNUM9807 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_openFunctionFile_in_synpred1_MatlabParser487 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_assignment_in_synpred2_MatlabParser2193 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_action_in_synpred3_MatlabParser2216 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simpleCommand_in_synpred4_MatlabParser2233 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_abortCommand_in_synpred5_MatlabParser2250 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LPAREN_in_synpred6_MatlabParser3422 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_var_in_synpred6_MatlabParser3424 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_synpred6_MatlabParser3426 = new BitSet(new long[]{0x84C0540100000080L,0x0000000001002240L});
	public static final BitSet FOLLOW_expression_in_synpred6_MatlabParser3428 = new BitSet(new long[]{0x0000000000008000L});
	public static final BitSet FOLLOW_COMMA_in_synpred6_MatlabParser3430 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DOT_in_synpred7_MatlabParser4955 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_LPAREN_in_synpred7_MatlabParser4957 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_NOT_in_synpred8_MatlabParser5508 = new BitSet(new long[]{0x0000000200008000L,0x0000000000030000L});
	public static final BitSet FOLLOW_set_in_synpred8_MatlabParser5510 = new BitSet(new long[]{0x0000000000000002L});
}
